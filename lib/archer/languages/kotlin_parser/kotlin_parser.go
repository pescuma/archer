// Code generated from KotlinParser.g4 by ANTLR 4.12.0. DO NOT EDIT.

package kotlin_parser // KotlinParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type KotlinParser struct {
	*antlr.BaseParser
}

var kotlinparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func kotlinparserParserInit() {
	staticData := &kotlinparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "", "'...'", "'.'", "','", "'('", "')'", "'['",
		"']'", "'{'", "'}'", "'*'", "'%'", "'/'", "'+'", "'-'", "'++'", "'--'",
		"'&&'", "'||'", "", "'!'", "':'", "';'", "'='", "'+='", "'-='", "'*='",
		"'/='", "'%='", "'->'", "'=>'", "'..'", "'::'", "';;'", "'#'", "'@'",
		"", "", "", "", "'?'", "'<'", "'>'", "'<='", "'>='", "'!='", "'!=='",
		"'as?'", "'=='", "'==='", "'''", "'&'", "", "", "", "", "", "'file'",
		"'field'", "'property'", "'get'", "'set'", "'receiver'", "'param'",
		"'setparam'", "'delegate'", "'package'", "'import'", "'class'", "'interface'",
		"'fun'", "'object'", "'val'", "'var'", "'typealias'", "'constructor'",
		"'by'", "'companion'", "'init'", "'this'", "'super'", "'typeof'", "'where'",
		"'if'", "'else'", "'when'", "'try'", "'catch'", "'finally'", "'for'",
		"'do'", "'while'", "'throw'", "'return'", "'continue'", "'break'", "'as'",
		"'is'", "'in'", "", "", "'out'", "'dynamic'", "'public'", "'private'",
		"'protected'", "'internal'", "'enum'", "'sealed'", "'annotation'", "'data'",
		"'inner'", "'value'", "'tailrec'", "'operator'", "'inline'", "'infix'",
		"'external'", "'suspend'", "'override'", "'abstract'", "'final'", "'open'",
		"'const'", "'lateinit'", "'vararg'", "'noinline'", "'crossinline'",
		"'reified'", "'expect'", "'actual'", "", "", "", "", "", "", "", "",
		"", "'null'", "", "", "", "", "", "'\"\"\"'",
	}
	staticData.symbolicNames = []string{
		"", "ShebangLine", "DelimitedComment", "LineComment", "WS", "NL", "RESERVED",
		"DOT", "COMMA", "LPAREN", "RPAREN", "LSQUARE", "RSQUARE", "LCURL", "RCURL",
		"MULT", "MOD", "DIV", "ADD", "SUB", "INCR", "DECR", "CONJ", "DISJ",
		"EXCL_WS", "EXCL_NO_WS", "COLON", "SEMICOLON", "ASSIGNMENT", "ADD_ASSIGNMENT",
		"SUB_ASSIGNMENT", "MULT_ASSIGNMENT", "DIV_ASSIGNMENT", "MOD_ASSIGNMENT",
		"ARROW", "DOUBLE_ARROW", "RANGE", "COLONCOLON", "DOUBLE_SEMICOLON",
		"HASH", "AT_NO_WS", "AT_POST_WS", "AT_PRE_WS", "AT_BOTH_WS", "QUEST_WS",
		"QUEST_NO_WS", "LANGLE", "RANGLE", "LE", "GE", "EXCL_EQ", "EXCL_EQEQ",
		"AS_SAFE", "EQEQ", "EQEQEQ", "SINGLE_QUOTE", "AMP", "RETURN_AT", "CONTINUE_AT",
		"BREAK_AT", "THIS_AT", "SUPER_AT", "FILE", "FIELD", "PROPERTY", "GET",
		"SET", "RECEIVER", "PARAM", "SETPARAM", "DELEGATE", "PACKAGE", "IMPORT",
		"CLASS", "INTERFACE", "FUN", "OBJECT", "VAL", "VAR", "TYPE_ALIAS", "CONSTRUCTOR",
		"BY", "COMPANION", "INIT", "THIS", "SUPER", "TYPEOF", "WHERE", "IF",
		"ELSE", "WHEN", "TRY", "CATCH", "FINALLY", "FOR", "DO", "WHILE", "THROW",
		"RETURN", "CONTINUE", "BREAK", "AS", "IS", "IN", "NOT_IS", "NOT_IN",
		"OUT", "DYNAMIC", "PUBLIC", "PRIVATE", "PROTECTED", "INTERNAL", "ENUM",
		"SEALED", "ANNOTATION", "DATA", "INNER", "VALUE", "TAILREC", "OPERATOR",
		"INLINE", "INFIX", "EXTERNAL", "SUSPEND", "OVERRIDE", "ABSTRACT", "FINAL",
		"OPEN", "CONST", "LATEINIT", "VARARG", "NOINLINE", "CROSSINLINE", "REIFIED",
		"EXPECT", "ACTUAL", "RealLiteral", "FloatLiteral", "DoubleLiteral",
		"IntegerLiteral", "HexLiteral", "BinLiteral", "UnsignedLiteral", "LongLiteral",
		"BooleanLiteral", "NullLiteral", "CharacterLiteral", "Identifier", "IdentifierOrSoftKey",
		"FieldIdentifier", "QUOTE_OPEN", "TRIPLE_QUOTE_OPEN", "UNICODE_CLASS_LL",
		"UNICODE_CLASS_LM", "UNICODE_CLASS_LO", "UNICODE_CLASS_LT", "UNICODE_CLASS_LU",
		"UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "QUOTE_CLOSE", "LineStrRef",
		"LineStrText", "LineStrEscapedChar", "LineStrExprStart", "TRIPLE_QUOTE_CLOSE",
		"MultiLineStringQuote", "MultiLineStrRef", "MultiLineStrText", "MultiLineStrExprStart",
		"Inside_Comment", "Inside_WS", "Inside_NL", "ErrorCharacter",
	}
	staticData.ruleNames = []string{
		"kotlinFile", "script", "shebangLine", "fileAnnotation", "packageHeader",
		"importList", "importHeader", "importAlias", "topLevelObject", "typeAlias",
		"declaration", "classDeclaration", "primaryConstructor", "classBody",
		"classParameters", "classParameter", "delegationSpecifiers", "delegationSpecifier",
		"constructorInvocation", "annotatedDelegationSpecifier", "explicitDelegation",
		"typeParameters", "typeParameter", "typeConstraints", "typeConstraint",
		"classMemberDeclarations", "classMemberDeclaration", "anonymousInitializer",
		"companionObject", "functionValueParameters", "functionValueParameter",
		"functionDeclaration", "functionBody", "variableDeclaration", "multiVariableDeclaration",
		"propertyDeclaration", "propertyDelegate", "getter", "setter", "parametersWithOptionalType",
		"functionValueParameterWithOptionalType", "parameterWithOptionalType",
		"parameter", "objectDeclaration", "secondaryConstructor", "constructorDelegationCall",
		"enumClassBody", "enumEntries", "enumEntry", "type", "typeReference",
		"nullableType", "quest", "userType", "simpleUserType", "typeProjection",
		"typeProjectionModifiers", "typeProjectionModifier", "functionType",
		"functionTypeParameters", "parenthesizedType", "receiverType", "parenthesizedUserType",
		"definitelyNonNullableType", "statements", "statement", "label", "controlStructureBody",
		"block", "loopStatement", "forStatement", "whileStatement", "doWhileStatement",
		"assignment", "semi", "semis", "expression", "disjunction", "conjunction",
		"equality", "comparison", "genericCallLikeComparison", "infixOperation",
		"elvisExpression", "elvis", "infixFunctionCall", "rangeExpression",
		"additiveExpression", "multiplicativeExpression", "asExpression", "prefixUnaryExpression",
		"unaryPrefix", "postfixUnaryExpression", "postfixUnarySuffix", "directlyAssignableExpression",
		"parenthesizedDirectlyAssignableExpression", "assignableExpression",
		"parenthesizedAssignableExpression", "assignableSuffix", "indexingSuffix",
		"navigationSuffix", "callSuffix", "annotatedLambda", "typeArguments",
		"valueArguments", "valueArgument", "primaryExpression", "parenthesizedExpression",
		"collectionLiteral", "literalConstant", "stringLiteral", "lineStringLiteral",
		"multiLineStringLiteral", "lineStringContent", "lineStringExpression",
		"multiLineStringContent", "multiLineStringExpression", "lambdaLiteral",
		"lambdaParameters", "lambdaParameter", "anonymousFunction", "functionLiteral",
		"objectLiteral", "thisExpression", "superExpression", "ifExpression",
		"whenSubject", "whenExpression", "whenEntry", "whenCondition", "rangeTest",
		"typeTest", "tryExpression", "catchBlock", "finallyBlock", "jumpExpression",
		"callableReference", "assignmentAndOperator", "equalityOperator", "comparisonOperator",
		"inOperator", "isOperator", "additiveOperator", "multiplicativeOperator",
		"asOperator", "prefixUnaryOperator", "postfixUnaryOperator", "excl",
		"memberAccessOperator", "safeNav", "modifiers", "parameterModifiers",
		"modifier", "typeModifiers", "typeModifier", "classModifier", "memberModifier",
		"visibilityModifier", "varianceModifier", "typeParameterModifiers",
		"typeParameterModifier", "functionModifier", "propertyModifier", "inheritanceModifier",
		"parameterModifier", "reificationModifier", "platformModifier", "annotation",
		"singleAnnotation", "multiAnnotation", "annotationUseSiteTarget", "unescapedAnnotation",
		"simpleIdentifier", "identifier",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 172, 3492, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 1, 0, 3, 0, 350, 8, 0, 1, 0, 5, 0,
		353, 8, 0, 10, 0, 12, 0, 356, 9, 0, 1, 0, 5, 0, 359, 8, 0, 10, 0, 12, 0,
		362, 9, 0, 1, 0, 1, 0, 1, 0, 5, 0, 367, 8, 0, 10, 0, 12, 0, 370, 9, 0,
		1, 0, 1, 0, 1, 1, 3, 1, 375, 8, 1, 1, 1, 5, 1, 378, 8, 1, 10, 1, 12, 1,
		381, 9, 1, 1, 1, 5, 1, 384, 8, 1, 10, 1, 12, 1, 387, 9, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 5, 1, 394, 8, 1, 10, 1, 12, 1, 397, 9, 1, 1, 1, 1, 1,
		1, 2, 1, 2, 4, 2, 403, 8, 2, 11, 2, 12, 2, 404, 1, 3, 1, 3, 1, 3, 5, 3,
		410, 8, 3, 10, 3, 12, 3, 413, 9, 3, 1, 3, 1, 3, 5, 3, 417, 8, 3, 10, 3,
		12, 3, 420, 9, 3, 1, 3, 1, 3, 4, 3, 424, 8, 3, 11, 3, 12, 3, 425, 1, 3,
		1, 3, 1, 3, 3, 3, 431, 8, 3, 1, 3, 5, 3, 434, 8, 3, 10, 3, 12, 3, 437,
		9, 3, 1, 4, 1, 4, 1, 4, 3, 4, 442, 8, 4, 3, 4, 444, 8, 4, 1, 5, 5, 5, 447,
		8, 5, 10, 5, 12, 5, 450, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 457,
		8, 6, 1, 6, 3, 6, 460, 8, 6, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 3, 8, 467, 8,
		8, 1, 9, 3, 9, 470, 8, 9, 1, 9, 1, 9, 5, 9, 474, 8, 9, 10, 9, 12, 9, 477,
		9, 9, 1, 9, 1, 9, 5, 9, 481, 8, 9, 10, 9, 12, 9, 484, 9, 9, 1, 9, 3, 9,
		487, 8, 9, 1, 9, 5, 9, 490, 8, 9, 10, 9, 12, 9, 493, 9, 9, 1, 9, 1, 9,
		5, 9, 497, 8, 9, 10, 9, 12, 9, 500, 9, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 509, 8, 10, 1, 11, 3, 11, 512, 8, 11, 1, 11, 1,
		11, 1, 11, 5, 11, 517, 8, 11, 10, 11, 12, 11, 520, 9, 11, 3, 11, 522, 8,
		11, 1, 11, 3, 11, 525, 8, 11, 1, 11, 5, 11, 528, 8, 11, 10, 11, 12, 11,
		531, 9, 11, 1, 11, 1, 11, 5, 11, 535, 8, 11, 10, 11, 12, 11, 538, 9, 11,
		1, 11, 3, 11, 541, 8, 11, 1, 11, 5, 11, 544, 8, 11, 10, 11, 12, 11, 547,
		9, 11, 1, 11, 3, 11, 550, 8, 11, 1, 11, 5, 11, 553, 8, 11, 10, 11, 12,
		11, 556, 9, 11, 1, 11, 1, 11, 5, 11, 560, 8, 11, 10, 11, 12, 11, 563, 9,
		11, 1, 11, 3, 11, 566, 8, 11, 1, 11, 5, 11, 569, 8, 11, 10, 11, 12, 11,
		572, 9, 11, 1, 11, 3, 11, 575, 8, 11, 1, 11, 5, 11, 578, 8, 11, 10, 11,
		12, 11, 581, 9, 11, 1, 11, 1, 11, 5, 11, 585, 8, 11, 10, 11, 12, 11, 588,
		9, 11, 1, 11, 3, 11, 591, 8, 11, 1, 12, 3, 12, 594, 8, 12, 1, 12, 1, 12,
		5, 12, 598, 8, 12, 10, 12, 12, 12, 601, 9, 12, 3, 12, 603, 8, 12, 1, 12,
		1, 12, 1, 13, 1, 13, 5, 13, 609, 8, 13, 10, 13, 12, 13, 612, 9, 13, 1,
		13, 1, 13, 5, 13, 616, 8, 13, 10, 13, 12, 13, 619, 9, 13, 1, 13, 1, 13,
		1, 14, 1, 14, 5, 14, 625, 8, 14, 10, 14, 12, 14, 628, 9, 14, 1, 14, 1,
		14, 5, 14, 632, 8, 14, 10, 14, 12, 14, 635, 9, 14, 1, 14, 1, 14, 5, 14,
		639, 8, 14, 10, 14, 12, 14, 642, 9, 14, 1, 14, 5, 14, 645, 8, 14, 10, 14,
		12, 14, 648, 9, 14, 1, 14, 5, 14, 651, 8, 14, 10, 14, 12, 14, 654, 9, 14,
		1, 14, 3, 14, 657, 8, 14, 3, 14, 659, 8, 14, 1, 14, 5, 14, 662, 8, 14,
		10, 14, 12, 14, 665, 9, 14, 1, 14, 1, 14, 1, 15, 3, 15, 670, 8, 15, 1,
		15, 3, 15, 673, 8, 15, 1, 15, 5, 15, 676, 8, 15, 10, 15, 12, 15, 679, 9,
		15, 1, 15, 1, 15, 1, 15, 5, 15, 684, 8, 15, 10, 15, 12, 15, 687, 9, 15,
		1, 15, 1, 15, 5, 15, 691, 8, 15, 10, 15, 12, 15, 694, 9, 15, 1, 15, 1,
		15, 5, 15, 698, 8, 15, 10, 15, 12, 15, 701, 9, 15, 1, 15, 3, 15, 704, 8,
		15, 1, 16, 1, 16, 5, 16, 708, 8, 16, 10, 16, 12, 16, 711, 9, 16, 1, 16,
		1, 16, 5, 16, 715, 8, 16, 10, 16, 12, 16, 718, 9, 16, 1, 16, 5, 16, 721,
		8, 16, 10, 16, 12, 16, 724, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 5, 17, 732, 8, 17, 10, 17, 12, 17, 735, 9, 17, 1, 17, 3, 17, 738, 8,
		17, 1, 18, 1, 18, 5, 18, 742, 8, 18, 10, 18, 12, 18, 745, 9, 18, 1, 18,
		1, 18, 1, 19, 5, 19, 750, 8, 19, 10, 19, 12, 19, 753, 9, 19, 1, 19, 5,
		19, 756, 8, 19, 10, 19, 12, 19, 759, 9, 19, 1, 19, 1, 19, 1, 20, 1, 20,
		3, 20, 765, 8, 20, 1, 20, 5, 20, 768, 8, 20, 10, 20, 12, 20, 771, 9, 20,
		1, 20, 1, 20, 5, 20, 775, 8, 20, 10, 20, 12, 20, 778, 9, 20, 1, 20, 1,
		20, 1, 21, 1, 21, 5, 21, 784, 8, 21, 10, 21, 12, 21, 787, 9, 21, 1, 21,
		1, 21, 5, 21, 791, 8, 21, 10, 21, 12, 21, 794, 9, 21, 1, 21, 1, 21, 5,
		21, 798, 8, 21, 10, 21, 12, 21, 801, 9, 21, 1, 21, 5, 21, 804, 8, 21, 10,
		21, 12, 21, 807, 9, 21, 1, 21, 5, 21, 810, 8, 21, 10, 21, 12, 21, 813,
		9, 21, 1, 21, 3, 21, 816, 8, 21, 1, 21, 5, 21, 819, 8, 21, 10, 21, 12,
		21, 822, 9, 21, 1, 21, 1, 21, 1, 22, 3, 22, 827, 8, 22, 1, 22, 5, 22, 830,
		8, 22, 10, 22, 12, 22, 833, 9, 22, 1, 22, 1, 22, 5, 22, 837, 8, 22, 10,
		22, 12, 22, 840, 9, 22, 1, 22, 1, 22, 5, 22, 844, 8, 22, 10, 22, 12, 22,
		847, 9, 22, 1, 22, 3, 22, 850, 8, 22, 1, 23, 1, 23, 5, 23, 854, 8, 23,
		10, 23, 12, 23, 857, 9, 23, 1, 23, 1, 23, 5, 23, 861, 8, 23, 10, 23, 12,
		23, 864, 9, 23, 1, 23, 1, 23, 5, 23, 868, 8, 23, 10, 23, 12, 23, 871, 9,
		23, 1, 23, 5, 23, 874, 8, 23, 10, 23, 12, 23, 877, 9, 23, 1, 24, 5, 24,
		880, 8, 24, 10, 24, 12, 24, 883, 9, 24, 1, 24, 1, 24, 5, 24, 887, 8, 24,
		10, 24, 12, 24, 890, 9, 24, 1, 24, 1, 24, 5, 24, 894, 8, 24, 10, 24, 12,
		24, 897, 9, 24, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 903, 8, 25, 5, 25, 905,
		8, 25, 10, 25, 12, 25, 908, 9, 25, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 914,
		8, 26, 1, 27, 1, 27, 5, 27, 918, 8, 27, 10, 27, 12, 27, 921, 9, 27, 1,
		27, 1, 27, 1, 28, 3, 28, 926, 8, 28, 1, 28, 1, 28, 5, 28, 930, 8, 28, 10,
		28, 12, 28, 933, 9, 28, 1, 28, 1, 28, 5, 28, 937, 8, 28, 10, 28, 12, 28,
		940, 9, 28, 1, 28, 3, 28, 943, 8, 28, 1, 28, 5, 28, 946, 8, 28, 10, 28,
		12, 28, 949, 9, 28, 1, 28, 1, 28, 5, 28, 953, 8, 28, 10, 28, 12, 28, 956,
		9, 28, 1, 28, 3, 28, 959, 8, 28, 1, 28, 5, 28, 962, 8, 28, 10, 28, 12,
		28, 965, 9, 28, 1, 28, 3, 28, 968, 8, 28, 1, 29, 1, 29, 5, 29, 972, 8,
		29, 10, 29, 12, 29, 975, 9, 29, 1, 29, 1, 29, 5, 29, 979, 8, 29, 10, 29,
		12, 29, 982, 9, 29, 1, 29, 1, 29, 5, 29, 986, 8, 29, 10, 29, 12, 29, 989,
		9, 29, 1, 29, 5, 29, 992, 8, 29, 10, 29, 12, 29, 995, 9, 29, 1, 29, 5,
		29, 998, 8, 29, 10, 29, 12, 29, 1001, 9, 29, 1, 29, 3, 29, 1004, 8, 29,
		3, 29, 1006, 8, 29, 1, 29, 5, 29, 1009, 8, 29, 10, 29, 12, 29, 1012, 9,
		29, 1, 29, 1, 29, 1, 30, 3, 30, 1017, 8, 30, 1, 30, 1, 30, 5, 30, 1021,
		8, 30, 10, 30, 12, 30, 1024, 9, 30, 1, 30, 1, 30, 5, 30, 1028, 8, 30, 10,
		30, 12, 30, 1031, 9, 30, 1, 30, 3, 30, 1034, 8, 30, 1, 31, 3, 31, 1037,
		8, 31, 1, 31, 1, 31, 5, 31, 1041, 8, 31, 10, 31, 12, 31, 1044, 9, 31, 1,
		31, 3, 31, 1047, 8, 31, 1, 31, 5, 31, 1050, 8, 31, 10, 31, 12, 31, 1053,
		9, 31, 1, 31, 1, 31, 5, 31, 1057, 8, 31, 10, 31, 12, 31, 1060, 9, 31, 1,
		31, 1, 31, 3, 31, 1064, 8, 31, 1, 31, 5, 31, 1067, 8, 31, 10, 31, 12, 31,
		1070, 9, 31, 1, 31, 1, 31, 5, 31, 1074, 8, 31, 10, 31, 12, 31, 1077, 9,
		31, 1, 31, 1, 31, 5, 31, 1081, 8, 31, 10, 31, 12, 31, 1084, 9, 31, 1, 31,
		1, 31, 5, 31, 1088, 8, 31, 10, 31, 12, 31, 1091, 9, 31, 1, 31, 3, 31, 1094,
		8, 31, 1, 31, 5, 31, 1097, 8, 31, 10, 31, 12, 31, 1100, 9, 31, 1, 31, 3,
		31, 1103, 8, 31, 1, 31, 5, 31, 1106, 8, 31, 10, 31, 12, 31, 1109, 9, 31,
		1, 31, 3, 31, 1112, 8, 31, 1, 32, 1, 32, 1, 32, 5, 32, 1117, 8, 32, 10,
		32, 12, 32, 1120, 9, 32, 1, 32, 3, 32, 1123, 8, 32, 1, 33, 5, 33, 1126,
		8, 33, 10, 33, 12, 33, 1129, 9, 33, 1, 33, 5, 33, 1132, 8, 33, 10, 33,
		12, 33, 1135, 9, 33, 1, 33, 1, 33, 5, 33, 1139, 8, 33, 10, 33, 12, 33,
		1142, 9, 33, 1, 33, 1, 33, 5, 33, 1146, 8, 33, 10, 33, 12, 33, 1149, 9,
		33, 1, 33, 3, 33, 1152, 8, 33, 1, 34, 1, 34, 5, 34, 1156, 8, 34, 10, 34,
		12, 34, 1159, 9, 34, 1, 34, 1, 34, 5, 34, 1163, 8, 34, 10, 34, 12, 34,
		1166, 9, 34, 1, 34, 1, 34, 5, 34, 1170, 8, 34, 10, 34, 12, 34, 1173, 9,
		34, 1, 34, 5, 34, 1176, 8, 34, 10, 34, 12, 34, 1179, 9, 34, 1, 34, 5, 34,
		1182, 8, 34, 10, 34, 12, 34, 1185, 9, 34, 1, 34, 3, 34, 1188, 8, 34, 1,
		34, 5, 34, 1191, 8, 34, 10, 34, 12, 34, 1194, 9, 34, 1, 34, 1, 34, 1, 35,
		3, 35, 1199, 8, 35, 1, 35, 1, 35, 5, 35, 1203, 8, 35, 10, 35, 12, 35, 1206,
		9, 35, 1, 35, 3, 35, 1209, 8, 35, 1, 35, 5, 35, 1212, 8, 35, 10, 35, 12,
		35, 1215, 9, 35, 1, 35, 1, 35, 5, 35, 1219, 8, 35, 10, 35, 12, 35, 1222,
		9, 35, 1, 35, 1, 35, 3, 35, 1226, 8, 35, 1, 35, 5, 35, 1229, 8, 35, 10,
		35, 12, 35, 1232, 9, 35, 1, 35, 1, 35, 3, 35, 1236, 8, 35, 1, 35, 5, 35,
		1239, 8, 35, 10, 35, 12, 35, 1242, 9, 35, 1, 35, 3, 35, 1245, 8, 35, 1,
		35, 5, 35, 1248, 8, 35, 10, 35, 12, 35, 1251, 9, 35, 1, 35, 1, 35, 5, 35,
		1255, 8, 35, 10, 35, 12, 35, 1258, 9, 35, 1, 35, 1, 35, 3, 35, 1262, 8,
		35, 3, 35, 1264, 8, 35, 1, 35, 4, 35, 1267, 8, 35, 11, 35, 12, 35, 1268,
		1, 35, 3, 35, 1272, 8, 35, 1, 35, 5, 35, 1275, 8, 35, 10, 35, 12, 35, 1278,
		9, 35, 1, 35, 3, 35, 1281, 8, 35, 1, 35, 5, 35, 1284, 8, 35, 10, 35, 12,
		35, 1287, 9, 35, 1, 35, 3, 35, 1290, 8, 35, 1, 35, 3, 35, 1293, 8, 35,
		1, 35, 3, 35, 1296, 8, 35, 1, 35, 5, 35, 1299, 8, 35, 10, 35, 12, 35, 1302,
		9, 35, 1, 35, 3, 35, 1305, 8, 35, 1, 35, 3, 35, 1308, 8, 35, 3, 35, 1310,
		8, 35, 1, 36, 1, 36, 5, 36, 1314, 8, 36, 10, 36, 12, 36, 1317, 9, 36, 1,
		36, 1, 36, 1, 37, 3, 37, 1322, 8, 37, 1, 37, 1, 37, 5, 37, 1326, 8, 37,
		10, 37, 12, 37, 1329, 9, 37, 1, 37, 1, 37, 5, 37, 1333, 8, 37, 10, 37,
		12, 37, 1336, 9, 37, 1, 37, 1, 37, 5, 37, 1340, 8, 37, 10, 37, 12, 37,
		1343, 9, 37, 1, 37, 1, 37, 5, 37, 1347, 8, 37, 10, 37, 12, 37, 1350, 9,
		37, 1, 37, 3, 37, 1353, 8, 37, 1, 37, 5, 37, 1356, 8, 37, 10, 37, 12, 37,
		1359, 9, 37, 1, 37, 3, 37, 1362, 8, 37, 1, 38, 3, 38, 1365, 8, 38, 1, 38,
		1, 38, 5, 38, 1369, 8, 38, 10, 38, 12, 38, 1372, 9, 38, 1, 38, 1, 38, 5,
		38, 1376, 8, 38, 10, 38, 12, 38, 1379, 9, 38, 1, 38, 1, 38, 5, 38, 1383,
		8, 38, 10, 38, 12, 38, 1386, 9, 38, 1, 38, 3, 38, 1389, 8, 38, 1, 38, 5,
		38, 1392, 8, 38, 10, 38, 12, 38, 1395, 9, 38, 1, 38, 1, 38, 5, 38, 1399,
		8, 38, 10, 38, 12, 38, 1402, 9, 38, 1, 38, 1, 38, 5, 38, 1406, 8, 38, 10,
		38, 12, 38, 1409, 9, 38, 1, 38, 3, 38, 1412, 8, 38, 1, 38, 5, 38, 1415,
		8, 38, 10, 38, 12, 38, 1418, 9, 38, 1, 38, 1, 38, 3, 38, 1422, 8, 38, 1,
		39, 1, 39, 5, 39, 1426, 8, 39, 10, 39, 12, 39, 1429, 9, 39, 1, 39, 1, 39,
		5, 39, 1433, 8, 39, 10, 39, 12, 39, 1436, 9, 39, 1, 39, 1, 39, 5, 39, 1440,
		8, 39, 10, 39, 12, 39, 1443, 9, 39, 1, 39, 5, 39, 1446, 8, 39, 10, 39,
		12, 39, 1449, 9, 39, 1, 39, 5, 39, 1452, 8, 39, 10, 39, 12, 39, 1455, 9,
		39, 1, 39, 3, 39, 1458, 8, 39, 3, 39, 1460, 8, 39, 1, 39, 5, 39, 1463,
		8, 39, 10, 39, 12, 39, 1466, 9, 39, 1, 39, 1, 39, 1, 40, 3, 40, 1471, 8,
		40, 1, 40, 1, 40, 5, 40, 1475, 8, 40, 10, 40, 12, 40, 1478, 9, 40, 1, 40,
		1, 40, 5, 40, 1482, 8, 40, 10, 40, 12, 40, 1485, 9, 40, 1, 40, 3, 40, 1488,
		8, 40, 1, 41, 1, 41, 5, 41, 1492, 8, 41, 10, 41, 12, 41, 1495, 9, 41, 1,
		41, 1, 41, 5, 41, 1499, 8, 41, 10, 41, 12, 41, 1502, 9, 41, 1, 41, 3, 41,
		1505, 8, 41, 1, 42, 1, 42, 5, 42, 1509, 8, 42, 10, 42, 12, 42, 1512, 9,
		42, 1, 42, 1, 42, 5, 42, 1516, 8, 42, 10, 42, 12, 42, 1519, 9, 42, 1, 42,
		1, 42, 1, 43, 3, 43, 1524, 8, 43, 1, 43, 1, 43, 5, 43, 1528, 8, 43, 10,
		43, 12, 43, 1531, 9, 43, 1, 43, 1, 43, 5, 43, 1535, 8, 43, 10, 43, 12,
		43, 1538, 9, 43, 1, 43, 1, 43, 5, 43, 1542, 8, 43, 10, 43, 12, 43, 1545,
		9, 43, 1, 43, 3, 43, 1548, 8, 43, 1, 43, 5, 43, 1551, 8, 43, 10, 43, 12,
		43, 1554, 9, 43, 1, 43, 3, 43, 1557, 8, 43, 1, 44, 3, 44, 1560, 8, 44,
		1, 44, 1, 44, 5, 44, 1564, 8, 44, 10, 44, 12, 44, 1567, 9, 44, 1, 44, 1,
		44, 5, 44, 1571, 8, 44, 10, 44, 12, 44, 1574, 9, 44, 1, 44, 1, 44, 5, 44,
		1578, 8, 44, 10, 44, 12, 44, 1581, 9, 44, 1, 44, 3, 44, 1584, 8, 44, 1,
		44, 5, 44, 1587, 8, 44, 10, 44, 12, 44, 1590, 9, 44, 1, 44, 3, 44, 1593,
		8, 44, 1, 45, 1, 45, 5, 45, 1597, 8, 45, 10, 45, 12, 45, 1600, 9, 45, 1,
		45, 1, 45, 1, 46, 1, 46, 5, 46, 1606, 8, 46, 10, 46, 12, 46, 1609, 9, 46,
		1, 46, 3, 46, 1612, 8, 46, 1, 46, 5, 46, 1615, 8, 46, 10, 46, 12, 46, 1618,
		9, 46, 1, 46, 1, 46, 5, 46, 1622, 8, 46, 10, 46, 12, 46, 1625, 9, 46, 1,
		46, 3, 46, 1628, 8, 46, 1, 46, 5, 46, 1631, 8, 46, 10, 46, 12, 46, 1634,
		9, 46, 1, 46, 1, 46, 1, 47, 1, 47, 5, 47, 1640, 8, 47, 10, 47, 12, 47,
		1643, 9, 47, 1, 47, 1, 47, 5, 47, 1647, 8, 47, 10, 47, 12, 47, 1650, 9,
		47, 1, 47, 5, 47, 1653, 8, 47, 10, 47, 12, 47, 1656, 9, 47, 1, 47, 5, 47,
		1659, 8, 47, 10, 47, 12, 47, 1662, 9, 47, 1, 47, 3, 47, 1665, 8, 47, 1,
		48, 1, 48, 5, 48, 1669, 8, 48, 10, 48, 12, 48, 1672, 9, 48, 3, 48, 1674,
		8, 48, 1, 48, 1, 48, 5, 48, 1678, 8, 48, 10, 48, 12, 48, 1681, 9, 48, 1,
		48, 3, 48, 1684, 8, 48, 1, 48, 5, 48, 1687, 8, 48, 10, 48, 12, 48, 1690,
		9, 48, 1, 48, 3, 48, 1693, 8, 48, 1, 49, 3, 49, 1696, 8, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 3, 49, 1703, 8, 49, 1, 50, 1, 50, 3, 50, 1707,
		8, 50, 1, 51, 1, 51, 3, 51, 1711, 8, 51, 1, 51, 5, 51, 1714, 8, 51, 10,
		51, 12, 51, 1717, 9, 51, 1, 51, 4, 51, 1720, 8, 51, 11, 51, 12, 51, 1721,
		1, 52, 1, 52, 1, 53, 1, 53, 5, 53, 1728, 8, 53, 10, 53, 12, 53, 1731, 9,
		53, 1, 53, 1, 53, 5, 53, 1735, 8, 53, 10, 53, 12, 53, 1738, 9, 53, 1, 53,
		5, 53, 1741, 8, 53, 10, 53, 12, 53, 1744, 9, 53, 1, 54, 1, 54, 5, 54, 1748,
		8, 54, 10, 54, 12, 54, 1751, 9, 54, 1, 54, 3, 54, 1754, 8, 54, 1, 55, 3,
		55, 1757, 8, 55, 1, 55, 1, 55, 3, 55, 1761, 8, 55, 1, 56, 4, 56, 1764,
		8, 56, 11, 56, 12, 56, 1765, 1, 57, 1, 57, 5, 57, 1770, 8, 57, 10, 57,
		12, 57, 1773, 9, 57, 1, 57, 3, 57, 1776, 8, 57, 1, 58, 1, 58, 5, 58, 1780,
		8, 58, 10, 58, 12, 58, 1783, 9, 58, 1, 58, 1, 58, 5, 58, 1787, 8, 58, 10,
		58, 12, 58, 1790, 9, 58, 3, 58, 1792, 8, 58, 1, 58, 1, 58, 5, 58, 1796,
		8, 58, 10, 58, 12, 58, 1799, 9, 58, 1, 58, 1, 58, 5, 58, 1803, 8, 58, 10,
		58, 12, 58, 1806, 9, 58, 1, 58, 1, 58, 1, 59, 1, 59, 5, 59, 1812, 8, 59,
		10, 59, 12, 59, 1815, 9, 59, 1, 59, 1, 59, 3, 59, 1819, 8, 59, 1, 59, 5,
		59, 1822, 8, 59, 10, 59, 12, 59, 1825, 9, 59, 1, 59, 1, 59, 5, 59, 1829,
		8, 59, 10, 59, 12, 59, 1832, 9, 59, 1, 59, 1, 59, 3, 59, 1836, 8, 59, 5,
		59, 1838, 8, 59, 10, 59, 12, 59, 1841, 9, 59, 1, 59, 5, 59, 1844, 8, 59,
		10, 59, 12, 59, 1847, 9, 59, 1, 59, 3, 59, 1850, 8, 59, 1, 59, 5, 59, 1853,
		8, 59, 10, 59, 12, 59, 1856, 9, 59, 1, 59, 1, 59, 1, 60, 1, 60, 5, 60,
		1862, 8, 60, 10, 60, 12, 60, 1865, 9, 60, 1, 60, 1, 60, 5, 60, 1869, 8,
		60, 10, 60, 12, 60, 1872, 9, 60, 1, 60, 1, 60, 1, 61, 3, 61, 1877, 8, 61,
		1, 61, 1, 61, 1, 61, 3, 61, 1882, 8, 61, 1, 62, 1, 62, 5, 62, 1886, 8,
		62, 10, 62, 12, 62, 1889, 9, 62, 1, 62, 1, 62, 3, 62, 1893, 8, 62, 1, 62,
		5, 62, 1896, 8, 62, 10, 62, 12, 62, 1899, 9, 62, 1, 62, 1, 62, 1, 63, 3,
		63, 1904, 8, 63, 1, 63, 1, 63, 3, 63, 1908, 8, 63, 1, 63, 5, 63, 1911,
		8, 63, 10, 63, 12, 63, 1914, 9, 63, 1, 63, 1, 63, 5, 63, 1918, 8, 63, 10,
		63, 12, 63, 1921, 9, 63, 1, 63, 3, 63, 1924, 8, 63, 1, 63, 1, 63, 3, 63,
		1928, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 1934, 8, 64, 10, 64, 12,
		64, 1937, 9, 64, 3, 64, 1939, 8, 64, 1, 64, 3, 64, 1942, 8, 64, 1, 65,
		1, 65, 5, 65, 1946, 8, 65, 10, 65, 12, 65, 1949, 9, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 3, 65, 1955, 8, 65, 1, 66, 1, 66, 1, 66, 5, 66, 1960, 8, 66,
		10, 66, 12, 66, 1963, 9, 66, 1, 67, 1, 67, 3, 67, 1967, 8, 67, 1, 68, 1,
		68, 5, 68, 1971, 8, 68, 10, 68, 12, 68, 1974, 9, 68, 1, 68, 1, 68, 5, 68,
		1978, 8, 68, 10, 68, 12, 68, 1981, 9, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1,
		69, 3, 69, 1988, 8, 69, 1, 70, 1, 70, 5, 70, 1992, 8, 70, 10, 70, 12, 70,
		1995, 9, 70, 1, 70, 1, 70, 5, 70, 1999, 8, 70, 10, 70, 12, 70, 2002, 9,
		70, 1, 70, 1, 70, 3, 70, 2006, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70,
		2012, 8, 70, 10, 70, 12, 70, 2015, 9, 70, 1, 70, 3, 70, 2018, 8, 70, 1,
		71, 1, 71, 5, 71, 2022, 8, 71, 10, 71, 12, 71, 2025, 9, 71, 1, 71, 1, 71,
		1, 71, 1, 71, 5, 71, 2031, 8, 71, 10, 71, 12, 71, 2034, 9, 71, 1, 71, 1,
		71, 3, 71, 2038, 8, 71, 1, 72, 1, 72, 5, 72, 2042, 8, 72, 10, 72, 12, 72,
		2045, 9, 72, 1, 72, 3, 72, 2048, 8, 72, 1, 72, 5, 72, 2051, 8, 72, 10,
		72, 12, 72, 2054, 9, 72, 1, 72, 1, 72, 5, 72, 2058, 8, 72, 10, 72, 12,
		72, 2061, 9, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 2073, 8, 73, 1, 73, 5, 73, 2076, 8, 73, 10, 73, 12,
		73, 2079, 9, 73, 1, 73, 1, 73, 1, 74, 1, 74, 5, 74, 2085, 8, 74, 10, 74,
		12, 74, 2088, 9, 74, 1, 75, 4, 75, 2091, 8, 75, 11, 75, 12, 75, 2092, 1,
		76, 1, 76, 1, 77, 1, 77, 5, 77, 2099, 8, 77, 10, 77, 12, 77, 2102, 9, 77,
		1, 77, 1, 77, 5, 77, 2106, 8, 77, 10, 77, 12, 77, 2109, 9, 77, 1, 77, 5,
		77, 2112, 8, 77, 10, 77, 12, 77, 2115, 9, 77, 1, 78, 1, 78, 5, 78, 2119,
		8, 78, 10, 78, 12, 78, 2122, 9, 78, 1, 78, 1, 78, 5, 78, 2126, 8, 78, 10,
		78, 12, 78, 2129, 9, 78, 1, 78, 5, 78, 2132, 8, 78, 10, 78, 12, 78, 2135,
		9, 78, 1, 79, 1, 79, 1, 79, 5, 79, 2140, 8, 79, 10, 79, 12, 79, 2143, 9,
		79, 1, 79, 1, 79, 5, 79, 2147, 8, 79, 10, 79, 12, 79, 2150, 9, 79, 1, 80,
		1, 80, 1, 80, 5, 80, 2155, 8, 80, 10, 80, 12, 80, 2158, 9, 80, 1, 80, 1,
		80, 5, 80, 2162, 8, 80, 10, 80, 12, 80, 2165, 9, 80, 1, 81, 1, 81, 5, 81,
		2169, 8, 81, 10, 81, 12, 81, 2172, 9, 81, 1, 82, 1, 82, 1, 82, 5, 82, 2177,
		8, 82, 10, 82, 12, 82, 2180, 9, 82, 1, 82, 1, 82, 1, 82, 1, 82, 5, 82,
		2186, 8, 82, 10, 82, 12, 82, 2189, 9, 82, 1, 82, 1, 82, 5, 82, 2193, 8,
		82, 10, 82, 12, 82, 2196, 9, 82, 1, 83, 1, 83, 5, 83, 2200, 8, 83, 10,
		83, 12, 83, 2203, 9, 83, 1, 83, 1, 83, 5, 83, 2207, 8, 83, 10, 83, 12,
		83, 2210, 9, 83, 1, 83, 1, 83, 5, 83, 2214, 8, 83, 10, 83, 12, 83, 2217,
		9, 83, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 5, 85, 2225, 8, 85, 10,
		85, 12, 85, 2228, 9, 85, 1, 85, 1, 85, 5, 85, 2232, 8, 85, 10, 85, 12,
		85, 2235, 9, 85, 1, 86, 1, 86, 1, 86, 5, 86, 2240, 8, 86, 10, 86, 12, 86,
		2243, 9, 86, 1, 86, 5, 86, 2246, 8, 86, 10, 86, 12, 86, 2249, 9, 86, 1,
		87, 1, 87, 1, 87, 5, 87, 2254, 8, 87, 10, 87, 12, 87, 2257, 9, 87, 1, 87,
		1, 87, 5, 87, 2261, 8, 87, 10, 87, 12, 87, 2264, 9, 87, 1, 88, 1, 88, 1,
		88, 5, 88, 2269, 8, 88, 10, 88, 12, 88, 2272, 9, 88, 1, 88, 1, 88, 5, 88,
		2276, 8, 88, 10, 88, 12, 88, 2279, 9, 88, 1, 89, 1, 89, 5, 89, 2283, 8,
		89, 10, 89, 12, 89, 2286, 9, 89, 1, 89, 1, 89, 5, 89, 2290, 8, 89, 10,
		89, 12, 89, 2293, 9, 89, 1, 89, 1, 89, 5, 89, 2297, 8, 89, 10, 89, 12,
		89, 2300, 9, 89, 1, 90, 5, 90, 2303, 8, 90, 10, 90, 12, 90, 2306, 9, 90,
		1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 5, 91, 2314, 8, 91, 10, 91, 12,
		91, 2317, 9, 91, 3, 91, 2319, 8, 91, 1, 92, 1, 92, 5, 92, 2323, 8, 92,
		10, 92, 12, 92, 2326, 9, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93,
		2333, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 2340, 8, 94, 1,
		95, 1, 95, 5, 95, 2344, 8, 95, 10, 95, 12, 95, 2347, 9, 95, 1, 95, 1, 95,
		5, 95, 2351, 8, 95, 10, 95, 12, 95, 2354, 9, 95, 1, 95, 1, 95, 1, 96, 1,
		96, 3, 96, 2360, 8, 96, 1, 97, 1, 97, 5, 97, 2364, 8, 97, 10, 97, 12, 97,
		2367, 9, 97, 1, 97, 1, 97, 5, 97, 2371, 8, 97, 10, 97, 12, 97, 2374, 9,
		97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 3, 98, 2381, 8, 98, 1, 99, 1, 99,
		5, 99, 2385, 8, 99, 10, 99, 12, 99, 2388, 9, 99, 1, 99, 1, 99, 5, 99, 2392,
		8, 99, 10, 99, 12, 99, 2395, 9, 99, 1, 99, 1, 99, 5, 99, 2399, 8, 99, 10,
		99, 12, 99, 2402, 9, 99, 1, 99, 5, 99, 2405, 8, 99, 10, 99, 12, 99, 2408,
		9, 99, 1, 99, 5, 99, 2411, 8, 99, 10, 99, 12, 99, 2414, 9, 99, 1, 99, 3,
		99, 2417, 8, 99, 1, 99, 5, 99, 2420, 8, 99, 10, 99, 12, 99, 2423, 9, 99,
		1, 99, 1, 99, 1, 100, 1, 100, 5, 100, 2429, 8, 100, 10, 100, 12, 100, 2432,
		9, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2437, 8, 100, 1, 101, 3, 101, 2440,
		8, 101, 1, 101, 3, 101, 2443, 8, 101, 1, 101, 1, 101, 3, 101, 2447, 8,
		101, 1, 102, 5, 102, 2450, 8, 102, 10, 102, 12, 102, 2453, 9, 102, 1, 102,
		3, 102, 2456, 8, 102, 1, 102, 5, 102, 2459, 8, 102, 10, 102, 12, 102, 2462,
		9, 102, 1, 102, 1, 102, 1, 103, 1, 103, 5, 103, 2468, 8, 103, 10, 103,
		12, 103, 2471, 9, 103, 1, 103, 1, 103, 5, 103, 2475, 8, 103, 10, 103, 12,
		103, 2478, 9, 103, 1, 103, 1, 103, 5, 103, 2482, 8, 103, 10, 103, 12, 103,
		2485, 9, 103, 1, 103, 5, 103, 2488, 8, 103, 10, 103, 12, 103, 2491, 9,
		103, 1, 103, 5, 103, 2494, 8, 103, 10, 103, 12, 103, 2497, 9, 103, 1, 103,
		3, 103, 2500, 8, 103, 1, 103, 5, 103, 2503, 8, 103, 10, 103, 12, 103, 2506,
		9, 103, 1, 103, 1, 103, 1, 104, 1, 104, 5, 104, 2512, 8, 104, 10, 104,
		12, 104, 2515, 9, 104, 1, 104, 1, 104, 5, 104, 2519, 8, 104, 10, 104, 12,
		104, 2522, 9, 104, 1, 104, 1, 104, 5, 104, 2526, 8, 104, 10, 104, 12, 104,
		2529, 9, 104, 1, 104, 5, 104, 2532, 8, 104, 10, 104, 12, 104, 2535, 9,
		104, 1, 104, 5, 104, 2538, 8, 104, 10, 104, 12, 104, 2541, 9, 104, 1, 104,
		3, 104, 2544, 8, 104, 1, 104, 5, 104, 2547, 8, 104, 10, 104, 12, 104, 2550,
		9, 104, 3, 104, 2552, 8, 104, 1, 104, 1, 104, 1, 105, 3, 105, 2557, 8,
		105, 1, 105, 5, 105, 2560, 8, 105, 10, 105, 12, 105, 2563, 9, 105, 1, 105,
		1, 105, 5, 105, 2567, 8, 105, 10, 105, 12, 105, 2570, 9, 105, 1, 105, 1,
		105, 5, 105, 2574, 8, 105, 10, 105, 12, 105, 2577, 9, 105, 3, 105, 2579,
		8, 105, 1, 105, 3, 105, 2582, 8, 105, 1, 105, 5, 105, 2585, 8, 105, 10,
		105, 12, 105, 2588, 9, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 106, 3, 106, 2606, 8, 106, 1, 107, 1, 107, 5, 107, 2610, 8, 107,
		10, 107, 12, 107, 2613, 9, 107, 1, 107, 1, 107, 5, 107, 2617, 8, 107, 10,
		107, 12, 107, 2620, 9, 107, 1, 107, 1, 107, 1, 108, 1, 108, 5, 108, 2626,
		8, 108, 10, 108, 12, 108, 2629, 9, 108, 1, 108, 1, 108, 5, 108, 2633, 8,
		108, 10, 108, 12, 108, 2636, 9, 108, 1, 108, 1, 108, 5, 108, 2640, 8, 108,
		10, 108, 12, 108, 2643, 9, 108, 1, 108, 5, 108, 2646, 8, 108, 10, 108,
		12, 108, 2649, 9, 108, 1, 108, 5, 108, 2652, 8, 108, 10, 108, 12, 108,
		2655, 9, 108, 1, 108, 3, 108, 2658, 8, 108, 1, 108, 5, 108, 2661, 8, 108,
		10, 108, 12, 108, 2664, 9, 108, 3, 108, 2666, 8, 108, 1, 108, 1, 108, 1,
		109, 1, 109, 1, 110, 1, 110, 3, 110, 2674, 8, 110, 1, 111, 1, 111, 1, 111,
		5, 111, 2679, 8, 111, 10, 111, 12, 111, 2682, 9, 111, 1, 111, 1, 111, 1,
		112, 1, 112, 1, 112, 1, 112, 5, 112, 2690, 8, 112, 10, 112, 12, 112, 2693,
		9, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 114, 1, 114, 5, 114, 2701, 8,
		114, 10, 114, 12, 114, 2704, 9, 114, 1, 114, 1, 114, 5, 114, 2708, 8, 114,
		10, 114, 12, 114, 2711, 9, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 116,
		1, 116, 5, 116, 2719, 8, 116, 10, 116, 12, 116, 2722, 9, 116, 1, 116, 1,
		116, 5, 116, 2726, 8, 116, 10, 116, 12, 116, 2729, 9, 116, 1, 116, 1, 116,
		1, 117, 1, 117, 5, 117, 2735, 8, 117, 10, 117, 12, 117, 2738, 9, 117, 1,
		117, 3, 117, 2741, 8, 117, 1, 117, 5, 117, 2744, 8, 117, 10, 117, 12, 117,
		2747, 9, 117, 1, 117, 1, 117, 5, 117, 2751, 8, 117, 10, 117, 12, 117, 2754,
		9, 117, 3, 117, 2756, 8, 117, 1, 117, 1, 117, 5, 117, 2760, 8, 117, 10,
		117, 12, 117, 2763, 9, 117, 1, 117, 1, 117, 1, 118, 1, 118, 5, 118, 2769,
		8, 118, 10, 118, 12, 118, 2772, 9, 118, 1, 118, 1, 118, 5, 118, 2776, 8,
		118, 10, 118, 12, 118, 2779, 9, 118, 1, 118, 5, 118, 2782, 8, 118, 10,
		118, 12, 118, 2785, 9, 118, 1, 118, 5, 118, 2788, 8, 118, 10, 118, 12,
		118, 2791, 9, 118, 1, 118, 3, 118, 2794, 8, 118, 1, 119, 1, 119, 1, 119,
		5, 119, 2799, 8, 119, 10, 119, 12, 119, 2802, 9, 119, 1, 119, 1, 119, 5,
		119, 2806, 8, 119, 10, 119, 12, 119, 2809, 9, 119, 1, 119, 3, 119, 2812,
		8, 119, 3, 119, 2814, 8, 119, 1, 120, 1, 120, 5, 120, 2818, 8, 120, 10,
		120, 12, 120, 2821, 9, 120, 1, 120, 1, 120, 5, 120, 2825, 8, 120, 10, 120,
		12, 120, 2828, 9, 120, 1, 120, 1, 120, 3, 120, 2832, 8, 120, 1, 120, 5,
		120, 2835, 8, 120, 10, 120, 12, 120, 2838, 9, 120, 1, 120, 1, 120, 5, 120,
		2842, 8, 120, 10, 120, 12, 120, 2845, 9, 120, 1, 120, 1, 120, 5, 120, 2849,
		8, 120, 10, 120, 12, 120, 2852, 9, 120, 1, 120, 3, 120, 2855, 8, 120, 1,
		120, 5, 120, 2858, 8, 120, 10, 120, 12, 120, 2861, 9, 120, 1, 120, 3, 120,
		2864, 8, 120, 1, 120, 5, 120, 2867, 8, 120, 10, 120, 12, 120, 2870, 9,
		120, 1, 120, 3, 120, 2873, 8, 120, 1, 121, 1, 121, 3, 121, 2877, 8, 121,
		1, 122, 1, 122, 5, 122, 2881, 8, 122, 10, 122, 12, 122, 2884, 9, 122, 1,
		122, 1, 122, 5, 122, 2888, 8, 122, 10, 122, 12, 122, 2891, 9, 122, 1, 122,
		1, 122, 5, 122, 2895, 8, 122, 10, 122, 12, 122, 2898, 9, 122, 3, 122, 2900,
		8, 122, 1, 122, 5, 122, 2903, 8, 122, 10, 122, 12, 122, 2906, 9, 122, 1,
		122, 3, 122, 2909, 8, 122, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 5, 124,
		2916, 8, 124, 10, 124, 12, 124, 2919, 9, 124, 1, 124, 1, 124, 5, 124, 2923,
		8, 124, 10, 124, 12, 124, 2926, 9, 124, 1, 124, 1, 124, 3, 124, 2930, 8,
		124, 1, 124, 1, 124, 3, 124, 2934, 8, 124, 1, 124, 3, 124, 2937, 8, 124,
		1, 125, 1, 125, 5, 125, 2941, 8, 125, 10, 125, 12, 125, 2944, 9, 125, 1,
		125, 1, 125, 5, 125, 2948, 8, 125, 10, 125, 12, 125, 2951, 9, 125, 1, 125,
		1, 125, 5, 125, 2955, 8, 125, 10, 125, 12, 125, 2958, 9, 125, 1, 125, 1,
		125, 5, 125, 2962, 8, 125, 10, 125, 12, 125, 2965, 9, 125, 1, 125, 1, 125,
		3, 125, 2969, 8, 125, 1, 125, 5, 125, 2972, 8, 125, 10, 125, 12, 125, 2975,
		9, 125, 1, 125, 3, 125, 2978, 8, 125, 1, 125, 5, 125, 2981, 8, 125, 10,
		125, 12, 125, 2984, 9, 125, 1, 125, 1, 125, 5, 125, 2988, 8, 125, 10, 125,
		12, 125, 2991, 9, 125, 1, 125, 1, 125, 3, 125, 2995, 8, 125, 1, 125, 3,
		125, 2998, 8, 125, 1, 126, 1, 126, 5, 126, 3002, 8, 126, 10, 126, 12, 126,
		3005, 9, 126, 1, 126, 5, 126, 3008, 8, 126, 10, 126, 12, 126, 3011, 9,
		126, 1, 126, 1, 126, 5, 126, 3015, 8, 126, 10, 126, 12, 126, 3018, 9, 126,
		1, 126, 1, 126, 5, 126, 3022, 8, 126, 10, 126, 12, 126, 3025, 9, 126, 1,
		126, 1, 126, 5, 126, 3029, 8, 126, 10, 126, 12, 126, 3032, 9, 126, 3, 126,
		3034, 8, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 5, 127, 3041, 8,
		127, 10, 127, 12, 127, 3044, 9, 127, 1, 127, 3, 127, 3047, 8, 127, 1, 127,
		5, 127, 3050, 8, 127, 10, 127, 12, 127, 3053, 9, 127, 1, 127, 1, 127, 5,
		127, 3057, 8, 127, 10, 127, 12, 127, 3060, 9, 127, 1, 127, 1, 127, 5, 127,
		3064, 8, 127, 10, 127, 12, 127, 3067, 9, 127, 5, 127, 3069, 8, 127, 10,
		127, 12, 127, 3072, 9, 127, 1, 127, 5, 127, 3075, 8, 127, 10, 127, 12,
		127, 3078, 9, 127, 1, 127, 1, 127, 1, 128, 1, 128, 5, 128, 3084, 8, 128,
		10, 128, 12, 128, 3087, 9, 128, 1, 128, 1, 128, 5, 128, 3091, 8, 128, 10,
		128, 12, 128, 3094, 9, 128, 1, 128, 5, 128, 3097, 8, 128, 10, 128, 12,
		128, 3100, 9, 128, 1, 128, 5, 128, 3103, 8, 128, 10, 128, 12, 128, 3106,
		9, 128, 1, 128, 3, 128, 3109, 8, 128, 1, 128, 5, 128, 3112, 8, 128, 10,
		128, 12, 128, 3115, 9, 128, 1, 128, 1, 128, 5, 128, 3119, 8, 128, 10, 128,
		12, 128, 3122, 9, 128, 1, 128, 1, 128, 3, 128, 3126, 8, 128, 1, 128, 1,
		128, 5, 128, 3130, 8, 128, 10, 128, 12, 128, 3133, 9, 128, 1, 128, 1, 128,
		5, 128, 3137, 8, 128, 10, 128, 12, 128, 3140, 9, 128, 1, 128, 1, 128, 3,
		128, 3144, 8, 128, 3, 128, 3146, 8, 128, 1, 129, 1, 129, 1, 129, 3, 129,
		3151, 8, 129, 1, 130, 1, 130, 5, 130, 3155, 8, 130, 10, 130, 12, 130, 3158,
		9, 130, 1, 130, 1, 130, 1, 131, 1, 131, 5, 131, 3164, 8, 131, 10, 131,
		12, 131, 3167, 9, 131, 1, 131, 1, 131, 1, 132, 1, 132, 5, 132, 3173, 8,
		132, 10, 132, 12, 132, 3176, 9, 132, 1, 132, 1, 132, 5, 132, 3180, 8, 132,
		10, 132, 12, 132, 3183, 9, 132, 1, 132, 4, 132, 3186, 8, 132, 11, 132,
		12, 132, 3187, 1, 132, 5, 132, 3191, 8, 132, 10, 132, 12, 132, 3194, 9,
		132, 1, 132, 3, 132, 3197, 8, 132, 1, 132, 5, 132, 3200, 8, 132, 10, 132,
		12, 132, 3203, 9, 132, 1, 132, 3, 132, 3206, 8, 132, 1, 133, 1, 133, 5,
		133, 3210, 8, 133, 10, 133, 12, 133, 3213, 9, 133, 1, 133, 1, 133, 5, 133,
		3217, 8, 133, 10, 133, 12, 133, 3220, 9, 133, 1, 133, 1, 133, 1, 133, 1,
		133, 5, 133, 3226, 8, 133, 10, 133, 12, 133, 3229, 9, 133, 1, 133, 3, 133,
		3232, 8, 133, 1, 133, 1, 133, 5, 133, 3236, 8, 133, 10, 133, 12, 133, 3239,
		9, 133, 1, 133, 1, 133, 1, 134, 1, 134, 5, 134, 3245, 8, 134, 10, 134,
		12, 134, 3248, 9, 134, 1, 134, 1, 134, 1, 135, 1, 135, 5, 135, 3254, 8,
		135, 10, 135, 12, 135, 3257, 9, 135, 1, 135, 1, 135, 1, 135, 3, 135, 3262,
		8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 3268, 8, 135, 1, 136, 3,
		136, 3271, 8, 136, 1, 136, 1, 136, 5, 136, 3275, 8, 136, 10, 136, 12, 136,
		3278, 9, 136, 1, 136, 1, 136, 3, 136, 3282, 8, 136, 1, 137, 1, 137, 1,
		138, 1, 138, 1, 139, 1, 139, 1, 140, 1, 140, 1, 141, 1, 141, 1, 142, 1,
		142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1,
		145, 3, 145, 3305, 8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 3311,
		8, 146, 1, 147, 1, 147, 1, 148, 5, 148, 3316, 8, 148, 10, 148, 12, 148,
		3319, 9, 148, 1, 148, 1, 148, 5, 148, 3323, 8, 148, 10, 148, 12, 148, 3326,
		9, 148, 1, 148, 1, 148, 3, 148, 3330, 8, 148, 1, 149, 1, 149, 1, 149, 1,
		150, 1, 150, 4, 150, 3337, 8, 150, 11, 150, 12, 150, 3338, 1, 151, 1, 151,
		4, 151, 3343, 8, 151, 11, 151, 12, 151, 3344, 1, 152, 1, 152, 1, 152, 1,
		152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 3355, 8, 152, 1, 152, 5, 152,
		3358, 8, 152, 10, 152, 12, 152, 3361, 9, 152, 1, 153, 4, 153, 3364, 8,
		153, 11, 153, 12, 153, 3365, 1, 154, 1, 154, 1, 154, 5, 154, 3371, 8, 154,
		10, 154, 12, 154, 3374, 9, 154, 3, 154, 3376, 8, 154, 1, 155, 1, 155, 1,
		156, 1, 156, 1, 157, 1, 157, 1, 158, 1, 158, 1, 159, 4, 159, 3387, 8, 159,
		11, 159, 12, 159, 3388, 1, 160, 1, 160, 5, 160, 3393, 8, 160, 10, 160,
		12, 160, 3396, 9, 160, 1, 160, 1, 160, 5, 160, 3400, 8, 160, 10, 160, 12,
		160, 3403, 9, 160, 1, 160, 3, 160, 3406, 8, 160, 1, 161, 1, 161, 1, 162,
		1, 162, 1, 163, 1, 163, 1, 164, 1, 164, 1, 165, 1, 165, 1, 166, 1, 166,
		1, 167, 1, 167, 3, 167, 3422, 8, 167, 1, 167, 5, 167, 3425, 8, 167, 10,
		167, 12, 167, 3428, 9, 167, 1, 168, 1, 168, 5, 168, 3432, 8, 168, 10, 168,
		12, 168, 3435, 9, 168, 1, 168, 1, 168, 3, 168, 3439, 8, 168, 1, 168, 1,
		168, 1, 169, 1, 169, 5, 169, 3445, 8, 169, 10, 169, 12, 169, 3448, 9, 169,
		1, 169, 1, 169, 3, 169, 3452, 8, 169, 1, 169, 1, 169, 4, 169, 3456, 8,
		169, 11, 169, 12, 169, 3457, 1, 169, 1, 169, 1, 170, 1, 170, 1, 170, 5,
		170, 3465, 8, 170, 10, 170, 12, 170, 3468, 9, 170, 1, 170, 1, 170, 1, 171,
		1, 171, 3, 171, 3474, 8, 171, 1, 172, 1, 172, 1, 173, 1, 173, 5, 173, 3480,
		8, 173, 10, 173, 12, 173, 3483, 9, 173, 1, 173, 1, 173, 5, 173, 3487, 8,
		173, 10, 173, 12, 173, 3490, 9, 173, 1, 173, 0, 0, 174, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
		234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
		264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
		294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
		324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 0, 30, 2, 0,
		40, 40, 42, 42, 1, 0, 77, 78, 1, 0, 84, 85, 1, 0, 44, 45, 1, 0, 40, 41,
		2, 0, 5, 5, 27, 27, 2, 0, 136, 136, 139, 146, 1, 0, 160, 162, 1, 0, 165,
		167, 2, 0, 60, 60, 84, 84, 2, 0, 57, 57, 98, 98, 1, 0, 29, 33, 2, 0, 50,
		51, 53, 54, 1, 0, 46, 49, 2, 0, 103, 103, 105, 105, 2, 0, 102, 102, 104,
		104, 1, 0, 18, 19, 1, 0, 15, 17, 2, 0, 52, 52, 101, 101, 1, 0, 24, 25,
		1, 0, 112, 117, 2, 0, 124, 124, 129, 129, 1, 0, 108, 111, 2, 0, 103, 103,
		106, 106, 1, 0, 118, 123, 1, 0, 125, 127, 1, 0, 130, 132, 1, 0, 134, 135,
		1, 0, 63, 70, 7, 0, 62, 70, 72, 72, 80, 83, 87, 87, 92, 93, 106, 135, 147,
		147, 3911, 0, 349, 1, 0, 0, 0, 2, 374, 1, 0, 0, 0, 4, 400, 1, 0, 0, 0,
		6, 406, 1, 0, 0, 0, 8, 443, 1, 0, 0, 0, 10, 448, 1, 0, 0, 0, 12, 451, 1,
		0, 0, 0, 14, 461, 1, 0, 0, 0, 16, 464, 1, 0, 0, 0, 18, 469, 1, 0, 0, 0,
		20, 508, 1, 0, 0, 0, 22, 511, 1, 0, 0, 0, 24, 602, 1, 0, 0, 0, 26, 606,
		1, 0, 0, 0, 28, 622, 1, 0, 0, 0, 30, 669, 1, 0, 0, 0, 32, 705, 1, 0, 0,
		0, 34, 737, 1, 0, 0, 0, 36, 739, 1, 0, 0, 0, 38, 751, 1, 0, 0, 0, 40, 764,
		1, 0, 0, 0, 42, 781, 1, 0, 0, 0, 44, 826, 1, 0, 0, 0, 46, 851, 1, 0, 0,
		0, 48, 881, 1, 0, 0, 0, 50, 906, 1, 0, 0, 0, 52, 913, 1, 0, 0, 0, 54, 915,
		1, 0, 0, 0, 56, 925, 1, 0, 0, 0, 58, 969, 1, 0, 0, 0, 60, 1016, 1, 0, 0,
		0, 62, 1036, 1, 0, 0, 0, 64, 1122, 1, 0, 0, 0, 66, 1127, 1, 0, 0, 0, 68,
		1153, 1, 0, 0, 0, 70, 1198, 1, 0, 0, 0, 72, 1311, 1, 0, 0, 0, 74, 1321,
		1, 0, 0, 0, 76, 1364, 1, 0, 0, 0, 78, 1423, 1, 0, 0, 0, 80, 1470, 1, 0,
		0, 0, 82, 1489, 1, 0, 0, 0, 84, 1506, 1, 0, 0, 0, 86, 1523, 1, 0, 0, 0,
		88, 1559, 1, 0, 0, 0, 90, 1594, 1, 0, 0, 0, 92, 1603, 1, 0, 0, 0, 94, 1637,
		1, 0, 0, 0, 96, 1673, 1, 0, 0, 0, 98, 1695, 1, 0, 0, 0, 100, 1706, 1, 0,
		0, 0, 102, 1710, 1, 0, 0, 0, 104, 1723, 1, 0, 0, 0, 106, 1725, 1, 0, 0,
		0, 108, 1745, 1, 0, 0, 0, 110, 1760, 1, 0, 0, 0, 112, 1763, 1, 0, 0, 0,
		114, 1775, 1, 0, 0, 0, 116, 1791, 1, 0, 0, 0, 118, 1809, 1, 0, 0, 0, 120,
		1859, 1, 0, 0, 0, 122, 1876, 1, 0, 0, 0, 124, 1883, 1, 0, 0, 0, 126, 1903,
		1, 0, 0, 0, 128, 1938, 1, 0, 0, 0, 130, 1947, 1, 0, 0, 0, 132, 1956, 1,
		0, 0, 0, 134, 1966, 1, 0, 0, 0, 136, 1968, 1, 0, 0, 0, 138, 1987, 1, 0,
		0, 0, 140, 1989, 1, 0, 0, 0, 142, 2019, 1, 0, 0, 0, 144, 2039, 1, 0, 0,
		0, 146, 2072, 1, 0, 0, 0, 148, 2082, 1, 0, 0, 0, 150, 2090, 1, 0, 0, 0,
		152, 2094, 1, 0, 0, 0, 154, 2096, 1, 0, 0, 0, 156, 2116, 1, 0, 0, 0, 158,
		2136, 1, 0, 0, 0, 160, 2151, 1, 0, 0, 0, 162, 2166, 1, 0, 0, 0, 164, 2173,
		1, 0, 0, 0, 166, 2197, 1, 0, 0, 0, 168, 2218, 1, 0, 0, 0, 170, 2221, 1,
		0, 0, 0, 172, 2236, 1, 0, 0, 0, 174, 2250, 1, 0, 0, 0, 176, 2265, 1, 0,
		0, 0, 178, 2280, 1, 0, 0, 0, 180, 2304, 1, 0, 0, 0, 182, 2318, 1, 0, 0,
		0, 184, 2320, 1, 0, 0, 0, 186, 2332, 1, 0, 0, 0, 188, 2339, 1, 0, 0, 0,
		190, 2341, 1, 0, 0, 0, 192, 2359, 1, 0, 0, 0, 194, 2361, 1, 0, 0, 0, 196,
		2380, 1, 0, 0, 0, 198, 2382, 1, 0, 0, 0, 200, 2426, 1, 0, 0, 0, 202, 2439,
		1, 0, 0, 0, 204, 2451, 1, 0, 0, 0, 206, 2465, 1, 0, 0, 0, 208, 2509, 1,
		0, 0, 0, 210, 2556, 1, 0, 0, 0, 212, 2605, 1, 0, 0, 0, 214, 2607, 1, 0,
		0, 0, 216, 2623, 1, 0, 0, 0, 218, 2669, 1, 0, 0, 0, 220, 2673, 1, 0, 0,
		0, 222, 2675, 1, 0, 0, 0, 224, 2685, 1, 0, 0, 0, 226, 2696, 1, 0, 0, 0,
		228, 2698, 1, 0, 0, 0, 230, 2714, 1, 0, 0, 0, 232, 2716, 1, 0, 0, 0, 234,
		2732, 1, 0, 0, 0, 236, 2766, 1, 0, 0, 0, 238, 2813, 1, 0, 0, 0, 240, 2815,
		1, 0, 0, 0, 242, 2876, 1, 0, 0, 0, 244, 2878, 1, 0, 0, 0, 246, 2910, 1,
		0, 0, 0, 248, 2936, 1, 0, 0, 0, 250, 2938, 1, 0, 0, 0, 252, 2999, 1, 0,
		0, 0, 254, 3038, 1, 0, 0, 0, 256, 3145, 1, 0, 0, 0, 258, 3150, 1, 0, 0,
		0, 260, 3152, 1, 0, 0, 0, 262, 3161, 1, 0, 0, 0, 264, 3170, 1, 0, 0, 0,
		266, 3207, 1, 0, 0, 0, 268, 3242, 1, 0, 0, 0, 270, 3267, 1, 0, 0, 0, 272,
		3270, 1, 0, 0, 0, 274, 3283, 1, 0, 0, 0, 276, 3285, 1, 0, 0, 0, 278, 3287,
		1, 0, 0, 0, 280, 3289, 1, 0, 0, 0, 282, 3291, 1, 0, 0, 0, 284, 3293, 1,
		0, 0, 0, 286, 3295, 1, 0, 0, 0, 288, 3297, 1, 0, 0, 0, 290, 3304, 1, 0,
		0, 0, 292, 3310, 1, 0, 0, 0, 294, 3312, 1, 0, 0, 0, 296, 3329, 1, 0, 0,
		0, 298, 3331, 1, 0, 0, 0, 300, 3336, 1, 0, 0, 0, 302, 3342, 1, 0, 0, 0,
		304, 3354, 1, 0, 0, 0, 306, 3363, 1, 0, 0, 0, 308, 3375, 1, 0, 0, 0, 310,
		3377, 1, 0, 0, 0, 312, 3379, 1, 0, 0, 0, 314, 3381, 1, 0, 0, 0, 316, 3383,
		1, 0, 0, 0, 318, 3386, 1, 0, 0, 0, 320, 3405, 1, 0, 0, 0, 322, 3407, 1,
		0, 0, 0, 324, 3409, 1, 0, 0, 0, 326, 3411, 1, 0, 0, 0, 328, 3413, 1, 0,
		0, 0, 330, 3415, 1, 0, 0, 0, 332, 3417, 1, 0, 0, 0, 334, 3421, 1, 0, 0,
		0, 336, 3438, 1, 0, 0, 0, 338, 3451, 1, 0, 0, 0, 340, 3461, 1, 0, 0, 0,
		342, 3473, 1, 0, 0, 0, 344, 3475, 1, 0, 0, 0, 346, 3477, 1, 0, 0, 0, 348,
		350, 3, 4, 2, 0, 349, 348, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 354,
		1, 0, 0, 0, 351, 353, 5, 5, 0, 0, 352, 351, 1, 0, 0, 0, 353, 356, 1, 0,
		0, 0, 354, 352, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355, 360, 1, 0, 0, 0,
		356, 354, 1, 0, 0, 0, 357, 359, 3, 6, 3, 0, 358, 357, 1, 0, 0, 0, 359,
		362, 1, 0, 0, 0, 360, 358, 1, 0, 0, 0, 360, 361, 1, 0, 0, 0, 361, 363,
		1, 0, 0, 0, 362, 360, 1, 0, 0, 0, 363, 364, 3, 8, 4, 0, 364, 368, 3, 10,
		5, 0, 365, 367, 3, 16, 8, 0, 366, 365, 1, 0, 0, 0, 367, 370, 1, 0, 0, 0,
		368, 366, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369, 371, 1, 0, 0, 0, 370,
		368, 1, 0, 0, 0, 371, 372, 5, 0, 0, 1, 372, 1, 1, 0, 0, 0, 373, 375, 3,
		4, 2, 0, 374, 373, 1, 0, 0, 0, 374, 375, 1, 0, 0, 0, 375, 379, 1, 0, 0,
		0, 376, 378, 5, 5, 0, 0, 377, 376, 1, 0, 0, 0, 378, 381, 1, 0, 0, 0, 379,
		377, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380, 385, 1, 0, 0, 0, 381, 379,
		1, 0, 0, 0, 382, 384, 3, 6, 3, 0, 383, 382, 1, 0, 0, 0, 384, 387, 1, 0,
		0, 0, 385, 383, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 388, 1, 0, 0, 0,
		387, 385, 1, 0, 0, 0, 388, 389, 3, 8, 4, 0, 389, 395, 3, 10, 5, 0, 390,
		391, 3, 130, 65, 0, 391, 392, 3, 148, 74, 0, 392, 394, 1, 0, 0, 0, 393,
		390, 1, 0, 0, 0, 394, 397, 1, 0, 0, 0, 395, 393, 1, 0, 0, 0, 395, 396,
		1, 0, 0, 0, 396, 398, 1, 0, 0, 0, 397, 395, 1, 0, 0, 0, 398, 399, 5, 0,
		0, 1, 399, 3, 1, 0, 0, 0, 400, 402, 5, 1, 0, 0, 401, 403, 5, 5, 0, 0, 402,
		401, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 402, 1, 0, 0, 0, 404, 405,
		1, 0, 0, 0, 405, 5, 1, 0, 0, 0, 406, 407, 7, 0, 0, 0, 407, 411, 5, 62,
		0, 0, 408, 410, 5, 5, 0, 0, 409, 408, 1, 0, 0, 0, 410, 413, 1, 0, 0, 0,
		411, 409, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 414, 1, 0, 0, 0, 413,
		411, 1, 0, 0, 0, 414, 418, 5, 26, 0, 0, 415, 417, 5, 5, 0, 0, 416, 415,
		1, 0, 0, 0, 417, 420, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 418, 419, 1, 0,
		0, 0, 419, 430, 1, 0, 0, 0, 420, 418, 1, 0, 0, 0, 421, 423, 5, 11, 0, 0,
		422, 424, 3, 342, 171, 0, 423, 422, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425,
		423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 428,
		5, 12, 0, 0, 428, 431, 1, 0, 0, 0, 429, 431, 3, 342, 171, 0, 430, 421,
		1, 0, 0, 0, 430, 429, 1, 0, 0, 0, 431, 435, 1, 0, 0, 0, 432, 434, 5, 5,
		0, 0, 433, 432, 1, 0, 0, 0, 434, 437, 1, 0, 0, 0, 435, 433, 1, 0, 0, 0,
		435, 436, 1, 0, 0, 0, 436, 7, 1, 0, 0, 0, 437, 435, 1, 0, 0, 0, 438, 439,
		5, 71, 0, 0, 439, 441, 3, 346, 173, 0, 440, 442, 3, 148, 74, 0, 441, 440,
		1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 444, 1, 0, 0, 0, 443, 438, 1, 0,
		0, 0, 443, 444, 1, 0, 0, 0, 444, 9, 1, 0, 0, 0, 445, 447, 3, 12, 6, 0,
		446, 445, 1, 0, 0, 0, 447, 450, 1, 0, 0, 0, 448, 446, 1, 0, 0, 0, 448,
		449, 1, 0, 0, 0, 449, 11, 1, 0, 0, 0, 450, 448, 1, 0, 0, 0, 451, 452, 5,
		72, 0, 0, 452, 456, 3, 346, 173, 0, 453, 454, 5, 7, 0, 0, 454, 457, 5,
		15, 0, 0, 455, 457, 3, 14, 7, 0, 456, 453, 1, 0, 0, 0, 456, 455, 1, 0,
		0, 0, 456, 457, 1, 0, 0, 0, 457, 459, 1, 0, 0, 0, 458, 460, 3, 148, 74,
		0, 459, 458, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 13, 1, 0, 0, 0, 461,
		462, 5, 101, 0, 0, 462, 463, 3, 344, 172, 0, 463, 15, 1, 0, 0, 0, 464,
		466, 3, 20, 10, 0, 465, 467, 3, 150, 75, 0, 466, 465, 1, 0, 0, 0, 466,
		467, 1, 0, 0, 0, 467, 17, 1, 0, 0, 0, 468, 470, 3, 300, 150, 0, 469, 468,
		1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 475, 5, 79,
		0, 0, 472, 474, 5, 5, 0, 0, 473, 472, 1, 0, 0, 0, 474, 477, 1, 0, 0, 0,
		475, 473, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476, 478, 1, 0, 0, 0, 477,
		475, 1, 0, 0, 0, 478, 486, 3, 344, 172, 0, 479, 481, 5, 5, 0, 0, 480, 479,
		1, 0, 0, 0, 481, 484, 1, 0, 0, 0, 482, 480, 1, 0, 0, 0, 482, 483, 1, 0,
		0, 0, 483, 485, 1, 0, 0, 0, 484, 482, 1, 0, 0, 0, 485, 487, 3, 42, 21,
		0, 486, 482, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487, 491, 1, 0, 0, 0, 488,
		490, 5, 5, 0, 0, 489, 488, 1, 0, 0, 0, 490, 493, 1, 0, 0, 0, 491, 489,
		1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 494, 1, 0, 0, 0, 493, 491, 1, 0,
		0, 0, 494, 498, 5, 28, 0, 0, 495, 497, 5, 5, 0, 0, 496, 495, 1, 0, 0, 0,
		497, 500, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499,
		501, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 501, 502, 3, 98, 49, 0, 502, 19,
		1, 0, 0, 0, 503, 509, 3, 22, 11, 0, 504, 509, 3, 86, 43, 0, 505, 509, 3,
		62, 31, 0, 506, 509, 3, 70, 35, 0, 507, 509, 3, 18, 9, 0, 508, 503, 1,
		0, 0, 0, 508, 504, 1, 0, 0, 0, 508, 505, 1, 0, 0, 0, 508, 506, 1, 0, 0,
		0, 508, 507, 1, 0, 0, 0, 509, 21, 1, 0, 0, 0, 510, 512, 3, 300, 150, 0,
		511, 510, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512, 524, 1, 0, 0, 0, 513,
		525, 5, 73, 0, 0, 514, 518, 5, 75, 0, 0, 515, 517, 5, 5, 0, 0, 516, 515,
		1, 0, 0, 0, 517, 520, 1, 0, 0, 0, 518, 516, 1, 0, 0, 0, 518, 519, 1, 0,
		0, 0, 519, 522, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 521, 514, 1, 0, 0, 0,
		521, 522, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 525, 5, 74, 0, 0, 524,
		513, 1, 0, 0, 0, 524, 521, 1, 0, 0, 0, 525, 529, 1, 0, 0, 0, 526, 528,
		5, 5, 0, 0, 527, 526, 1, 0, 0, 0, 528, 531, 1, 0, 0, 0, 529, 527, 1, 0,
		0, 0, 529, 530, 1, 0, 0, 0, 530, 532, 1, 0, 0, 0, 531, 529, 1, 0, 0, 0,
		532, 540, 3, 344, 172, 0, 533, 535, 5, 5, 0, 0, 534, 533, 1, 0, 0, 0, 535,
		538, 1, 0, 0, 0, 536, 534, 1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 539,
		1, 0, 0, 0, 538, 536, 1, 0, 0, 0, 539, 541, 3, 42, 21, 0, 540, 536, 1,
		0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 549, 1, 0, 0, 0, 542, 544, 5, 5, 0,
		0, 543, 542, 1, 0, 0, 0, 544, 547, 1, 0, 0, 0, 545, 543, 1, 0, 0, 0, 545,
		546, 1, 0, 0, 0, 546, 548, 1, 0, 0, 0, 547, 545, 1, 0, 0, 0, 548, 550,
		3, 24, 12, 0, 549, 545, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 565, 1,
		0, 0, 0, 551, 553, 5, 5, 0, 0, 552, 551, 1, 0, 0, 0, 553, 556, 1, 0, 0,
		0, 554, 552, 1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 557, 1, 0, 0, 0, 556,
		554, 1, 0, 0, 0, 557, 561, 5, 26, 0, 0, 558, 560, 5, 5, 0, 0, 559, 558,
		1, 0, 0, 0, 560, 563, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0, 561, 562, 1, 0,
		0, 0, 562, 564, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 564, 566, 3, 32, 16,
		0, 565, 554, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 574, 1, 0, 0, 0, 567,
		569, 5, 5, 0, 0, 568, 567, 1, 0, 0, 0, 569, 572, 1, 0, 0, 0, 570, 568,
		1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 573, 1, 0, 0, 0, 572, 570, 1, 0,
		0, 0, 573, 575, 3, 46, 23, 0, 574, 570, 1, 0, 0, 0, 574, 575, 1, 0, 0,
		0, 575, 590, 1, 0, 0, 0, 576, 578, 5, 5, 0, 0, 577, 576, 1, 0, 0, 0, 578,
		581, 1, 0, 0, 0, 579, 577, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 582,
		1, 0, 0, 0, 581, 579, 1, 0, 0, 0, 582, 591, 3, 26, 13, 0, 583, 585, 5,
		5, 0, 0, 584, 583, 1, 0, 0, 0, 585, 588, 1, 0, 0, 0, 586, 584, 1, 0, 0,
		0, 586, 587, 1, 0, 0, 0, 587, 589, 1, 0, 0, 0, 588, 586, 1, 0, 0, 0, 589,
		591, 3, 92, 46, 0, 590, 579, 1, 0, 0, 0, 590, 586, 1, 0, 0, 0, 590, 591,
		1, 0, 0, 0, 591, 23, 1, 0, 0, 0, 592, 594, 3, 300, 150, 0, 593, 592, 1,
		0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 595, 1, 0, 0, 0, 595, 599, 5, 80, 0,
		0, 596, 598, 5, 5, 0, 0, 597, 596, 1, 0, 0, 0, 598, 601, 1, 0, 0, 0, 599,
		597, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 603, 1, 0, 0, 0, 601, 599,
		1, 0, 0, 0, 602, 593, 1, 0, 0, 0, 602, 603, 1, 0, 0, 0, 603, 604, 1, 0,
		0, 0, 604, 605, 3, 28, 14, 0, 605, 25, 1, 0, 0, 0, 606, 610, 5, 13, 0,
		0, 607, 609, 5, 5, 0, 0, 608, 607, 1, 0, 0, 0, 609, 612, 1, 0, 0, 0, 610,
		608, 1, 0, 0, 0, 610, 611, 1, 0, 0, 0, 611, 613, 1, 0, 0, 0, 612, 610,
		1, 0, 0, 0, 613, 617, 3, 50, 25, 0, 614, 616, 5, 5, 0, 0, 615, 614, 1,
		0, 0, 0, 616, 619, 1, 0, 0, 0, 617, 615, 1, 0, 0, 0, 617, 618, 1, 0, 0,
		0, 618, 620, 1, 0, 0, 0, 619, 617, 1, 0, 0, 0, 620, 621, 5, 14, 0, 0, 621,
		27, 1, 0, 0, 0, 622, 626, 5, 9, 0, 0, 623, 625, 5, 5, 0, 0, 624, 623, 1,
		0, 0, 0, 625, 628, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 626, 627, 1, 0, 0,
		0, 627, 658, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 629, 646, 3, 30, 15, 0,
		630, 632, 5, 5, 0, 0, 631, 630, 1, 0, 0, 0, 632, 635, 1, 0, 0, 0, 633,
		631, 1, 0, 0, 0, 633, 634, 1, 0, 0, 0, 634, 636, 1, 0, 0, 0, 635, 633,
		1, 0, 0, 0, 636, 640, 5, 8, 0, 0, 637, 639, 5, 5, 0, 0, 638, 637, 1, 0,
		0, 0, 639, 642, 1, 0, 0, 0, 640, 638, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0,
		641, 643, 1, 0, 0, 0, 642, 640, 1, 0, 0, 0, 643, 645, 3, 30, 15, 0, 644,
		633, 1, 0, 0, 0, 645, 648, 1, 0, 0, 0, 646, 644, 1, 0, 0, 0, 646, 647,
		1, 0, 0, 0, 647, 656, 1, 0, 0, 0, 648, 646, 1, 0, 0, 0, 649, 651, 5, 5,
		0, 0, 650, 649, 1, 0, 0, 0, 651, 654, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0,
		652, 653, 1, 0, 0, 0, 653, 655, 1, 0, 0, 0, 654, 652, 1, 0, 0, 0, 655,
		657, 5, 8, 0, 0, 656, 652, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657, 659,
		1, 0, 0, 0, 658, 629, 1, 0, 0, 0, 658, 659, 1, 0, 0, 0, 659, 663, 1, 0,
		0, 0, 660, 662, 5, 5, 0, 0, 661, 660, 1, 0, 0, 0, 662, 665, 1, 0, 0, 0,
		663, 661, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 666, 1, 0, 0, 0, 665,
		663, 1, 0, 0, 0, 666, 667, 5, 10, 0, 0, 667, 29, 1, 0, 0, 0, 668, 670,
		3, 300, 150, 0, 669, 668, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 672, 1,
		0, 0, 0, 671, 673, 7, 1, 0, 0, 672, 671, 1, 0, 0, 0, 672, 673, 1, 0, 0,
		0, 673, 677, 1, 0, 0, 0, 674, 676, 5, 5, 0, 0, 675, 674, 1, 0, 0, 0, 676,
		679, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 680,
		1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 680, 681, 3, 344, 172, 0, 681, 685, 5,
		26, 0, 0, 682, 684, 5, 5, 0, 0, 683, 682, 1, 0, 0, 0, 684, 687, 1, 0, 0,
		0, 685, 683, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 688, 1, 0, 0, 0, 687,
		685, 1, 0, 0, 0, 688, 703, 3, 98, 49, 0, 689, 691, 5, 5, 0, 0, 690, 689,
		1, 0, 0, 0, 691, 694, 1, 0, 0, 0, 692, 690, 1, 0, 0, 0, 692, 693, 1, 0,
		0, 0, 693, 695, 1, 0, 0, 0, 694, 692, 1, 0, 0, 0, 695, 699, 5, 28, 0, 0,
		696, 698, 5, 5, 0, 0, 697, 696, 1, 0, 0, 0, 698, 701, 1, 0, 0, 0, 699,
		697, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 702, 1, 0, 0, 0, 701, 699,
		1, 0, 0, 0, 702, 704, 3, 152, 76, 0, 703, 692, 1, 0, 0, 0, 703, 704, 1,
		0, 0, 0, 704, 31, 1, 0, 0, 0, 705, 722, 3, 38, 19, 0, 706, 708, 5, 5, 0,
		0, 707, 706, 1, 0, 0, 0, 708, 711, 1, 0, 0, 0, 709, 707, 1, 0, 0, 0, 709,
		710, 1, 0, 0, 0, 710, 712, 1, 0, 0, 0, 711, 709, 1, 0, 0, 0, 712, 716,
		5, 8, 0, 0, 713, 715, 5, 5, 0, 0, 714, 713, 1, 0, 0, 0, 715, 718, 1, 0,
		0, 0, 716, 714, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 719, 1, 0, 0, 0,
		718, 716, 1, 0, 0, 0, 719, 721, 3, 38, 19, 0, 720, 709, 1, 0, 0, 0, 721,
		724, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 33, 1,
		0, 0, 0, 724, 722, 1, 0, 0, 0, 725, 738, 3, 36, 18, 0, 726, 738, 3, 40,
		20, 0, 727, 738, 3, 106, 53, 0, 728, 738, 3, 116, 58, 0, 729, 733, 5, 123,
		0, 0, 730, 732, 5, 5, 0, 0, 731, 730, 1, 0, 0, 0, 732, 735, 1, 0, 0, 0,
		733, 731, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 736, 1, 0, 0, 0, 735,
		733, 1, 0, 0, 0, 736, 738, 3, 116, 58, 0, 737, 725, 1, 0, 0, 0, 737, 726,
		1, 0, 0, 0, 737, 727, 1, 0, 0, 0, 737, 728, 1, 0, 0, 0, 737, 729, 1, 0,
		0, 0, 738, 35, 1, 0, 0, 0, 739, 743, 3, 106, 53, 0, 740, 742, 5, 5, 0,
		0, 741, 740, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743, 741, 1, 0, 0, 0, 743,
		744, 1, 0, 0, 0, 744, 746, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0, 746, 747,
		3, 208, 104, 0, 747, 37, 1, 0, 0, 0, 748, 750, 3, 334, 167, 0, 749, 748,
		1, 0, 0, 0, 750, 753, 1, 0, 0, 0, 751, 749, 1, 0, 0, 0, 751, 752, 1, 0,
		0, 0, 752, 757, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 754, 756, 5, 5, 0, 0,
		755, 754, 1, 0, 0, 0, 756, 759, 1, 0, 0, 0, 757, 755, 1, 0, 0, 0, 757,
		758, 1, 0, 0, 0, 758, 760, 1, 0, 0, 0, 759, 757, 1, 0, 0, 0, 760, 761,
		3, 34, 17, 0, 761, 39, 1, 0, 0, 0, 762, 765, 3, 106, 53, 0, 763, 765, 3,
		116, 58, 0, 764, 762, 1, 0, 0, 0, 764, 763, 1, 0, 0, 0, 765, 769, 1, 0,
		0, 0, 766, 768, 5, 5, 0, 0, 767, 766, 1, 0, 0, 0, 768, 771, 1, 0, 0, 0,
		769, 767, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 772, 1, 0, 0, 0, 771,
		769, 1, 0, 0, 0, 772, 776, 5, 81, 0, 0, 773, 775, 5, 5, 0, 0, 774, 773,
		1, 0, 0, 0, 775, 778, 1, 0, 0, 0, 776, 774, 1, 0, 0, 0, 776, 777, 1, 0,
		0, 0, 777, 779, 1, 0, 0, 0, 778, 776, 1, 0, 0, 0, 779, 780, 3, 152, 76,
		0, 780, 41, 1, 0, 0, 0, 781, 785, 5, 46, 0, 0, 782, 784, 5, 5, 0, 0, 783,
		782, 1, 0, 0, 0, 784, 787, 1, 0, 0, 0, 785, 783, 1, 0, 0, 0, 785, 786,
		1, 0, 0, 0, 786, 788, 1, 0, 0, 0, 787, 785, 1, 0, 0, 0, 788, 805, 3, 44,
		22, 0, 789, 791, 5, 5, 0, 0, 790, 789, 1, 0, 0, 0, 791, 794, 1, 0, 0, 0,
		792, 790, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 795, 1, 0, 0, 0, 794,
		792, 1, 0, 0, 0, 795, 799, 5, 8, 0, 0, 796, 798, 5, 5, 0, 0, 797, 796,
		1, 0, 0, 0, 798, 801, 1, 0, 0, 0, 799, 797, 1, 0, 0, 0, 799, 800, 1, 0,
		0, 0, 800, 802, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 802, 804, 3, 44, 22,
		0, 803, 792, 1, 0, 0, 0, 804, 807, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805,
		806, 1, 0, 0, 0, 806, 815, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 808, 810,
		5, 5, 0, 0, 809, 808, 1, 0, 0, 0, 810, 813, 1, 0, 0, 0, 811, 809, 1, 0,
		0, 0, 811, 812, 1, 0, 0, 0, 812, 814, 1, 0, 0, 0, 813, 811, 1, 0, 0, 0,
		814, 816, 5, 8, 0, 0, 815, 811, 1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816,
		820, 1, 0, 0, 0, 817, 819, 5, 5, 0, 0, 818, 817, 1, 0, 0, 0, 819, 822,
		1, 0, 0, 0, 820, 818, 1, 0, 0, 0, 820, 821, 1, 0, 0, 0, 821, 823, 1, 0,
		0, 0, 822, 820, 1, 0, 0, 0, 823, 824, 5, 47, 0, 0, 824, 43, 1, 0, 0, 0,
		825, 827, 3, 318, 159, 0, 826, 825, 1, 0, 0, 0, 826, 827, 1, 0, 0, 0, 827,
		831, 1, 0, 0, 0, 828, 830, 5, 5, 0, 0, 829, 828, 1, 0, 0, 0, 830, 833,
		1, 0, 0, 0, 831, 829, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 834, 1, 0,
		0, 0, 833, 831, 1, 0, 0, 0, 834, 849, 3, 344, 172, 0, 835, 837, 5, 5, 0,
		0, 836, 835, 1, 0, 0, 0, 837, 840, 1, 0, 0, 0, 838, 836, 1, 0, 0, 0, 838,
		839, 1, 0, 0, 0, 839, 841, 1, 0, 0, 0, 840, 838, 1, 0, 0, 0, 841, 845,
		5, 26, 0, 0, 842, 844, 5, 5, 0, 0, 843, 842, 1, 0, 0, 0, 844, 847, 1, 0,
		0, 0, 845, 843, 1, 0, 0, 0, 845, 846, 1, 0, 0, 0, 846, 848, 1, 0, 0, 0,
		847, 845, 1, 0, 0, 0, 848, 850, 3, 98, 49, 0, 849, 838, 1, 0, 0, 0, 849,
		850, 1, 0, 0, 0, 850, 45, 1, 0, 0, 0, 851, 855, 5, 87, 0, 0, 852, 854,
		5, 5, 0, 0, 853, 852, 1, 0, 0, 0, 854, 857, 1, 0, 0, 0, 855, 853, 1, 0,
		0, 0, 855, 856, 1, 0, 0, 0, 856, 858, 1, 0, 0, 0, 857, 855, 1, 0, 0, 0,
		858, 875, 3, 48, 24, 0, 859, 861, 5, 5, 0, 0, 860, 859, 1, 0, 0, 0, 861,
		864, 1, 0, 0, 0, 862, 860, 1, 0, 0, 0, 862, 863, 1, 0, 0, 0, 863, 865,
		1, 0, 0, 0, 864, 862, 1, 0, 0, 0, 865, 869, 5, 8, 0, 0, 866, 868, 5, 5,
		0, 0, 867, 866, 1, 0, 0, 0, 868, 871, 1, 0, 0, 0, 869, 867, 1, 0, 0, 0,
		869, 870, 1, 0, 0, 0, 870, 872, 1, 0, 0, 0, 871, 869, 1, 0, 0, 0, 872,
		874, 3, 48, 24, 0, 873, 862, 1, 0, 0, 0, 874, 877, 1, 0, 0, 0, 875, 873,
		1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876, 47, 1, 0, 0, 0, 877, 875, 1, 0,
		0, 0, 878, 880, 3, 334, 167, 0, 879, 878, 1, 0, 0, 0, 880, 883, 1, 0, 0,
		0, 881, 879, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 884, 1, 0, 0, 0, 883,
		881, 1, 0, 0, 0, 884, 888, 3, 344, 172, 0, 885, 887, 5, 5, 0, 0, 886, 885,
		1, 0, 0, 0, 887, 890, 1, 0, 0, 0, 888, 886, 1, 0, 0, 0, 888, 889, 1, 0,
		0, 0, 889, 891, 1, 0, 0, 0, 890, 888, 1, 0, 0, 0, 891, 895, 5, 26, 0, 0,
		892, 894, 5, 5, 0, 0, 893, 892, 1, 0, 0, 0, 894, 897, 1, 0, 0, 0, 895,
		893, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 898, 1, 0, 0, 0, 897, 895,
		1, 0, 0, 0, 898, 899, 3, 98, 49, 0, 899, 49, 1, 0, 0, 0, 900, 902, 3, 52,
		26, 0, 901, 903, 3, 150, 75, 0, 902, 901, 1, 0, 0, 0, 902, 903, 1, 0, 0,
		0, 903, 905, 1, 0, 0, 0, 904, 900, 1, 0, 0, 0, 905, 908, 1, 0, 0, 0, 906,
		904, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 51, 1, 0, 0, 0, 908, 906, 1,
		0, 0, 0, 909, 914, 3, 20, 10, 0, 910, 914, 3, 56, 28, 0, 911, 914, 3, 54,
		27, 0, 912, 914, 3, 88, 44, 0, 913, 909, 1, 0, 0, 0, 913, 910, 1, 0, 0,
		0, 913, 911, 1, 0, 0, 0, 913, 912, 1, 0, 0, 0, 914, 53, 1, 0, 0, 0, 915,
		919, 5, 83, 0, 0, 916, 918, 5, 5, 0, 0, 917, 916, 1, 0, 0, 0, 918, 921,
		1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920, 922, 1, 0,
		0, 0, 921, 919, 1, 0, 0, 0, 922, 923, 3, 136, 68, 0, 923, 55, 1, 0, 0,
		0, 924, 926, 3, 300, 150, 0, 925, 924, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0,
		926, 927, 1, 0, 0, 0, 927, 931, 5, 82, 0, 0, 928, 930, 5, 5, 0, 0, 929,
		928, 1, 0, 0, 0, 930, 933, 1, 0, 0, 0, 931, 929, 1, 0, 0, 0, 931, 932,
		1, 0, 0, 0, 932, 934, 1, 0, 0, 0, 933, 931, 1, 0, 0, 0, 934, 942, 5, 76,
		0, 0, 935, 937, 5, 5, 0, 0, 936, 935, 1, 0, 0, 0, 937, 940, 1, 0, 0, 0,
		938, 936, 1, 0, 0, 0, 938, 939, 1, 0, 0, 0, 939, 941, 1, 0, 0, 0, 940,
		938, 1, 0, 0, 0, 941, 943, 3, 344, 172, 0, 942, 938, 1, 0, 0, 0, 942, 943,
		1, 0, 0, 0, 943, 958, 1, 0, 0, 0, 944, 946, 5, 5, 0, 0, 945, 944, 1, 0,
		0, 0, 946, 949, 1, 0, 0, 0, 947, 945, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0,
		948, 950, 1, 0, 0, 0, 949, 947, 1, 0, 0, 0, 950, 954, 5, 26, 0, 0, 951,
		953, 5, 5, 0, 0, 952, 951, 1, 0, 0, 0, 953, 956, 1, 0, 0, 0, 954, 952,
		1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 957, 1, 0, 0, 0, 956, 954, 1, 0,
		0, 0, 957, 959, 3, 32, 16, 0, 958, 947, 1, 0, 0, 0, 958, 959, 1, 0, 0,
		0, 959, 967, 1, 0, 0, 0, 960, 962, 5, 5, 0, 0, 961, 960, 1, 0, 0, 0, 962,
		965, 1, 0, 0, 0, 963, 961, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964, 966,
		1, 0, 0, 0, 965, 963, 1, 0, 0, 0, 966, 968, 3, 26, 13, 0, 967, 963, 1,
		0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 57, 1, 0, 0, 0, 969, 973, 5, 9, 0,
		0, 970, 972, 5, 5, 0, 0, 971, 970, 1, 0, 0, 0, 972, 975, 1, 0, 0, 0, 973,
		971, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 1005, 1, 0, 0, 0, 975, 973,
		1, 0, 0, 0, 976, 993, 3, 60, 30, 0, 977, 979, 5, 5, 0, 0, 978, 977, 1,
		0, 0, 0, 979, 982, 1, 0, 0, 0, 980, 978, 1, 0, 0, 0, 980, 981, 1, 0, 0,
		0, 981, 983, 1, 0, 0, 0, 982, 980, 1, 0, 0, 0, 983, 987, 5, 8, 0, 0, 984,
		986, 5, 5, 0, 0, 985, 984, 1, 0, 0, 0, 986, 989, 1, 0, 0, 0, 987, 985,
		1, 0, 0, 0, 987, 988, 1, 0, 0, 0, 988, 990, 1, 0, 0, 0, 989, 987, 1, 0,
		0, 0, 990, 992, 3, 60, 30, 0, 991, 980, 1, 0, 0, 0, 992, 995, 1, 0, 0,
		0, 993, 991, 1, 0, 0, 0, 993, 994, 1, 0, 0, 0, 994, 1003, 1, 0, 0, 0, 995,
		993, 1, 0, 0, 0, 996, 998, 5, 5, 0, 0, 997, 996, 1, 0, 0, 0, 998, 1001,
		1, 0, 0, 0, 999, 997, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 1002, 1,
		0, 0, 0, 1001, 999, 1, 0, 0, 0, 1002, 1004, 5, 8, 0, 0, 1003, 999, 1, 0,
		0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1006, 1, 0, 0, 0, 1005, 976, 1, 0,
		0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1010, 1, 0, 0, 0, 1007, 1009, 5, 5,
		0, 0, 1008, 1007, 1, 0, 0, 0, 1009, 1012, 1, 0, 0, 0, 1010, 1008, 1, 0,
		0, 0, 1010, 1011, 1, 0, 0, 0, 1011, 1013, 1, 0, 0, 0, 1012, 1010, 1, 0,
		0, 0, 1013, 1014, 5, 10, 0, 0, 1014, 59, 1, 0, 0, 0, 1015, 1017, 3, 302,
		151, 0, 1016, 1015, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1,
		0, 0, 0, 1018, 1033, 3, 84, 42, 0, 1019, 1021, 5, 5, 0, 0, 1020, 1019,
		1, 0, 0, 0, 1021, 1024, 1, 0, 0, 0, 1022, 1020, 1, 0, 0, 0, 1022, 1023,
		1, 0, 0, 0, 1023, 1025, 1, 0, 0, 0, 1024, 1022, 1, 0, 0, 0, 1025, 1029,
		5, 28, 0, 0, 1026, 1028, 5, 5, 0, 0, 1027, 1026, 1, 0, 0, 0, 1028, 1031,
		1, 0, 0, 0, 1029, 1027, 1, 0, 0, 0, 1029, 1030, 1, 0, 0, 0, 1030, 1032,
		1, 0, 0, 0, 1031, 1029, 1, 0, 0, 0, 1032, 1034, 3, 152, 76, 0, 1033, 1022,
		1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 61, 1, 0, 0, 0, 1035, 1037, 3,
		300, 150, 0, 1036, 1035, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 1038,
		1, 0, 0, 0, 1038, 1046, 5, 75, 0, 0, 1039, 1041, 5, 5, 0, 0, 1040, 1039,
		1, 0, 0, 0, 1041, 1044, 1, 0, 0, 0, 1042, 1040, 1, 0, 0, 0, 1042, 1043,
		1, 0, 0, 0, 1043, 1045, 1, 0, 0, 0, 1044, 1042, 1, 0, 0, 0, 1045, 1047,
		3, 42, 21, 0, 1046, 1042, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1063,
		1, 0, 0, 0, 1048, 1050, 5, 5, 0, 0, 1049, 1048, 1, 0, 0, 0, 1050, 1053,
		1, 0, 0, 0, 1051, 1049, 1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1054,
		1, 0, 0, 0, 1053, 1051, 1, 0, 0, 0, 1054, 1058, 3, 122, 61, 0, 1055, 1057,
		5, 5, 0, 0, 1056, 1055, 1, 0, 0, 0, 1057, 1060, 1, 0, 0, 0, 1058, 1056,
		1, 0, 0, 0, 1058, 1059, 1, 0, 0, 0, 1059, 1061, 1, 0, 0, 0, 1060, 1058,
		1, 0, 0, 0, 1061, 1062, 5, 7, 0, 0, 1062, 1064, 1, 0, 0, 0, 1063, 1051,
		1, 0, 0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 1068, 1, 0, 0, 0, 1065, 1067,
		5, 5, 0, 0, 1066, 1065, 1, 0, 0, 0, 1067, 1070, 1, 0, 0, 0, 1068, 1066,
		1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1071, 1, 0, 0, 0, 1070, 1068,
		1, 0, 0, 0, 1071, 1075, 3, 344, 172, 0, 1072, 1074, 5, 5, 0, 0, 1073, 1072,
		1, 0, 0, 0, 1074, 1077, 1, 0, 0, 0, 1075, 1073, 1, 0, 0, 0, 1075, 1076,
		1, 0, 0, 0, 1076, 1078, 1, 0, 0, 0, 1077, 1075, 1, 0, 0, 0, 1078, 1093,
		3, 58, 29, 0, 1079, 1081, 5, 5, 0, 0, 1080, 1079, 1, 0, 0, 0, 1081, 1084,
		1, 0, 0, 0, 1082, 1080, 1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 1085,
		1, 0, 0, 0, 1084, 1082, 1, 0, 0, 0, 1085, 1089, 5, 26, 0, 0, 1086, 1088,
		5, 5, 0, 0, 1087, 1086, 1, 0, 0, 0, 1088, 1091, 1, 0, 0, 0, 1089, 1087,
		1, 0, 0, 0, 1089, 1090, 1, 0, 0, 0, 1090, 1092, 1, 0, 0, 0, 1091, 1089,
		1, 0, 0, 0, 1092, 1094, 3, 98, 49, 0, 1093, 1082, 1, 0, 0, 0, 1093, 1094,
		1, 0, 0, 0, 1094, 1102, 1, 0, 0, 0, 1095, 1097, 5, 5, 0, 0, 1096, 1095,
		1, 0, 0, 0, 1097, 1100, 1, 0, 0, 0, 1098, 1096, 1, 0, 0, 0, 1098, 1099,
		1, 0, 0, 0, 1099, 1101, 1, 0, 0, 0, 1100, 1098, 1, 0, 0, 0, 1101, 1103,
		3, 46, 23, 0, 1102, 1098, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 1111,
		1, 0, 0, 0, 1104, 1106, 5, 5, 0, 0, 1105, 1104, 1, 0, 0, 0, 1106, 1109,
		1, 0, 0, 0, 1107, 1105, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 1110,
		1, 0, 0, 0, 1109, 1107, 1, 0, 0, 0, 1110, 1112, 3, 64, 32, 0, 1111, 1107,
		1, 0, 0, 0, 1111, 1112, 1, 0, 0, 0, 1112, 63, 1, 0, 0, 0, 1113, 1123, 3,
		136, 68, 0, 1114, 1118, 5, 28, 0, 0, 1115, 1117, 5, 5, 0, 0, 1116, 1115,
		1, 0, 0, 0, 1117, 1120, 1, 0, 0, 0, 1118, 1116, 1, 0, 0, 0, 1118, 1119,
		1, 0, 0, 0, 1119, 1121, 1, 0, 0, 0, 1120, 1118, 1, 0, 0, 0, 1121, 1123,
		3, 152, 76, 0, 1122, 1113, 1, 0, 0, 0, 1122, 1114, 1, 0, 0, 0, 1123, 65,
		1, 0, 0, 0, 1124, 1126, 3, 334, 167, 0, 1125, 1124, 1, 0, 0, 0, 1126, 1129,
		1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128, 1133,
		1, 0, 0, 0, 1129, 1127, 1, 0, 0, 0, 1130, 1132, 5, 5, 0, 0, 1131, 1130,
		1, 0, 0, 0, 1132, 1135, 1, 0, 0, 0, 1133, 1131, 1, 0, 0, 0, 1133, 1134,
		1, 0, 0, 0, 1134, 1136, 1, 0, 0, 0, 1135, 1133, 1, 0, 0, 0, 1136, 1151,
		3, 344, 172, 0, 1137, 1139, 5, 5, 0, 0, 1138, 1137, 1, 0, 0, 0, 1139, 1142,
		1, 0, 0, 0, 1140, 1138, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 1143,
		1, 0, 0, 0, 1142, 1140, 1, 0, 0, 0, 1143, 1147, 5, 26, 0, 0, 1144, 1146,
		5, 5, 0, 0, 1145, 1144, 1, 0, 0, 0, 1146, 1149, 1, 0, 0, 0, 1147, 1145,
		1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148, 1150, 1, 0, 0, 0, 1149, 1147,
		1, 0, 0, 0, 1150, 1152, 3, 98, 49, 0, 1151, 1140, 1, 0, 0, 0, 1151, 1152,
		1, 0, 0, 0, 1152, 67, 1, 0, 0, 0, 1153, 1157, 5, 9, 0, 0, 1154, 1156, 5,
		5, 0, 0, 1155, 1154, 1, 0, 0, 0, 1156, 1159, 1, 0, 0, 0, 1157, 1155, 1,
		0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158, 1160, 1, 0, 0, 0, 1159, 1157, 1,
		0, 0, 0, 1160, 1177, 3, 66, 33, 0, 1161, 1163, 5, 5, 0, 0, 1162, 1161,
		1, 0, 0, 0, 1163, 1166, 1, 0, 0, 0, 1164, 1162, 1, 0, 0, 0, 1164, 1165,
		1, 0, 0, 0, 1165, 1167, 1, 0, 0, 0, 1166, 1164, 1, 0, 0, 0, 1167, 1171,
		5, 8, 0, 0, 1168, 1170, 5, 5, 0, 0, 1169, 1168, 1, 0, 0, 0, 1170, 1173,
		1, 0, 0, 0, 1171, 1169, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1174,
		1, 0, 0, 0, 1173, 1171, 1, 0, 0, 0, 1174, 1176, 3, 66, 33, 0, 1175, 1164,
		1, 0, 0, 0, 1176, 1179, 1, 0, 0, 0, 1177, 1175, 1, 0, 0, 0, 1177, 1178,
		1, 0, 0, 0, 1178, 1187, 1, 0, 0, 0, 1179, 1177, 1, 0, 0, 0, 1180, 1182,
		5, 5, 0, 0, 1181, 1180, 1, 0, 0, 0, 1182, 1185, 1, 0, 0, 0, 1183, 1181,
		1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1186, 1, 0, 0, 0, 1185, 1183,
		1, 0, 0, 0, 1186, 1188, 5, 8, 0, 0, 1187, 1183, 1, 0, 0, 0, 1187, 1188,
		1, 0, 0, 0, 1188, 1192, 1, 0, 0, 0, 1189, 1191, 5, 5, 0, 0, 1190, 1189,
		1, 0, 0, 0, 1191, 1194, 1, 0, 0, 0, 1192, 1190, 1, 0, 0, 0, 1192, 1193,
		1, 0, 0, 0, 1193, 1195, 1, 0, 0, 0, 1194, 1192, 1, 0, 0, 0, 1195, 1196,
		5, 10, 0, 0, 1196, 69, 1, 0, 0, 0, 1197, 1199, 3, 300, 150, 0, 1198, 1197,
		1, 0, 0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 1200, 1, 0, 0, 0, 1200, 1208,
		7, 1, 0, 0, 1201, 1203, 5, 5, 0, 0, 1202, 1201, 1, 0, 0, 0, 1203, 1206,
		1, 0, 0, 0, 1204, 1202, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 1207,
		1, 0, 0, 0, 1206, 1204, 1, 0, 0, 0, 1207, 1209, 3, 42, 21, 0, 1208, 1204,
		1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209, 1225, 1, 0, 0, 0, 1210, 1212,
		5, 5, 0, 0, 1211, 1210, 1, 0, 0, 0, 1212, 1215, 1, 0, 0, 0, 1213, 1211,
		1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214, 1216, 1, 0, 0, 0, 1215, 1213,
		1, 0, 0, 0, 1216, 1220, 3, 122, 61, 0, 1217, 1219, 5, 5, 0, 0, 1218, 1217,
		1, 0, 0, 0, 1219, 1222, 1, 0, 0, 0, 1220, 1218, 1, 0, 0, 0, 1220, 1221,
		1, 0, 0, 0, 1221, 1223, 1, 0, 0, 0, 1222, 1220, 1, 0, 0, 0, 1223, 1224,
		5, 7, 0, 0, 1224, 1226, 1, 0, 0, 0, 1225, 1213, 1, 0, 0, 0, 1225, 1226,
		1, 0, 0, 0, 1226, 1230, 1, 0, 0, 0, 1227, 1229, 5, 5, 0, 0, 1228, 1227,
		1, 0, 0, 0, 1229, 1232, 1, 0, 0, 0, 1230, 1228, 1, 0, 0, 0, 1230, 1231,
		1, 0, 0, 0, 1231, 1235, 1, 0, 0, 0, 1232, 1230, 1, 0, 0, 0, 1233, 1236,
		3, 68, 34, 0, 1234, 1236, 3, 66, 33, 0, 1235, 1233, 1, 0, 0, 0, 1235, 1234,
		1, 0, 0, 0, 1236, 1244, 1, 0, 0, 0, 1237, 1239, 5, 5, 0, 0, 1238, 1237,
		1, 0, 0, 0, 1239, 1242, 1, 0, 0, 0, 1240, 1238, 1, 0, 0, 0, 1240, 1241,
		1, 0, 0, 0, 1241, 1243, 1, 0, 0, 0, 1242, 1240, 1, 0, 0, 0, 1243, 1245,
		3, 46, 23, 0, 1244, 1240, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 1263,
		1, 0, 0, 0, 1246, 1248, 5, 5, 0, 0, 1247, 1246, 1, 0, 0, 0, 1248, 1251,
		1, 0, 0, 0, 1249, 1247, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250, 1261,
		1, 0, 0, 0, 1251, 1249, 1, 0, 0, 0, 1252, 1256, 5, 28, 0, 0, 1253, 1255,
		5, 5, 0, 0, 1254, 1253, 1, 0, 0, 0, 1255, 1258, 1, 0, 0, 0, 1256, 1254,
		1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1259, 1, 0, 0, 0, 1258, 1256,
		1, 0, 0, 0, 1259, 1262, 3, 152, 76, 0, 1260, 1262, 3, 72, 36, 0, 1261,
		1252, 1, 0, 0, 0, 1261, 1260, 1, 0, 0, 0, 1262, 1264, 1, 0, 0, 0, 1263,
		1249, 1, 0, 0, 0, 1263, 1264, 1, 0, 0, 0, 1264, 1271, 1, 0, 0, 0, 1265,
		1267, 5, 5, 0, 0, 1266, 1265, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268,
		1266, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 1270, 1, 0, 0, 0, 1270,
		1272, 5, 27, 0, 0, 1271, 1266, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272,
		1276, 1, 0, 0, 0, 1273, 1275, 5, 5, 0, 0, 1274, 1273, 1, 0, 0, 0, 1275,
		1278, 1, 0, 0, 0, 1276, 1274, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277,
		1309, 1, 0, 0, 0, 1278, 1276, 1, 0, 0, 0, 1279, 1281, 3, 74, 37, 0, 1280,
		1279, 1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281, 1292, 1, 0, 0, 0, 1282,
		1284, 5, 5, 0, 0, 1283, 1282, 1, 0, 0, 0, 1284, 1287, 1, 0, 0, 0, 1285,
		1283, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1289, 1, 0, 0, 0, 1287,
		1285, 1, 0, 0, 0, 1288, 1290, 3, 148, 74, 0, 1289, 1288, 1, 0, 0, 0, 1289,
		1290, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 1293, 3, 76, 38, 0, 1292,
		1285, 1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 1310, 1, 0, 0, 0, 1294,
		1296, 3, 76, 38, 0, 1295, 1294, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296,
		1307, 1, 0, 0, 0, 1297, 1299, 5, 5, 0, 0, 1298, 1297, 1, 0, 0, 0, 1299,
		1302, 1, 0, 0, 0, 1300, 1298, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301,
		1304, 1, 0, 0, 0, 1302, 1300, 1, 0, 0, 0, 1303, 1305, 3, 148, 74, 0, 1304,
		1303, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1306, 1, 0, 0, 0, 1306,
		1308, 3, 74, 37, 0, 1307, 1300, 1, 0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308,
		1310, 1, 0, 0, 0, 1309, 1280, 1, 0, 0, 0, 1309, 1295, 1, 0, 0, 0, 1310,
		71, 1, 0, 0, 0, 1311, 1315, 5, 81, 0, 0, 1312, 1314, 5, 5, 0, 0, 1313,
		1312, 1, 0, 0, 0, 1314, 1317, 1, 0, 0, 0, 1315, 1313, 1, 0, 0, 0, 1315,
		1316, 1, 0, 0, 0, 1316, 1318, 1, 0, 0, 0, 1317, 1315, 1, 0, 0, 0, 1318,
		1319, 3, 152, 76, 0, 1319, 73, 1, 0, 0, 0, 1320, 1322, 3, 300, 150, 0,
		1321, 1320, 1, 0, 0, 0, 1321, 1322, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0,
		1323, 1361, 5, 65, 0, 0, 1324, 1326, 5, 5, 0, 0, 1325, 1324, 1, 0, 0, 0,
		1326, 1329, 1, 0, 0, 0, 1327, 1325, 1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0,
		1328, 1330, 1, 0, 0, 0, 1329, 1327, 1, 0, 0, 0, 1330, 1334, 5, 9, 0, 0,
		1331, 1333, 5, 5, 0, 0, 1332, 1331, 1, 0, 0, 0, 1333, 1336, 1, 0, 0, 0,
		1334, 1332, 1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 1337, 1, 0, 0, 0,
		1336, 1334, 1, 0, 0, 0, 1337, 1352, 5, 10, 0, 0, 1338, 1340, 5, 5, 0, 0,
		1339, 1338, 1, 0, 0, 0, 1340, 1343, 1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0,
		1341, 1342, 1, 0, 0, 0, 1342, 1344, 1, 0, 0, 0, 1343, 1341, 1, 0, 0, 0,
		1344, 1348, 5, 26, 0, 0, 1345, 1347, 5, 5, 0, 0, 1346, 1345, 1, 0, 0, 0,
		1347, 1350, 1, 0, 0, 0, 1348, 1346, 1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0,
		1349, 1351, 1, 0, 0, 0, 1350, 1348, 1, 0, 0, 0, 1351, 1353, 3, 98, 49,
		0, 1352, 1341, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353, 1357, 1, 0, 0,
		0, 1354, 1356, 5, 5, 0, 0, 1355, 1354, 1, 0, 0, 0, 1356, 1359, 1, 0, 0,
		0, 1357, 1355, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0, 1358, 1360, 1, 0, 0,
		0, 1359, 1357, 1, 0, 0, 0, 1360, 1362, 3, 64, 32, 0, 1361, 1327, 1, 0,
		0, 0, 1361, 1362, 1, 0, 0, 0, 1362, 75, 1, 0, 0, 0, 1363, 1365, 3, 300,
		150, 0, 1364, 1363, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365, 1366, 1,
		0, 0, 0, 1366, 1421, 5, 66, 0, 0, 1367, 1369, 5, 5, 0, 0, 1368, 1367, 1,
		0, 0, 0, 1369, 1372, 1, 0, 0, 0, 1370, 1368, 1, 0, 0, 0, 1370, 1371, 1,
		0, 0, 0, 1371, 1373, 1, 0, 0, 0, 1372, 1370, 1, 0, 0, 0, 1373, 1377, 5,
		9, 0, 0, 1374, 1376, 5, 5, 0, 0, 1375, 1374, 1, 0, 0, 0, 1376, 1379, 1,
		0, 0, 0, 1377, 1375, 1, 0, 0, 0, 1377, 1378, 1, 0, 0, 0, 1378, 1380, 1,
		0, 0, 0, 1379, 1377, 1, 0, 0, 0, 1380, 1388, 3, 80, 40, 0, 1381, 1383,
		5, 5, 0, 0, 1382, 1381, 1, 0, 0, 0, 1383, 1386, 1, 0, 0, 0, 1384, 1382,
		1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1387, 1, 0, 0, 0, 1386, 1384,
		1, 0, 0, 0, 1387, 1389, 5, 8, 0, 0, 1388, 1384, 1, 0, 0, 0, 1388, 1389,
		1, 0, 0, 0, 1389, 1393, 1, 0, 0, 0, 1390, 1392, 5, 5, 0, 0, 1391, 1390,
		1, 0, 0, 0, 1392, 1395, 1, 0, 0, 0, 1393, 1391, 1, 0, 0, 0, 1393, 1394,
		1, 0, 0, 0, 1394, 1396, 1, 0, 0, 0, 1395, 1393, 1, 0, 0, 0, 1396, 1411,
		5, 10, 0, 0, 1397, 1399, 5, 5, 0, 0, 1398, 1397, 1, 0, 0, 0, 1399, 1402,
		1, 0, 0, 0, 1400, 1398, 1, 0, 0, 0, 1400, 1401, 1, 0, 0, 0, 1401, 1403,
		1, 0, 0, 0, 1402, 1400, 1, 0, 0, 0, 1403, 1407, 5, 26, 0, 0, 1404, 1406,
		5, 5, 0, 0, 1405, 1404, 1, 0, 0, 0, 1406, 1409, 1, 0, 0, 0, 1407, 1405,
		1, 0, 0, 0, 1407, 1408, 1, 0, 0, 0, 1408, 1410, 1, 0, 0, 0, 1409, 1407,
		1, 0, 0, 0, 1410, 1412, 3, 98, 49, 0, 1411, 1400, 1, 0, 0, 0, 1411, 1412,
		1, 0, 0, 0, 1412, 1416, 1, 0, 0, 0, 1413, 1415, 5, 5, 0, 0, 1414, 1413,
		1, 0, 0, 0, 1415, 1418, 1, 0, 0, 0, 1416, 1414, 1, 0, 0, 0, 1416, 1417,
		1, 0, 0, 0, 1417, 1419, 1, 0, 0, 0, 1418, 1416, 1, 0, 0, 0, 1419, 1420,
		3, 64, 32, 0, 1420, 1422, 1, 0, 0, 0, 1421, 1370, 1, 0, 0, 0, 1421, 1422,
		1, 0, 0, 0, 1422, 77, 1, 0, 0, 0, 1423, 1427, 5, 9, 0, 0, 1424, 1426, 5,
		5, 0, 0, 1425, 1424, 1, 0, 0, 0, 1426, 1429, 1, 0, 0, 0, 1427, 1425, 1,
		0, 0, 0, 1427, 1428, 1, 0, 0, 0, 1428, 1459, 1, 0, 0, 0, 1429, 1427, 1,
		0, 0, 0, 1430, 1447, 3, 80, 40, 0, 1431, 1433, 5, 5, 0, 0, 1432, 1431,
		1, 0, 0, 0, 1433, 1436, 1, 0, 0, 0, 1434, 1432, 1, 0, 0, 0, 1434, 1435,
		1, 0, 0, 0, 1435, 1437, 1, 0, 0, 0, 1436, 1434, 1, 0, 0, 0, 1437, 1441,
		5, 8, 0, 0, 1438, 1440, 5, 5, 0, 0, 1439, 1438, 1, 0, 0, 0, 1440, 1443,
		1, 0, 0, 0, 1441, 1439, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1444,
		1, 0, 0, 0, 1443, 1441, 1, 0, 0, 0, 1444, 1446, 3, 80, 40, 0, 1445, 1434,
		1, 0, 0, 0, 1446, 1449, 1, 0, 0, 0, 1447, 1445, 1, 0, 0, 0, 1447, 1448,
		1, 0, 0, 0, 1448, 1457, 1, 0, 0, 0, 1449, 1447, 1, 0, 0, 0, 1450, 1452,
		5, 5, 0, 0, 1451, 1450, 1, 0, 0, 0, 1452, 1455, 1, 0, 0, 0, 1453, 1451,
		1, 0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 1456, 1, 0, 0, 0, 1455, 1453,
		1, 0, 0, 0, 1456, 1458, 5, 8, 0, 0, 1457, 1453, 1, 0, 0, 0, 1457, 1458,
		1, 0, 0, 0, 1458, 1460, 1, 0, 0, 0, 1459, 1430, 1, 0, 0, 0, 1459, 1460,
		1, 0, 0, 0, 1460, 1464, 1, 0, 0, 0, 1461, 1463, 5, 5, 0, 0, 1462, 1461,
		1, 0, 0, 0, 1463, 1466, 1, 0, 0, 0, 1464, 1462, 1, 0, 0, 0, 1464, 1465,
		1, 0, 0, 0, 1465, 1467, 1, 0, 0, 0, 1466, 1464, 1, 0, 0, 0, 1467, 1468,
		5, 10, 0, 0, 1468, 79, 1, 0, 0, 0, 1469, 1471, 3, 302, 151, 0, 1470, 1469,
		1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471, 1472, 1, 0, 0, 0, 1472, 1487,
		3, 82, 41, 0, 1473, 1475, 5, 5, 0, 0, 1474, 1473, 1, 0, 0, 0, 1475, 1478,
		1, 0, 0, 0, 1476, 1474, 1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1479,
		1, 0, 0, 0, 1478, 1476, 1, 0, 0, 0, 1479, 1483, 5, 28, 0, 0, 1480, 1482,
		5, 5, 0, 0, 1481, 1480, 1, 0, 0, 0, 1482, 1485, 1, 0, 0, 0, 1483, 1481,
		1, 0, 0, 0, 1483, 1484, 1, 0, 0, 0, 1484, 1486, 1, 0, 0, 0, 1485, 1483,
		1, 0, 0, 0, 1486, 1488, 3, 152, 76, 0, 1487, 1476, 1, 0, 0, 0, 1487, 1488,
		1, 0, 0, 0, 1488, 81, 1, 0, 0, 0, 1489, 1493, 3, 344, 172, 0, 1490, 1492,
		5, 5, 0, 0, 1491, 1490, 1, 0, 0, 0, 1492, 1495, 1, 0, 0, 0, 1493, 1491,
		1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 1504, 1, 0, 0, 0, 1495, 1493,
		1, 0, 0, 0, 1496, 1500, 5, 26, 0, 0, 1497, 1499, 5, 5, 0, 0, 1498, 1497,
		1, 0, 0, 0, 1499, 1502, 1, 0, 0, 0, 1500, 1498, 1, 0, 0, 0, 1500, 1501,
		1, 0, 0, 0, 1501, 1503, 1, 0, 0, 0, 1502, 1500, 1, 0, 0, 0, 1503, 1505,
		3, 98, 49, 0, 1504, 1496, 1, 0, 0, 0, 1504, 1505, 1, 0, 0, 0, 1505, 83,
		1, 0, 0, 0, 1506, 1510, 3, 344, 172, 0, 1507, 1509, 5, 5, 0, 0, 1508, 1507,
		1, 0, 0, 0, 1509, 1512, 1, 0, 0, 0, 1510, 1508, 1, 0, 0, 0, 1510, 1511,
		1, 0, 0, 0, 1511, 1513, 1, 0, 0, 0, 1512, 1510, 1, 0, 0, 0, 1513, 1517,
		5, 26, 0, 0, 1514, 1516, 5, 5, 0, 0, 1515, 1514, 1, 0, 0, 0, 1516, 1519,
		1, 0, 0, 0, 1517, 1515, 1, 0, 0, 0, 1517, 1518, 1, 0, 0, 0, 1518, 1520,
		1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0, 1520, 1521, 3, 98, 49, 0, 1521, 85,
		1, 0, 0, 0, 1522, 1524, 3, 300, 150, 0, 1523, 1522, 1, 0, 0, 0, 1523, 1524,
		1, 0, 0, 0, 1524, 1525, 1, 0, 0, 0, 1525, 1529, 5, 76, 0, 0, 1526, 1528,
		5, 5, 0, 0, 1527, 1526, 1, 0, 0, 0, 1528, 1531, 1, 0, 0, 0, 1529, 1527,
		1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1532, 1, 0, 0, 0, 1531, 1529,
		1, 0, 0, 0, 1532, 1547, 3, 344, 172, 0, 1533, 1535, 5, 5, 0, 0, 1534, 1533,
		1, 0, 0, 0, 1535, 1538, 1, 0, 0, 0, 1536, 1534, 1, 0, 0, 0, 1536, 1537,
		1, 0, 0, 0, 1537, 1539, 1, 0, 0, 0, 1538, 1536, 1, 0, 0, 0, 1539, 1543,
		5, 26, 0, 0, 1540, 1542, 5, 5, 0, 0, 1541, 1540, 1, 0, 0, 0, 1542, 1545,
		1, 0, 0, 0, 1543, 1541, 1, 0, 0, 0, 1543, 1544, 1, 0, 0, 0, 1544, 1546,
		1, 0, 0, 0, 1545, 1543, 1, 0, 0, 0, 1546, 1548, 3, 32, 16, 0, 1547, 1536,
		1, 0, 0, 0, 1547, 1548, 1, 0, 0, 0, 1548, 1556, 1, 0, 0, 0, 1549, 1551,
		5, 5, 0, 0, 1550, 1549, 1, 0, 0, 0, 1551, 1554, 1, 0, 0, 0, 1552, 1550,
		1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553, 1555, 1, 0, 0, 0, 1554, 1552,
		1, 0, 0, 0, 1555, 1557, 3, 26, 13, 0, 1556, 1552, 1, 0, 0, 0, 1556, 1557,
		1, 0, 0, 0, 1557, 87, 1, 0, 0, 0, 1558, 1560, 3, 300, 150, 0, 1559, 1558,
		1, 0, 0, 0, 1559, 1560, 1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1565,
		5, 80, 0, 0, 1562, 1564, 5, 5, 0, 0, 1563, 1562, 1, 0, 0, 0, 1564, 1567,
		1, 0, 0, 0, 1565, 1563, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 1568,
		1, 0, 0, 0, 1567, 1565, 1, 0, 0, 0, 1568, 1583, 3, 58, 29, 0, 1569, 1571,
		5, 5, 0, 0, 1570, 1569, 1, 0, 0, 0, 1571, 1574, 1, 0, 0, 0, 1572, 1570,
		1, 0, 0, 0, 1572, 1573, 1, 0, 0, 0, 1573, 1575, 1, 0, 0, 0, 1574, 1572,
		1, 0, 0, 0, 1575, 1579, 5, 26, 0, 0, 1576, 1578, 5, 5, 0, 0, 1577, 1576,
		1, 0, 0, 0, 1578, 1581, 1, 0, 0, 0, 1579, 1577, 1, 0, 0, 0, 1579, 1580,
		1, 0, 0, 0, 1580, 1582, 1, 0, 0, 0, 1581, 1579, 1, 0, 0, 0, 1582, 1584,
		3, 90, 45, 0, 1583, 1572, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1588,
		1, 0, 0, 0, 1585, 1587, 5, 5, 0, 0, 1586, 1585, 1, 0, 0, 0, 1587, 1590,
		1, 0, 0, 0, 1588, 1586, 1, 0, 0, 0, 1588, 1589, 1, 0, 0, 0, 1589, 1592,
		1, 0, 0, 0, 1590, 1588, 1, 0, 0, 0, 1591, 1593, 3, 136, 68, 0, 1592, 1591,
		1, 0, 0, 0, 1592, 1593, 1, 0, 0, 0, 1593, 89, 1, 0, 0, 0, 1594, 1598, 7,
		2, 0, 0, 1595, 1597, 5, 5, 0, 0, 1596, 1595, 1, 0, 0, 0, 1597, 1600, 1,
		0, 0, 0, 1598, 1596, 1, 0, 0, 0, 1598, 1599, 1, 0, 0, 0, 1599, 1601, 1,
		0, 0, 0, 1600, 1598, 1, 0, 0, 0, 1601, 1602, 3, 208, 104, 0, 1602, 91,
		1, 0, 0, 0, 1603, 1607, 5, 13, 0, 0, 1604, 1606, 5, 5, 0, 0, 1605, 1604,
		1, 0, 0, 0, 1606, 1609, 1, 0, 0, 0, 1607, 1605, 1, 0, 0, 0, 1607, 1608,
		1, 0, 0, 0, 1608, 1611, 1, 0, 0, 0, 1609, 1607, 1, 0, 0, 0, 1610, 1612,
		3, 94, 47, 0, 1611, 1610, 1, 0, 0, 0, 1611, 1612, 1, 0, 0, 0, 1612, 1627,
		1, 0, 0, 0, 1613, 1615, 5, 5, 0, 0, 1614, 1613, 1, 0, 0, 0, 1615, 1618,
		1, 0, 0, 0, 1616, 1614, 1, 0, 0, 0, 1616, 1617, 1, 0, 0, 0, 1617, 1619,
		1, 0, 0, 0, 1618, 1616, 1, 0, 0, 0, 1619, 1623, 5, 27, 0, 0, 1620, 1622,
		5, 5, 0, 0, 1621, 1620, 1, 0, 0, 0, 1622, 1625, 1, 0, 0, 0, 1623, 1621,
		1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1626, 1, 0, 0, 0, 1625, 1623,
		1, 0, 0, 0, 1626, 1628, 3, 50, 25, 0, 1627, 1616, 1, 0, 0, 0, 1627, 1628,
		1, 0, 0, 0, 1628, 1632, 1, 0, 0, 0, 1629, 1631, 5, 5, 0, 0, 1630, 1629,
		1, 0, 0, 0, 1631, 1634, 1, 0, 0, 0, 1632, 1630, 1, 0, 0, 0, 1632, 1633,
		1, 0, 0, 0, 1633, 1635, 1, 0, 0, 0, 1634, 1632, 1, 0, 0, 0, 1635, 1636,
		5, 14, 0, 0, 1636, 93, 1, 0, 0, 0, 1637, 1654, 3, 96, 48, 0, 1638, 1640,
		5, 5, 0, 0, 1639, 1638, 1, 0, 0, 0, 1640, 1643, 1, 0, 0, 0, 1641, 1639,
		1, 0, 0, 0, 1641, 1642, 1, 0, 0, 0, 1642, 1644, 1, 0, 0, 0, 1643, 1641,
		1, 0, 0, 0, 1644, 1648, 5, 8, 0, 0, 1645, 1647, 5, 5, 0, 0, 1646, 1645,
		1, 0, 0, 0, 1647, 1650, 1, 0, 0, 0, 1648, 1646, 1, 0, 0, 0, 1648, 1649,
		1, 0, 0, 0, 1649, 1651, 1, 0, 0, 0, 1650, 1648, 1, 0, 0, 0, 1651, 1653,
		3, 96, 48, 0, 1652, 1641, 1, 0, 0, 0, 1653, 1656, 1, 0, 0, 0, 1654, 1652,
		1, 0, 0, 0, 1654, 1655, 1, 0, 0, 0, 1655, 1660, 1, 0, 0, 0, 1656, 1654,
		1, 0, 0, 0, 1657, 1659, 5, 5, 0, 0, 1658, 1657, 1, 0, 0, 0, 1659, 1662,
		1, 0, 0, 0, 1660, 1658, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1664,
		1, 0, 0, 0, 1662, 1660, 1, 0, 0, 0, 1663, 1665, 5, 8, 0, 0, 1664, 1663,
		1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 95, 1, 0, 0, 0, 1666, 1670, 3,
		300, 150, 0, 1667, 1669, 5, 5, 0, 0, 1668, 1667, 1, 0, 0, 0, 1669, 1672,
		1, 0, 0, 0, 1670, 1668, 1, 0, 0, 0, 1670, 1671, 1, 0, 0, 0, 1671, 1674,
		1, 0, 0, 0, 1672, 1670, 1, 0, 0, 0, 1673, 1666, 1, 0, 0, 0, 1673, 1674,
		1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0, 1675, 1683, 3, 344, 172, 0, 1676, 1678,
		5, 5, 0, 0, 1677, 1676, 1, 0, 0, 0, 1678, 1681, 1, 0, 0, 0, 1679, 1677,
		1, 0, 0, 0, 1679, 1680, 1, 0, 0, 0, 1680, 1682, 1, 0, 0, 0, 1681, 1679,
		1, 0, 0, 0, 1682, 1684, 3, 208, 104, 0, 1683, 1679, 1, 0, 0, 0, 1683, 1684,
		1, 0, 0, 0, 1684, 1692, 1, 0, 0, 0, 1685, 1687, 5, 5, 0, 0, 1686, 1685,
		1, 0, 0, 0, 1687, 1690, 1, 0, 0, 0, 1688, 1686, 1, 0, 0, 0, 1688, 1689,
		1, 0, 0, 0, 1689, 1691, 1, 0, 0, 0, 1690, 1688, 1, 0, 0, 0, 1691, 1693,
		3, 26, 13, 0, 1692, 1688, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693, 97,
		1, 0, 0, 0, 1694, 1696, 3, 306, 153, 0, 1695, 1694, 1, 0, 0, 0, 1695, 1696,
		1, 0, 0, 0, 1696, 1702, 1, 0, 0, 0, 1697, 1703, 3, 116, 58, 0, 1698, 1703,
		3, 120, 60, 0, 1699, 1703, 3, 102, 51, 0, 1700, 1703, 3, 100, 50, 0, 1701,
		1703, 3, 126, 63, 0, 1702, 1697, 1, 0, 0, 0, 1702, 1698, 1, 0, 0, 0, 1702,
		1699, 1, 0, 0, 0, 1702, 1700, 1, 0, 0, 0, 1702, 1701, 1, 0, 0, 0, 1703,
		99, 1, 0, 0, 0, 1704, 1707, 3, 106, 53, 0, 1705, 1707, 5, 107, 0, 0, 1706,
		1704, 1, 0, 0, 0, 1706, 1705, 1, 0, 0, 0, 1707, 101, 1, 0, 0, 0, 1708,
		1711, 3, 100, 50, 0, 1709, 1711, 3, 120, 60, 0, 1710, 1708, 1, 0, 0, 0,
		1710, 1709, 1, 0, 0, 0, 1711, 1715, 1, 0, 0, 0, 1712, 1714, 5, 5, 0, 0,
		1713, 1712, 1, 0, 0, 0, 1714, 1717, 1, 0, 0, 0, 1715, 1713, 1, 0, 0, 0,
		1715, 1716, 1, 0, 0, 0, 1716, 1719, 1, 0, 0, 0, 1717, 1715, 1, 0, 0, 0,
		1718, 1720, 3, 104, 52, 0, 1719, 1718, 1, 0, 0, 0, 1720, 1721, 1, 0, 0,
		0, 1721, 1719, 1, 0, 0, 0, 1721, 1722, 1, 0, 0, 0, 1722, 103, 1, 0, 0,
		0, 1723, 1724, 7, 3, 0, 0, 1724, 105, 1, 0, 0, 0, 1725, 1742, 3, 108, 54,
		0, 1726, 1728, 5, 5, 0, 0, 1727, 1726, 1, 0, 0, 0, 1728, 1731, 1, 0, 0,
		0, 1729, 1727, 1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0, 1730, 1732, 1, 0, 0,
		0, 1731, 1729, 1, 0, 0, 0, 1732, 1736, 5, 7, 0, 0, 1733, 1735, 5, 5, 0,
		0, 1734, 1733, 1, 0, 0, 0, 1735, 1738, 1, 0, 0, 0, 1736, 1734, 1, 0, 0,
		0, 1736, 1737, 1, 0, 0, 0, 1737, 1739, 1, 0, 0, 0, 1738, 1736, 1, 0, 0,
		0, 1739, 1741, 3, 108, 54, 0, 1740, 1729, 1, 0, 0, 0, 1741, 1744, 1, 0,
		0, 0, 1742, 1740, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 107, 1, 0,
		0, 0, 1744, 1742, 1, 0, 0, 0, 1745, 1753, 3, 344, 172, 0, 1746, 1748, 5,
		5, 0, 0, 1747, 1746, 1, 0, 0, 0, 1748, 1751, 1, 0, 0, 0, 1749, 1747, 1,
		0, 0, 0, 1749, 1750, 1, 0, 0, 0, 1750, 1752, 1, 0, 0, 0, 1751, 1749, 1,
		0, 0, 0, 1752, 1754, 3, 206, 103, 0, 1753, 1749, 1, 0, 0, 0, 1753, 1754,
		1, 0, 0, 0, 1754, 109, 1, 0, 0, 0, 1755, 1757, 3, 112, 56, 0, 1756, 1755,
		1, 0, 0, 0, 1756, 1757, 1, 0, 0, 0, 1757, 1758, 1, 0, 0, 0, 1758, 1761,
		3, 98, 49, 0, 1759, 1761, 5, 15, 0, 0, 1760, 1756, 1, 0, 0, 0, 1760, 1759,
		1, 0, 0, 0, 1761, 111, 1, 0, 0, 0, 1762, 1764, 3, 114, 57, 0, 1763, 1762,
		1, 0, 0, 0, 1764, 1765, 1, 0, 0, 0, 1765, 1763, 1, 0, 0, 0, 1765, 1766,
		1, 0, 0, 0, 1766, 113, 1, 0, 0, 0, 1767, 1771, 3, 316, 158, 0, 1768, 1770,
		5, 5, 0, 0, 1769, 1768, 1, 0, 0, 0, 1770, 1773, 1, 0, 0, 0, 1771, 1769,
		1, 0, 0, 0, 1771, 1772, 1, 0, 0, 0, 1772, 1776, 1, 0, 0, 0, 1773, 1771,
		1, 0, 0, 0, 1774, 1776, 3, 334, 167, 0, 1775, 1767, 1, 0, 0, 0, 1775, 1774,
		1, 0, 0, 0, 1776, 115, 1, 0, 0, 0, 1777, 1781, 3, 122, 61, 0, 1778, 1780,
		5, 5, 0, 0, 1779, 1778, 1, 0, 0, 0, 1780, 1783, 1, 0, 0, 0, 1781, 1779,
		1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1784, 1, 0, 0, 0, 1783, 1781,
		1, 0, 0, 0, 1784, 1788, 5, 7, 0, 0, 1785, 1787, 5, 5, 0, 0, 1786, 1785,
		1, 0, 0, 0, 1787, 1790, 1, 0, 0, 0, 1788, 1786, 1, 0, 0, 0, 1788, 1789,
		1, 0, 0, 0, 1789, 1792, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1791, 1777,
		1, 0, 0, 0, 1791, 1792, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793, 1797,
		3, 118, 59, 0, 1794, 1796, 5, 5, 0, 0, 1795, 1794, 1, 0, 0, 0, 1796, 1799,
		1, 0, 0, 0, 1797, 1795, 1, 0, 0, 0, 1797, 1798, 1, 0, 0, 0, 1798, 1800,
		1, 0, 0, 0, 1799, 1797, 1, 0, 0, 0, 1800, 1804, 5, 34, 0, 0, 1801, 1803,
		5, 5, 0, 0, 1802, 1801, 1, 0, 0, 0, 1803, 1806, 1, 0, 0, 0, 1804, 1802,
		1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1807, 1, 0, 0, 0, 1806, 1804,
		1, 0, 0, 0, 1807, 1808, 3, 98, 49, 0, 1808, 117, 1, 0, 0, 0, 1809, 1813,
		5, 9, 0, 0, 1810, 1812, 5, 5, 0, 0, 1811, 1810, 1, 0, 0, 0, 1812, 1815,
		1, 0, 0, 0, 1813, 1811, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1818,
		1, 0, 0, 0, 1815, 1813, 1, 0, 0, 0, 1816, 1819, 3, 84, 42, 0, 1817, 1819,
		3, 98, 49, 0, 1818, 1816, 1, 0, 0, 0, 1818, 1817, 1, 0, 0, 0, 1818, 1819,
		1, 0, 0, 0, 1819, 1839, 1, 0, 0, 0, 1820, 1822, 5, 5, 0, 0, 1821, 1820,
		1, 0, 0, 0, 1822, 1825, 1, 0, 0, 0, 1823, 1821, 1, 0, 0, 0, 1823, 1824,
		1, 0, 0, 0, 1824, 1826, 1, 0, 0, 0, 1825, 1823, 1, 0, 0, 0, 1826, 1830,
		5, 8, 0, 0, 1827, 1829, 5, 5, 0, 0, 1828, 1827, 1, 0, 0, 0, 1829, 1832,
		1, 0, 0, 0, 1830, 1828, 1, 0, 0, 0, 1830, 1831, 1, 0, 0, 0, 1831, 1835,
		1, 0, 0, 0, 1832, 1830, 1, 0, 0, 0, 1833, 1836, 3, 84, 42, 0, 1834, 1836,
		3, 98, 49, 0, 1835, 1833, 1, 0, 0, 0, 1835, 1834, 1, 0, 0, 0, 1836, 1838,
		1, 0, 0, 0, 1837, 1823, 1, 0, 0, 0, 1838, 1841, 1, 0, 0, 0, 1839, 1837,
		1, 0, 0, 0, 1839, 1840, 1, 0, 0, 0, 1840, 1849, 1, 0, 0, 0, 1841, 1839,
		1, 0, 0, 0, 1842, 1844, 5, 5, 0, 0, 1843, 1842, 1, 0, 0, 0, 1844, 1847,
		1, 0, 0, 0, 1845, 1843, 1, 0, 0, 0, 1845, 1846, 1, 0, 0, 0, 1846, 1848,
		1, 0, 0, 0, 1847, 1845, 1, 0, 0, 0, 1848, 1850, 5, 8, 0, 0, 1849, 1845,
		1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1854, 1, 0, 0, 0, 1851, 1853,
		5, 5, 0, 0, 1852, 1851, 1, 0, 0, 0, 1853, 1856, 1, 0, 0, 0, 1854, 1852,
		1, 0, 0, 0, 1854, 1855, 1, 0, 0, 0, 1855, 1857, 1, 0, 0, 0, 1856, 1854,
		1, 0, 0, 0, 1857, 1858, 5, 10, 0, 0, 1858, 119, 1, 0, 0, 0, 1859, 1863,
		5, 9, 0, 0, 1860, 1862, 5, 5, 0, 0, 1861, 1860, 1, 0, 0, 0, 1862, 1865,
		1, 0, 0, 0, 1863, 1861, 1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 1866,
		1, 0, 0, 0, 1865, 1863, 1, 0, 0, 0, 1866, 1870, 3, 98, 49, 0, 1867, 1869,
		5, 5, 0, 0, 1868, 1867, 1, 0, 0, 0, 1869, 1872, 1, 0, 0, 0, 1870, 1868,
		1, 0, 0, 0, 1870, 1871, 1, 0, 0, 0, 1871, 1873, 1, 0, 0, 0, 1872, 1870,
		1, 0, 0, 0, 1873, 1874, 5, 10, 0, 0, 1874, 121, 1, 0, 0, 0, 1875, 1877,
		3, 306, 153, 0, 1876, 1875, 1, 0, 0, 0, 1876, 1877, 1, 0, 0, 0, 1877, 1881,
		1, 0, 0, 0, 1878, 1882, 3, 120, 60, 0, 1879, 1882, 3, 102, 51, 0, 1880,
		1882, 3, 100, 50, 0, 1881, 1878, 1, 0, 0, 0, 1881, 1879, 1, 0, 0, 0, 1881,
		1880, 1, 0, 0, 0, 1882, 123, 1, 0, 0, 0, 1883, 1887, 5, 9, 0, 0, 1884,
		1886, 5, 5, 0, 0, 1885, 1884, 1, 0, 0, 0, 1886, 1889, 1, 0, 0, 0, 1887,
		1885, 1, 0, 0, 0, 1887, 1888, 1, 0, 0, 0, 1888, 1892, 1, 0, 0, 0, 1889,
		1887, 1, 0, 0, 0, 1890, 1893, 3, 106, 53, 0, 1891, 1893, 3, 124, 62, 0,
		1892, 1890, 1, 0, 0, 0, 1892, 1891, 1, 0, 0, 0, 1893, 1897, 1, 0, 0, 0,
		1894, 1896, 5, 5, 0, 0, 1895, 1894, 1, 0, 0, 0, 1896, 1899, 1, 0, 0, 0,
		1897, 1895, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 1900, 1, 0, 0, 0,
		1899, 1897, 1, 0, 0, 0, 1900, 1901, 5, 10, 0, 0, 1901, 125, 1, 0, 0, 0,
		1902, 1904, 3, 306, 153, 0, 1903, 1902, 1, 0, 0, 0, 1903, 1904, 1, 0, 0,
		0, 1904, 1907, 1, 0, 0, 0, 1905, 1908, 3, 106, 53, 0, 1906, 1908, 3, 124,
		62, 0, 1907, 1905, 1, 0, 0, 0, 1907, 1906, 1, 0, 0, 0, 1908, 1912, 1, 0,
		0, 0, 1909, 1911, 5, 5, 0, 0, 1910, 1909, 1, 0, 0, 0, 1911, 1914, 1, 0,
		0, 0, 1912, 1910, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1915, 1, 0,
		0, 0, 1914, 1912, 1, 0, 0, 0, 1915, 1919, 5, 56, 0, 0, 1916, 1918, 5, 5,
		0, 0, 1917, 1916, 1, 0, 0, 0, 1918, 1921, 1, 0, 0, 0, 1919, 1917, 1, 0,
		0, 0, 1919, 1920, 1, 0, 0, 0, 1920, 1923, 1, 0, 0, 0, 1921, 1919, 1, 0,
		0, 0, 1922, 1924, 3, 306, 153, 0, 1923, 1922, 1, 0, 0, 0, 1923, 1924, 1,
		0, 0, 0, 1924, 1927, 1, 0, 0, 0, 1925, 1928, 3, 106, 53, 0, 1926, 1928,
		3, 124, 62, 0, 1927, 1925, 1, 0, 0, 0, 1927, 1926, 1, 0, 0, 0, 1928, 127,
		1, 0, 0, 0, 1929, 1935, 3, 130, 65, 0, 1930, 1931, 3, 150, 75, 0, 1931,
		1932, 3, 130, 65, 0, 1932, 1934, 1, 0, 0, 0, 1933, 1930, 1, 0, 0, 0, 1934,
		1937, 1, 0, 0, 0, 1935, 1933, 1, 0, 0, 0, 1935, 1936, 1, 0, 0, 0, 1936,
		1939, 1, 0, 0, 0, 1937, 1935, 1, 0, 0, 0, 1938, 1929, 1, 0, 0, 0, 1938,
		1939, 1, 0, 0, 0, 1939, 1941, 1, 0, 0, 0, 1940, 1942, 3, 150, 75, 0, 1941,
		1940, 1, 0, 0, 0, 1941, 1942, 1, 0, 0, 0, 1942, 129, 1, 0, 0, 0, 1943,
		1946, 3, 132, 66, 0, 1944, 1946, 3, 334, 167, 0, 1945, 1943, 1, 0, 0, 0,
		1945, 1944, 1, 0, 0, 0, 1946, 1949, 1, 0, 0, 0, 1947, 1945, 1, 0, 0, 0,
		1947, 1948, 1, 0, 0, 0, 1948, 1954, 1, 0, 0, 0, 1949, 1947, 1, 0, 0, 0,
		1950, 1955, 3, 20, 10, 0, 1951, 1955, 3, 146, 73, 0, 1952, 1955, 3, 138,
		69, 0, 1953, 1955, 3, 152, 76, 0, 1954, 1950, 1, 0, 0, 0, 1954, 1951, 1,
		0, 0, 0, 1954, 1952, 1, 0, 0, 0, 1954, 1953, 1, 0, 0, 0, 1955, 131, 1,
		0, 0, 0, 1956, 1957, 3, 344, 172, 0, 1957, 1961, 7, 4, 0, 0, 1958, 1960,
		5, 5, 0, 0, 1959, 1958, 1, 0, 0, 0, 1960, 1963, 1, 0, 0, 0, 1961, 1959,
		1, 0, 0, 0, 1961, 1962, 1, 0, 0, 0, 1962, 133, 1, 0, 0, 0, 1963, 1961,
		1, 0, 0, 0, 1964, 1967, 3, 136, 68, 0, 1965, 1967, 3, 130, 65, 0, 1966,
		1964, 1, 0, 0, 0, 1966, 1965, 1, 0, 0, 0, 1967, 135, 1, 0, 0, 0, 1968,
		1972, 5, 13, 0, 0, 1969, 1971, 5, 5, 0, 0, 1970, 1969, 1, 0, 0, 0, 1971,
		1974, 1, 0, 0, 0, 1972, 1970, 1, 0, 0, 0, 1972, 1973, 1, 0, 0, 0, 1973,
		1975, 1, 0, 0, 0, 1974, 1972, 1, 0, 0, 0, 1975, 1979, 3, 128, 64, 0, 1976,
		1978, 5, 5, 0, 0, 1977, 1976, 1, 0, 0, 0, 1978, 1981, 1, 0, 0, 0, 1979,
		1977, 1, 0, 0, 0, 1979, 1980, 1, 0, 0, 0, 1980, 1982, 1, 0, 0, 0, 1981,
		1979, 1, 0, 0, 0, 1982, 1983, 5, 14, 0, 0, 1983, 137, 1, 0, 0, 0, 1984,
		1988, 3, 140, 70, 0, 1985, 1988, 3, 142, 71, 0, 1986, 1988, 3, 144, 72,
		0, 1987, 1984, 1, 0, 0, 0, 1987, 1985, 1, 0, 0, 0, 1987, 1986, 1, 0, 0,
		0, 1988, 139, 1, 0, 0, 0, 1989, 1993, 5, 94, 0, 0, 1990, 1992, 5, 5, 0,
		0, 1991, 1990, 1, 0, 0, 0, 1992, 1995, 1, 0, 0, 0, 1993, 1991, 1, 0, 0,
		0, 1993, 1994, 1, 0, 0, 0, 1994, 1996, 1, 0, 0, 0, 1995, 1993, 1, 0, 0,
		0, 1996, 2000, 5, 9, 0, 0, 1997, 1999, 3, 334, 167, 0, 1998, 1997, 1, 0,
		0, 0, 1999, 2002, 1, 0, 0, 0, 2000, 1998, 1, 0, 0, 0, 2000, 2001, 1, 0,
		0, 0, 2001, 2005, 1, 0, 0, 0, 2002, 2000, 1, 0, 0, 0, 2003, 2006, 3, 66,
		33, 0, 2004, 2006, 3, 68, 34, 0, 2005, 2003, 1, 0, 0, 0, 2005, 2004, 1,
		0, 0, 0, 2006, 2007, 1, 0, 0, 0, 2007, 2008, 5, 103, 0, 0, 2008, 2009,
		3, 152, 76, 0, 2009, 2013, 5, 10, 0, 0, 2010, 2012, 5, 5, 0, 0, 2011, 2010,
		1, 0, 0, 0, 2012, 2015, 1, 0, 0, 0, 2013, 2011, 1, 0, 0, 0, 2013, 2014,
		1, 0, 0, 0, 2014, 2017, 1, 0, 0, 0, 2015, 2013, 1, 0, 0, 0, 2016, 2018,
		3, 134, 67, 0, 2017, 2016, 1, 0, 0, 0, 2017, 2018, 1, 0, 0, 0, 2018, 141,
		1, 0, 0, 0, 2019, 2023, 5, 96, 0, 0, 2020, 2022, 5, 5, 0, 0, 2021, 2020,
		1, 0, 0, 0, 2022, 2025, 1, 0, 0, 0, 2023, 2021, 1, 0, 0, 0, 2023, 2024,
		1, 0, 0, 0, 2024, 2026, 1, 0, 0, 0, 2025, 2023, 1, 0, 0, 0, 2026, 2027,
		5, 9, 0, 0, 2027, 2028, 3, 152, 76, 0, 2028, 2032, 5, 10, 0, 0, 2029, 2031,
		5, 5, 0, 0, 2030, 2029, 1, 0, 0, 0, 2031, 2034, 1, 0, 0, 0, 2032, 2030,
		1, 0, 0, 0, 2032, 2033, 1, 0, 0, 0, 2033, 2037, 1, 0, 0, 0, 2034, 2032,
		1, 0, 0, 0, 2035, 2038, 3, 134, 67, 0, 2036, 2038, 5, 27, 0, 0, 2037, 2035,
		1, 0, 0, 0, 2037, 2036, 1, 0, 0, 0, 2038, 143, 1, 0, 0, 0, 2039, 2043,
		5, 95, 0, 0, 2040, 2042, 5, 5, 0, 0, 2041, 2040, 1, 0, 0, 0, 2042, 2045,
		1, 0, 0, 0, 2043, 2041, 1, 0, 0, 0, 2043, 2044, 1, 0, 0, 0, 2044, 2047,
		1, 0, 0, 0, 2045, 2043, 1, 0, 0, 0, 2046, 2048, 3, 134, 67, 0, 2047, 2046,
		1, 0, 0, 0, 2047, 2048, 1, 0, 0, 0, 2048, 2052, 1, 0, 0, 0, 2049, 2051,
		5, 5, 0, 0, 2050, 2049, 1, 0, 0, 0, 2051, 2054, 1, 0, 0, 0, 2052, 2050,
		1, 0, 0, 0, 2052, 2053, 1, 0, 0, 0, 2053, 2055, 1, 0, 0, 0, 2054, 2052,
		1, 0, 0, 0, 2055, 2059, 5, 96, 0, 0, 2056, 2058, 5, 5, 0, 0, 2057, 2056,
		1, 0, 0, 0, 2058, 2061, 1, 0, 0, 0, 2059, 2057, 1, 0, 0, 0, 2059, 2060,
		1, 0, 0, 0, 2060, 2062, 1, 0, 0, 0, 2061, 2059, 1, 0, 0, 0, 2062, 2063,
		5, 9, 0, 0, 2063, 2064, 3, 152, 76, 0, 2064, 2065, 5, 10, 0, 0, 2065, 145,
		1, 0, 0, 0, 2066, 2067, 3, 188, 94, 0, 2067, 2068, 5, 28, 0, 0, 2068, 2073,
		1, 0, 0, 0, 2069, 2070, 3, 192, 96, 0, 2070, 2071, 3, 274, 137, 0, 2071,
		2073, 1, 0, 0, 0, 2072, 2066, 1, 0, 0, 0, 2072, 2069, 1, 0, 0, 0, 2073,
		2077, 1, 0, 0, 0, 2074, 2076, 5, 5, 0, 0, 2075, 2074, 1, 0, 0, 0, 2076,
		2079, 1, 0, 0, 0, 2077, 2075, 1, 0, 0, 0, 2077, 2078, 1, 0, 0, 0, 2078,
		2080, 1, 0, 0, 0, 2079, 2077, 1, 0, 0, 0, 2080, 2081, 3, 152, 76, 0, 2081,
		147, 1, 0, 0, 0, 2082, 2086, 7, 5, 0, 0, 2083, 2085, 5, 5, 0, 0, 2084,
		2083, 1, 0, 0, 0, 2085, 2088, 1, 0, 0, 0, 2086, 2084, 1, 0, 0, 0, 2086,
		2087, 1, 0, 0, 0, 2087, 149, 1, 0, 0, 0, 2088, 2086, 1, 0, 0, 0, 2089,
		2091, 7, 5, 0, 0, 2090, 2089, 1, 0, 0, 0, 2091, 2092, 1, 0, 0, 0, 2092,
		2090, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 151, 1, 0, 0, 0, 2094,
		2095, 3, 154, 77, 0, 2095, 153, 1, 0, 0, 0, 2096, 2113, 3, 156, 78, 0,
		2097, 2099, 5, 5, 0, 0, 2098, 2097, 1, 0, 0, 0, 2099, 2102, 1, 0, 0, 0,
		2100, 2098, 1, 0, 0, 0, 2100, 2101, 1, 0, 0, 0, 2101, 2103, 1, 0, 0, 0,
		2102, 2100, 1, 0, 0, 0, 2103, 2107, 5, 23, 0, 0, 2104, 2106, 5, 5, 0, 0,
		2105, 2104, 1, 0, 0, 0, 2106, 2109, 1, 0, 0, 0, 2107, 2105, 1, 0, 0, 0,
		2107, 2108, 1, 0, 0, 0, 2108, 2110, 1, 0, 0, 0, 2109, 2107, 1, 0, 0, 0,
		2110, 2112, 3, 156, 78, 0, 2111, 2100, 1, 0, 0, 0, 2112, 2115, 1, 0, 0,
		0, 2113, 2111, 1, 0, 0, 0, 2113, 2114, 1, 0, 0, 0, 2114, 155, 1, 0, 0,
		0, 2115, 2113, 1, 0, 0, 0, 2116, 2133, 3, 158, 79, 0, 2117, 2119, 5, 5,
		0, 0, 2118, 2117, 1, 0, 0, 0, 2119, 2122, 1, 0, 0, 0, 2120, 2118, 1, 0,
		0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2123, 1, 0, 0, 0, 2122, 2120, 1, 0,
		0, 0, 2123, 2127, 5, 22, 0, 0, 2124, 2126, 5, 5, 0, 0, 2125, 2124, 1, 0,
		0, 0, 2126, 2129, 1, 0, 0, 0, 2127, 2125, 1, 0, 0, 0, 2127, 2128, 1, 0,
		0, 0, 2128, 2130, 1, 0, 0, 0, 2129, 2127, 1, 0, 0, 0, 2130, 2132, 3, 158,
		79, 0, 2131, 2120, 1, 0, 0, 0, 2132, 2135, 1, 0, 0, 0, 2133, 2131, 1, 0,
		0, 0, 2133, 2134, 1, 0, 0, 0, 2134, 157, 1, 0, 0, 0, 2135, 2133, 1, 0,
		0, 0, 2136, 2148, 3, 160, 80, 0, 2137, 2141, 3, 276, 138, 0, 2138, 2140,
		5, 5, 0, 0, 2139, 2138, 1, 0, 0, 0, 2140, 2143, 1, 0, 0, 0, 2141, 2139,
		1, 0, 0, 0, 2141, 2142, 1, 0, 0, 0, 2142, 2144, 1, 0, 0, 0, 2143, 2141,
		1, 0, 0, 0, 2144, 2145, 3, 160, 80, 0, 2145, 2147, 1, 0, 0, 0, 2146, 2137,
		1, 0, 0, 0, 2147, 2150, 1, 0, 0, 0, 2148, 2146, 1, 0, 0, 0, 2148, 2149,
		1, 0, 0, 0, 2149, 159, 1, 0, 0, 0, 2150, 2148, 1, 0, 0, 0, 2151, 2163,
		3, 162, 81, 0, 2152, 2156, 3, 278, 139, 0, 2153, 2155, 5, 5, 0, 0, 2154,
		2153, 1, 0, 0, 0, 2155, 2158, 1, 0, 0, 0, 2156, 2154, 1, 0, 0, 0, 2156,
		2157, 1, 0, 0, 0, 2157, 2159, 1, 0, 0, 0, 2158, 2156, 1, 0, 0, 0, 2159,
		2160, 3, 162, 81, 0, 2160, 2162, 1, 0, 0, 0, 2161, 2152, 1, 0, 0, 0, 2162,
		2165, 1, 0, 0, 0, 2163, 2161, 1, 0, 0, 0, 2163, 2164, 1, 0, 0, 0, 2164,
		161, 1, 0, 0, 0, 2165, 2163, 1, 0, 0, 0, 2166, 2170, 3, 164, 82, 0, 2167,
		2169, 3, 202, 101, 0, 2168, 2167, 1, 0, 0, 0, 2169, 2172, 1, 0, 0, 0, 2170,
		2168, 1, 0, 0, 0, 2170, 2171, 1, 0, 0, 0, 2171, 163, 1, 0, 0, 0, 2172,
		2170, 1, 0, 0, 0, 2173, 2194, 3, 166, 83, 0, 2174, 2178, 3, 280, 140, 0,
		2175, 2177, 5, 5, 0, 0, 2176, 2175, 1, 0, 0, 0, 2177, 2180, 1, 0, 0, 0,
		2178, 2176, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0, 2179, 2181, 1, 0, 0, 0,
		2180, 2178, 1, 0, 0, 0, 2181, 2182, 3, 166, 83, 0, 2182, 2193, 1, 0, 0,
		0, 2183, 2187, 3, 282, 141, 0, 2184, 2186, 5, 5, 0, 0, 2185, 2184, 1, 0,
		0, 0, 2186, 2189, 1, 0, 0, 0, 2187, 2185, 1, 0, 0, 0, 2187, 2188, 1, 0,
		0, 0, 2188, 2190, 1, 0, 0, 0, 2189, 2187, 1, 0, 0, 0, 2190, 2191, 3, 98,
		49, 0, 2191, 2193, 1, 0, 0, 0, 2192, 2174, 1, 0, 0, 0, 2192, 2183, 1, 0,
		0, 0, 2193, 2196, 1, 0, 0, 0, 2194, 2192, 1, 0, 0, 0, 2194, 2195, 1, 0,
		0, 0, 2195, 165, 1, 0, 0, 0, 2196, 2194, 1, 0, 0, 0, 2197, 2215, 3, 170,
		85, 0, 2198, 2200, 5, 5, 0, 0, 2199, 2198, 1, 0, 0, 0, 2200, 2203, 1, 0,
		0, 0, 2201, 2199, 1, 0, 0, 0, 2201, 2202, 1, 0, 0, 0, 2202, 2204, 1, 0,
		0, 0, 2203, 2201, 1, 0, 0, 0, 2204, 2208, 3, 168, 84, 0, 2205, 2207, 5,
		5, 0, 0, 2206, 2205, 1, 0, 0, 0, 2207, 2210, 1, 0, 0, 0, 2208, 2206, 1,
		0, 0, 0, 2208, 2209, 1, 0, 0, 0, 2209, 2211, 1, 0, 0, 0, 2210, 2208, 1,
		0, 0, 0, 2211, 2212, 3, 170, 85, 0, 2212, 2214, 1, 0, 0, 0, 2213, 2201,
		1, 0, 0, 0, 2214, 2217, 1, 0, 0, 0, 2215, 2213, 1, 0, 0, 0, 2215, 2216,
		1, 0, 0, 0, 2216, 167, 1, 0, 0, 0, 2217, 2215, 1, 0, 0, 0, 2218, 2219,
		5, 45, 0, 0, 2219, 2220, 5, 26, 0, 0, 2220, 169, 1, 0, 0, 0, 2221, 2233,
		3, 172, 86, 0, 2222, 2226, 3, 344, 172, 0, 2223, 2225, 5, 5, 0, 0, 2224,
		2223, 1, 0, 0, 0, 2225, 2228, 1, 0, 0, 0, 2226, 2224, 1, 0, 0, 0, 2226,
		2227, 1, 0, 0, 0, 2227, 2229, 1, 0, 0, 0, 2228, 2226, 1, 0, 0, 0, 2229,
		2230, 3, 172, 86, 0, 2230, 2232, 1, 0, 0, 0, 2231, 2222, 1, 0, 0, 0, 2232,
		2235, 1, 0, 0, 0, 2233, 2231, 1, 0, 0, 0, 2233, 2234, 1, 0, 0, 0, 2234,
		171, 1, 0, 0, 0, 2235, 2233, 1, 0, 0, 0, 2236, 2247, 3, 174, 87, 0, 2237,
		2241, 5, 36, 0, 0, 2238, 2240, 5, 5, 0, 0, 2239, 2238, 1, 0, 0, 0, 2240,
		2243, 1, 0, 0, 0, 2241, 2239, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242,
		2244, 1, 0, 0, 0, 2243, 2241, 1, 0, 0, 0, 2244, 2246, 3, 174, 87, 0, 2245,
		2237, 1, 0, 0, 0, 2246, 2249, 1, 0, 0, 0, 2247, 2245, 1, 0, 0, 0, 2247,
		2248, 1, 0, 0, 0, 2248, 173, 1, 0, 0, 0, 2249, 2247, 1, 0, 0, 0, 2250,
		2262, 3, 176, 88, 0, 2251, 2255, 3, 284, 142, 0, 2252, 2254, 5, 5, 0, 0,
		2253, 2252, 1, 0, 0, 0, 2254, 2257, 1, 0, 0, 0, 2255, 2253, 1, 0, 0, 0,
		2255, 2256, 1, 0, 0, 0, 2256, 2258, 1, 0, 0, 0, 2257, 2255, 1, 0, 0, 0,
		2258, 2259, 3, 176, 88, 0, 2259, 2261, 1, 0, 0, 0, 2260, 2251, 1, 0, 0,
		0, 2261, 2264, 1, 0, 0, 0, 2262, 2260, 1, 0, 0, 0, 2262, 2263, 1, 0, 0,
		0, 2263, 175, 1, 0, 0, 0, 2264, 2262, 1, 0, 0, 0, 2265, 2277, 3, 178, 89,
		0, 2266, 2270, 3, 286, 143, 0, 2267, 2269, 5, 5, 0, 0, 2268, 2267, 1, 0,
		0, 0, 2269, 2272, 1, 0, 0, 0, 2270, 2268, 1, 0, 0, 0, 2270, 2271, 1, 0,
		0, 0, 2271, 2273, 1, 0, 0, 0, 2272, 2270, 1, 0, 0, 0, 2273, 2274, 3, 178,
		89, 0, 2274, 2276, 1, 0, 0, 0, 2275, 2266, 1, 0, 0, 0, 2276, 2279, 1, 0,
		0, 0, 2277, 2275, 1, 0, 0, 0, 2277, 2278, 1, 0, 0, 0, 2278, 177, 1, 0,
		0, 0, 2279, 2277, 1, 0, 0, 0, 2280, 2298, 3, 180, 90, 0, 2281, 2283, 5,
		5, 0, 0, 2282, 2281, 1, 0, 0, 0, 2283, 2286, 1, 0, 0, 0, 2284, 2282, 1,
		0, 0, 0, 2284, 2285, 1, 0, 0, 0, 2285, 2287, 1, 0, 0, 0, 2286, 2284, 1,
		0, 0, 0, 2287, 2291, 3, 288, 144, 0, 2288, 2290, 5, 5, 0, 0, 2289, 2288,
		1, 0, 0, 0, 2290, 2293, 1, 0, 0, 0, 2291, 2289, 1, 0, 0, 0, 2291, 2292,
		1, 0, 0, 0, 2292, 2294, 1, 0, 0, 0, 2293, 2291, 1, 0, 0, 0, 2294, 2295,
		3, 98, 49, 0, 2295, 2297, 1, 0, 0, 0, 2296, 2284, 1, 0, 0, 0, 2297, 2300,
		1, 0, 0, 0, 2298, 2296, 1, 0, 0, 0, 2298, 2299, 1, 0, 0, 0, 2299, 179,
		1, 0, 0, 0, 2300, 2298, 1, 0, 0, 0, 2301, 2303, 3, 182, 91, 0, 2302, 2301,
		1, 0, 0, 0, 2303, 2306, 1, 0, 0, 0, 2304, 2302, 1, 0, 0, 0, 2304, 2305,
		1, 0, 0, 0, 2305, 2307, 1, 0, 0, 0, 2306, 2304, 1, 0, 0, 0, 2307, 2308,
		3, 184, 92, 0, 2308, 181, 1, 0, 0, 0, 2309, 2319, 3, 334, 167, 0, 2310,
		2319, 3, 132, 66, 0, 2311, 2315, 3, 290, 145, 0, 2312, 2314, 5, 5, 0, 0,
		2313, 2312, 1, 0, 0, 0, 2314, 2317, 1, 0, 0, 0, 2315, 2313, 1, 0, 0, 0,
		2315, 2316, 1, 0, 0, 0, 2316, 2319, 1, 0, 0, 0, 2317, 2315, 1, 0, 0, 0,
		2318, 2309, 1, 0, 0, 0, 2318, 2310, 1, 0, 0, 0, 2318, 2311, 1, 0, 0, 0,
		2319, 183, 1, 0, 0, 0, 2320, 2324, 3, 212, 106, 0, 2321, 2323, 3, 186,
		93, 0, 2322, 2321, 1, 0, 0, 0, 2323, 2326, 1, 0, 0, 0, 2324, 2322, 1, 0,
		0, 0, 2324, 2325, 1, 0, 0, 0, 2325, 185, 1, 0, 0, 0, 2326, 2324, 1, 0,
		0, 0, 2327, 2333, 3, 292, 146, 0, 2328, 2333, 3, 206, 103, 0, 2329, 2333,
		3, 202, 101, 0, 2330, 2333, 3, 198, 99, 0, 2331, 2333, 3, 200, 100, 0,
		2332, 2327, 1, 0, 0, 0, 2332, 2328, 1, 0, 0, 0, 2332, 2329, 1, 0, 0, 0,
		2332, 2330, 1, 0, 0, 0, 2332, 2331, 1, 0, 0, 0, 2333, 187, 1, 0, 0, 0,
		2334, 2335, 3, 184, 92, 0, 2335, 2336, 3, 196, 98, 0, 2336, 2340, 1, 0,
		0, 0, 2337, 2340, 3, 344, 172, 0, 2338, 2340, 3, 190, 95, 0, 2339, 2334,
		1, 0, 0, 0, 2339, 2337, 1, 0, 0, 0, 2339, 2338, 1, 0, 0, 0, 2340, 189,
		1, 0, 0, 0, 2341, 2345, 5, 9, 0, 0, 2342, 2344, 5, 5, 0, 0, 2343, 2342,
		1, 0, 0, 0, 2344, 2347, 1, 0, 0, 0, 2345, 2343, 1, 0, 0, 0, 2345, 2346,
		1, 0, 0, 0, 2346, 2348, 1, 0, 0, 0, 2347, 2345, 1, 0, 0, 0, 2348, 2352,
		3, 188, 94, 0, 2349, 2351, 5, 5, 0, 0, 2350, 2349, 1, 0, 0, 0, 2351, 2354,
		1, 0, 0, 0, 2352, 2350, 1, 0, 0, 0, 2352, 2353, 1, 0, 0, 0, 2353, 2355,
		1, 0, 0, 0, 2354, 2352, 1, 0, 0, 0, 2355, 2356, 5, 10, 0, 0, 2356, 191,
		1, 0, 0, 0, 2357, 2360, 3, 180, 90, 0, 2358, 2360, 3, 194, 97, 0, 2359,
		2357, 1, 0, 0, 0, 2359, 2358, 1, 0, 0, 0, 2360, 193, 1, 0, 0, 0, 2361,
		2365, 5, 9, 0, 0, 2362, 2364, 5, 5, 0, 0, 2363, 2362, 1, 0, 0, 0, 2364,
		2367, 1, 0, 0, 0, 2365, 2363, 1, 0, 0, 0, 2365, 2366, 1, 0, 0, 0, 2366,
		2368, 1, 0, 0, 0, 2367, 2365, 1, 0, 0, 0, 2368, 2372, 3, 192, 96, 0, 2369,
		2371, 5, 5, 0, 0, 2370, 2369, 1, 0, 0, 0, 2371, 2374, 1, 0, 0, 0, 2372,
		2370, 1, 0, 0, 0, 2372, 2373, 1, 0, 0, 0, 2373, 2375, 1, 0, 0, 0, 2374,
		2372, 1, 0, 0, 0, 2375, 2376, 5, 10, 0, 0, 2376, 195, 1, 0, 0, 0, 2377,
		2381, 3, 206, 103, 0, 2378, 2381, 3, 198, 99, 0, 2379, 2381, 3, 200, 100,
		0, 2380, 2377, 1, 0, 0, 0, 2380, 2378, 1, 0, 0, 0, 2380, 2379, 1, 0, 0,
		0, 2381, 197, 1, 0, 0, 0, 2382, 2386, 5, 11, 0, 0, 2383, 2385, 5, 5, 0,
		0, 2384, 2383, 1, 0, 0, 0, 2385, 2388, 1, 0, 0, 0, 2386, 2384, 1, 0, 0,
		0, 2386, 2387, 1, 0, 0, 0, 2387, 2389, 1, 0, 0, 0, 2388, 2386, 1, 0, 0,
		0, 2389, 2406, 3, 152, 76, 0, 2390, 2392, 5, 5, 0, 0, 2391, 2390, 1, 0,
		0, 0, 2392, 2395, 1, 0, 0, 0, 2393, 2391, 1, 0, 0, 0, 2393, 2394, 1, 0,
		0, 0, 2394, 2396, 1, 0, 0, 0, 2395, 2393, 1, 0, 0, 0, 2396, 2400, 5, 8,
		0, 0, 2397, 2399, 5, 5, 0, 0, 2398, 2397, 1, 0, 0, 0, 2399, 2402, 1, 0,
		0, 0, 2400, 2398, 1, 0, 0, 0, 2400, 2401, 1, 0, 0, 0, 2401, 2403, 1, 0,
		0, 0, 2402, 2400, 1, 0, 0, 0, 2403, 2405, 3, 152, 76, 0, 2404, 2393, 1,
		0, 0, 0, 2405, 2408, 1, 0, 0, 0, 2406, 2404, 1, 0, 0, 0, 2406, 2407, 1,
		0, 0, 0, 2407, 2416, 1, 0, 0, 0, 2408, 2406, 1, 0, 0, 0, 2409, 2411, 5,
		5, 0, 0, 2410, 2409, 1, 0, 0, 0, 2411, 2414, 1, 0, 0, 0, 2412, 2410, 1,
		0, 0, 0, 2412, 2413, 1, 0, 0, 0, 2413, 2415, 1, 0, 0, 0, 2414, 2412, 1,
		0, 0, 0, 2415, 2417, 5, 8, 0, 0, 2416, 2412, 1, 0, 0, 0, 2416, 2417, 1,
		0, 0, 0, 2417, 2421, 1, 0, 0, 0, 2418, 2420, 5, 5, 0, 0, 2419, 2418, 1,
		0, 0, 0, 2420, 2423, 1, 0, 0, 0, 2421, 2419, 1, 0, 0, 0, 2421, 2422, 1,
		0, 0, 0, 2422, 2424, 1, 0, 0, 0, 2423, 2421, 1, 0, 0, 0, 2424, 2425, 5,
		12, 0, 0, 2425, 199, 1, 0, 0, 0, 2426, 2430, 3, 296, 148, 0, 2427, 2429,
		5, 5, 0, 0, 2428, 2427, 1, 0, 0, 0, 2429, 2432, 1, 0, 0, 0, 2430, 2428,
		1, 0, 0, 0, 2430, 2431, 1, 0, 0, 0, 2431, 2436, 1, 0, 0, 0, 2432, 2430,
		1, 0, 0, 0, 2433, 2437, 3, 344, 172, 0, 2434, 2437, 3, 214, 107, 0, 2435,
		2437, 5, 73, 0, 0, 2436, 2433, 1, 0, 0, 0, 2436, 2434, 1, 0, 0, 0, 2436,
		2435, 1, 0, 0, 0, 2437, 201, 1, 0, 0, 0, 2438, 2440, 3, 206, 103, 0, 2439,
		2438, 1, 0, 0, 0, 2439, 2440, 1, 0, 0, 0, 2440, 2446, 1, 0, 0, 0, 2441,
		2443, 3, 208, 104, 0, 2442, 2441, 1, 0, 0, 0, 2442, 2443, 1, 0, 0, 0, 2443,
		2444, 1, 0, 0, 0, 2444, 2447, 3, 204, 102, 0, 2445, 2447, 3, 208, 104,
		0, 2446, 2442, 1, 0, 0, 0, 2446, 2445, 1, 0, 0, 0, 2447, 203, 1, 0, 0,
		0, 2448, 2450, 3, 334, 167, 0, 2449, 2448, 1, 0, 0, 0, 2450, 2453, 1, 0,
		0, 0, 2451, 2449, 1, 0, 0, 0, 2451, 2452, 1, 0, 0, 0, 2452, 2455, 1, 0,
		0, 0, 2453, 2451, 1, 0, 0, 0, 2454, 2456, 3, 132, 66, 0, 2455, 2454, 1,
		0, 0, 0, 2455, 2456, 1, 0, 0, 0, 2456, 2460, 1, 0, 0, 0, 2457, 2459, 5,
		5, 0, 0, 2458, 2457, 1, 0, 0, 0, 2459, 2462, 1, 0, 0, 0, 2460, 2458, 1,
		0, 0, 0, 2460, 2461, 1, 0, 0, 0, 2461, 2463, 1, 0, 0, 0, 2462, 2460, 1,
		0, 0, 0, 2463, 2464, 3, 234, 117, 0, 2464, 205, 1, 0, 0, 0, 2465, 2469,
		5, 46, 0, 0, 2466, 2468, 5, 5, 0, 0, 2467, 2466, 1, 0, 0, 0, 2468, 2471,
		1, 0, 0, 0, 2469, 2467, 1, 0, 0, 0, 2469, 2470, 1, 0, 0, 0, 2470, 2472,
		1, 0, 0, 0, 2471, 2469, 1, 0, 0, 0, 2472, 2489, 3, 110, 55, 0, 2473, 2475,
		5, 5, 0, 0, 2474, 2473, 1, 0, 0, 0, 2475, 2478, 1, 0, 0, 0, 2476, 2474,
		1, 0, 0, 0, 2476, 2477, 1, 0, 0, 0, 2477, 2479, 1, 0, 0, 0, 2478, 2476,
		1, 0, 0, 0, 2479, 2483, 5, 8, 0, 0, 2480, 2482, 5, 5, 0, 0, 2481, 2480,
		1, 0, 0, 0, 2482, 2485, 1, 0, 0, 0, 2483, 2481, 1, 0, 0, 0, 2483, 2484,
		1, 0, 0, 0, 2484, 2486, 1, 0, 0, 0, 2485, 2483, 1, 0, 0, 0, 2486, 2488,
		3, 110, 55, 0, 2487, 2476, 1, 0, 0, 0, 2488, 2491, 1, 0, 0, 0, 2489, 2487,
		1, 0, 0, 0, 2489, 2490, 1, 0, 0, 0, 2490, 2499, 1, 0, 0, 0, 2491, 2489,
		1, 0, 0, 0, 2492, 2494, 5, 5, 0, 0, 2493, 2492, 1, 0, 0, 0, 2494, 2497,
		1, 0, 0, 0, 2495, 2493, 1, 0, 0, 0, 2495, 2496, 1, 0, 0, 0, 2496, 2498,
		1, 0, 0, 0, 2497, 2495, 1, 0, 0, 0, 2498, 2500, 5, 8, 0, 0, 2499, 2495,
		1, 0, 0, 0, 2499, 2500, 1, 0, 0, 0, 2500, 2504, 1, 0, 0, 0, 2501, 2503,
		5, 5, 0, 0, 2502, 2501, 1, 0, 0, 0, 2503, 2506, 1, 0, 0, 0, 2504, 2502,
		1, 0, 0, 0, 2504, 2505, 1, 0, 0, 0, 2505, 2507, 1, 0, 0, 0, 2506, 2504,
		1, 0, 0, 0, 2507, 2508, 5, 47, 0, 0, 2508, 207, 1, 0, 0, 0, 2509, 2513,
		5, 9, 0, 0, 2510, 2512, 5, 5, 0, 0, 2511, 2510, 1, 0, 0, 0, 2512, 2515,
		1, 0, 0, 0, 2513, 2511, 1, 0, 0, 0, 2513, 2514, 1, 0, 0, 0, 2514, 2551,
		1, 0, 0, 0, 2515, 2513, 1, 0, 0, 0, 2516, 2533, 3, 210, 105, 0, 2517, 2519,
		5, 5, 0, 0, 2518, 2517, 1, 0, 0, 0, 2519, 2522, 1, 0, 0, 0, 2520, 2518,
		1, 0, 0, 0, 2520, 2521, 1, 0, 0, 0, 2521, 2523, 1, 0, 0, 0, 2522, 2520,
		1, 0, 0, 0, 2523, 2527, 5, 8, 0, 0, 2524, 2526, 5, 5, 0, 0, 2525, 2524,
		1, 0, 0, 0, 2526, 2529, 1, 0, 0, 0, 2527, 2525, 1, 0, 0, 0, 2527, 2528,
		1, 0, 0, 0, 2528, 2530, 1, 0, 0, 0, 2529, 2527, 1, 0, 0, 0, 2530, 2532,
		3, 210, 105, 0, 2531, 2520, 1, 0, 0, 0, 2532, 2535, 1, 0, 0, 0, 2533, 2531,
		1, 0, 0, 0, 2533, 2534, 1, 0, 0, 0, 2534, 2543, 1, 0, 0, 0, 2535, 2533,
		1, 0, 0, 0, 2536, 2538, 5, 5, 0, 0, 2537, 2536, 1, 0, 0, 0, 2538, 2541,
		1, 0, 0, 0, 2539, 2537, 1, 0, 0, 0, 2539, 2540, 1, 0, 0, 0, 2540, 2542,
		1, 0, 0, 0, 2541, 2539, 1, 0, 0, 0, 2542, 2544, 5, 8, 0, 0, 2543, 2539,
		1, 0, 0, 0, 2543, 2544, 1, 0, 0, 0, 2544, 2548, 1, 0, 0, 0, 2545, 2547,
		5, 5, 0, 0, 2546, 2545, 1, 0, 0, 0, 2547, 2550, 1, 0, 0, 0, 2548, 2546,
		1, 0, 0, 0, 2548, 2549, 1, 0, 0, 0, 2549, 2552, 1, 0, 0, 0, 2550, 2548,
		1, 0, 0, 0, 2551, 2516, 1, 0, 0, 0, 2551, 2552, 1, 0, 0, 0, 2552, 2553,
		1, 0, 0, 0, 2553, 2554, 5, 10, 0, 0, 2554, 209, 1, 0, 0, 0, 2555, 2557,
		3, 334, 167, 0, 2556, 2555, 1, 0, 0, 0, 2556, 2557, 1, 0, 0, 0, 2557, 2561,
		1, 0, 0, 0, 2558, 2560, 5, 5, 0, 0, 2559, 2558, 1, 0, 0, 0, 2560, 2563,
		1, 0, 0, 0, 2561, 2559, 1, 0, 0, 0, 2561, 2562, 1, 0, 0, 0, 2562, 2578,
		1, 0, 0, 0, 2563, 2561, 1, 0, 0, 0, 2564, 2568, 3, 344, 172, 0, 2565, 2567,
		5, 5, 0, 0, 2566, 2565, 1, 0, 0, 0, 2567, 2570, 1, 0, 0, 0, 2568, 2566,
		1, 0, 0, 0, 2568, 2569, 1, 0, 0, 0, 2569, 2571, 1, 0, 0, 0, 2570, 2568,
		1, 0, 0, 0, 2571, 2575, 5, 28, 0, 0, 2572, 2574, 5, 5, 0, 0, 2573, 2572,
		1, 0, 0, 0, 2574, 2577, 1, 0, 0, 0, 2575, 2573, 1, 0, 0, 0, 2575, 2576,
		1, 0, 0, 0, 2576, 2579, 1, 0, 0, 0, 2577, 2575, 1, 0, 0, 0, 2578, 2564,
		1, 0, 0, 0, 2578, 2579, 1, 0, 0, 0, 2579, 2581, 1, 0, 0, 0, 2580, 2582,
		5, 15, 0, 0, 2581, 2580, 1, 0, 0, 0, 2581, 2582, 1, 0, 0, 0, 2582, 2586,
		1, 0, 0, 0, 2583, 2585, 5, 5, 0, 0, 2584, 2583, 1, 0, 0, 0, 2585, 2588,
		1, 0, 0, 0, 2586, 2584, 1, 0, 0, 0, 2586, 2587, 1, 0, 0, 0, 2587, 2589,
		1, 0, 0, 0, 2588, 2586, 1, 0, 0, 0, 2589, 2590, 3, 152, 76, 0, 2590, 211,
		1, 0, 0, 0, 2591, 2606, 3, 214, 107, 0, 2592, 2606, 3, 344, 172, 0, 2593,
		2606, 3, 218, 109, 0, 2594, 2606, 3, 220, 110, 0, 2595, 2606, 3, 272, 136,
		0, 2596, 2606, 3, 242, 121, 0, 2597, 2606, 3, 244, 122, 0, 2598, 2606,
		3, 216, 108, 0, 2599, 2606, 3, 246, 123, 0, 2600, 2606, 3, 248, 124, 0,
		2601, 2606, 3, 250, 125, 0, 2602, 2606, 3, 254, 127, 0, 2603, 2606, 3,
		264, 132, 0, 2604, 2606, 3, 270, 135, 0, 2605, 2591, 1, 0, 0, 0, 2605,
		2592, 1, 0, 0, 0, 2605, 2593, 1, 0, 0, 0, 2605, 2594, 1, 0, 0, 0, 2605,
		2595, 1, 0, 0, 0, 2605, 2596, 1, 0, 0, 0, 2605, 2597, 1, 0, 0, 0, 2605,
		2598, 1, 0, 0, 0, 2605, 2599, 1, 0, 0, 0, 2605, 2600, 1, 0, 0, 0, 2605,
		2601, 1, 0, 0, 0, 2605, 2602, 1, 0, 0, 0, 2605, 2603, 1, 0, 0, 0, 2605,
		2604, 1, 0, 0, 0, 2606, 213, 1, 0, 0, 0, 2607, 2611, 5, 9, 0, 0, 2608,
		2610, 5, 5, 0, 0, 2609, 2608, 1, 0, 0, 0, 2610, 2613, 1, 0, 0, 0, 2611,
		2609, 1, 0, 0, 0, 2611, 2612, 1, 0, 0, 0, 2612, 2614, 1, 0, 0, 0, 2613,
		2611, 1, 0, 0, 0, 2614, 2618, 3, 152, 76, 0, 2615, 2617, 5, 5, 0, 0, 2616,
		2615, 1, 0, 0, 0, 2617, 2620, 1, 0, 0, 0, 2618, 2616, 1, 0, 0, 0, 2618,
		2619, 1, 0, 0, 0, 2619, 2621, 1, 0, 0, 0, 2620, 2618, 1, 0, 0, 0, 2621,
		2622, 5, 10, 0, 0, 2622, 215, 1, 0, 0, 0, 2623, 2627, 5, 11, 0, 0, 2624,
		2626, 5, 5, 0, 0, 2625, 2624, 1, 0, 0, 0, 2626, 2629, 1, 0, 0, 0, 2627,
		2625, 1, 0, 0, 0, 2627, 2628, 1, 0, 0, 0, 2628, 2665, 1, 0, 0, 0, 2629,
		2627, 1, 0, 0, 0, 2630, 2647, 3, 152, 76, 0, 2631, 2633, 5, 5, 0, 0, 2632,
		2631, 1, 0, 0, 0, 2633, 2636, 1, 0, 0, 0, 2634, 2632, 1, 0, 0, 0, 2634,
		2635, 1, 0, 0, 0, 2635, 2637, 1, 0, 0, 0, 2636, 2634, 1, 0, 0, 0, 2637,
		2641, 5, 8, 0, 0, 2638, 2640, 5, 5, 0, 0, 2639, 2638, 1, 0, 0, 0, 2640,
		2643, 1, 0, 0, 0, 2641, 2639, 1, 0, 0, 0, 2641, 2642, 1, 0, 0, 0, 2642,
		2644, 1, 0, 0, 0, 2643, 2641, 1, 0, 0, 0, 2644, 2646, 3, 152, 76, 0, 2645,
		2634, 1, 0, 0, 0, 2646, 2649, 1, 0, 0, 0, 2647, 2645, 1, 0, 0, 0, 2647,
		2648, 1, 0, 0, 0, 2648, 2657, 1, 0, 0, 0, 2649, 2647, 1, 0, 0, 0, 2650,
		2652, 5, 5, 0, 0, 2651, 2650, 1, 0, 0, 0, 2652, 2655, 1, 0, 0, 0, 2653,
		2651, 1, 0, 0, 0, 2653, 2654, 1, 0, 0, 0, 2654, 2656, 1, 0, 0, 0, 2655,
		2653, 1, 0, 0, 0, 2656, 2658, 5, 8, 0, 0, 2657, 2653, 1, 0, 0, 0, 2657,
		2658, 1, 0, 0, 0, 2658, 2662, 1, 0, 0, 0, 2659, 2661, 5, 5, 0, 0, 2660,
		2659, 1, 0, 0, 0, 2661, 2664, 1, 0, 0, 0, 2662, 2660, 1, 0, 0, 0, 2662,
		2663, 1, 0, 0, 0, 2663, 2666, 1, 0, 0, 0, 2664, 2662, 1, 0, 0, 0, 2665,
		2630, 1, 0, 0, 0, 2665, 2666, 1, 0, 0, 0, 2666, 2667, 1, 0, 0, 0, 2667,
		2668, 5, 12, 0, 0, 2668, 217, 1, 0, 0, 0, 2669, 2670, 7, 6, 0, 0, 2670,
		219, 1, 0, 0, 0, 2671, 2674, 3, 222, 111, 0, 2672, 2674, 3, 224, 112, 0,
		2673, 2671, 1, 0, 0, 0, 2673, 2672, 1, 0, 0, 0, 2674, 221, 1, 0, 0, 0,
		2675, 2680, 5, 150, 0, 0, 2676, 2679, 3, 226, 113, 0, 2677, 2679, 3, 228,
		114, 0, 2678, 2676, 1, 0, 0, 0, 2678, 2677, 1, 0, 0, 0, 2679, 2682, 1,
		0, 0, 0, 2680, 2678, 1, 0, 0, 0, 2680, 2681, 1, 0, 0, 0, 2681, 2683, 1,
		0, 0, 0, 2682, 2680, 1, 0, 0, 0, 2683, 2684, 5, 159, 0, 0, 2684, 223, 1,
		0, 0, 0, 2685, 2691, 5, 151, 0, 0, 2686, 2690, 3, 230, 115, 0, 2687, 2690,
		3, 232, 116, 0, 2688, 2690, 5, 165, 0, 0, 2689, 2686, 1, 0, 0, 0, 2689,
		2687, 1, 0, 0, 0, 2689, 2688, 1, 0, 0, 0, 2690, 2693, 1, 0, 0, 0, 2691,
		2689, 1, 0, 0, 0, 2691, 2692, 1, 0, 0, 0, 2692, 2694, 1, 0, 0, 0, 2693,
		2691, 1, 0, 0, 0, 2694, 2695, 5, 164, 0, 0, 2695, 225, 1, 0, 0, 0, 2696,
		2697, 7, 7, 0, 0, 2697, 227, 1, 0, 0, 0, 2698, 2702, 5, 163, 0, 0, 2699,
		2701, 5, 5, 0, 0, 2700, 2699, 1, 0, 0, 0, 2701, 2704, 1, 0, 0, 0, 2702,
		2700, 1, 0, 0, 0, 2702, 2703, 1, 0, 0, 0, 2703, 2705, 1, 0, 0, 0, 2704,
		2702, 1, 0, 0, 0, 2705, 2709, 3, 152, 76, 0, 2706, 2708, 5, 5, 0, 0, 2707,
		2706, 1, 0, 0, 0, 2708, 2711, 1, 0, 0, 0, 2709, 2707, 1, 0, 0, 0, 2709,
		2710, 1, 0, 0, 0, 2710, 2712, 1, 0, 0, 0, 2711, 2709, 1, 0, 0, 0, 2712,
		2713, 5, 14, 0, 0, 2713, 229, 1, 0, 0, 0, 2714, 2715, 7, 8, 0, 0, 2715,
		231, 1, 0, 0, 0, 2716, 2720, 5, 168, 0, 0, 2717, 2719, 5, 5, 0, 0, 2718,
		2717, 1, 0, 0, 0, 2719, 2722, 1, 0, 0, 0, 2720, 2718, 1, 0, 0, 0, 2720,
		2721, 1, 0, 0, 0, 2721, 2723, 1, 0, 0, 0, 2722, 2720, 1, 0, 0, 0, 2723,
		2727, 3, 152, 76, 0, 2724, 2726, 5, 5, 0, 0, 2725, 2724, 1, 0, 0, 0, 2726,
		2729, 1, 0, 0, 0, 2727, 2725, 1, 0, 0, 0, 2727, 2728, 1, 0, 0, 0, 2728,
		2730, 1, 0, 0, 0, 2729, 2727, 1, 0, 0, 0, 2730, 2731, 5, 14, 0, 0, 2731,
		233, 1, 0, 0, 0, 2732, 2736, 5, 13, 0, 0, 2733, 2735, 5, 5, 0, 0, 2734,
		2733, 1, 0, 0, 0, 2735, 2738, 1, 0, 0, 0, 2736, 2734, 1, 0, 0, 0, 2736,
		2737, 1, 0, 0, 0, 2737, 2755, 1, 0, 0, 0, 2738, 2736, 1, 0, 0, 0, 2739,
		2741, 3, 236, 118, 0, 2740, 2739, 1, 0, 0, 0, 2740, 2741, 1, 0, 0, 0, 2741,
		2745, 1, 0, 0, 0, 2742, 2744, 5, 5, 0, 0, 2743, 2742, 1, 0, 0, 0, 2744,
		2747, 1, 0, 0, 0, 2745, 2743, 1, 0, 0, 0, 2745, 2746, 1, 0, 0, 0, 2746,
		2748, 1, 0, 0, 0, 2747, 2745, 1, 0, 0, 0, 2748, 2752, 5, 34, 0, 0, 2749,
		2751, 5, 5, 0, 0, 2750, 2749, 1, 0, 0, 0, 2751, 2754, 1, 0, 0, 0, 2752,
		2750, 1, 0, 0, 0, 2752, 2753, 1, 0, 0, 0, 2753, 2756, 1, 0, 0, 0, 2754,
		2752, 1, 0, 0, 0, 2755, 2740, 1, 0, 0, 0, 2755, 2756, 1, 0, 0, 0, 2756,
		2757, 1, 0, 0, 0, 2757, 2761, 3, 128, 64, 0, 2758, 2760, 5, 5, 0, 0, 2759,
		2758, 1, 0, 0, 0, 2760, 2763, 1, 0, 0, 0, 2761, 2759, 1, 0, 0, 0, 2761,
		2762, 1, 0, 0, 0, 2762, 2764, 1, 0, 0, 0, 2763, 2761, 1, 0, 0, 0, 2764,
		2765, 5, 14, 0, 0, 2765, 235, 1, 0, 0, 0, 2766, 2783, 3, 238, 119, 0, 2767,
		2769, 5, 5, 0, 0, 2768, 2767, 1, 0, 0, 0, 2769, 2772, 1, 0, 0, 0, 2770,
		2768, 1, 0, 0, 0, 2770, 2771, 1, 0, 0, 0, 2771, 2773, 1, 0, 0, 0, 2772,
		2770, 1, 0, 0, 0, 2773, 2777, 5, 8, 0, 0, 2774, 2776, 5, 5, 0, 0, 2775,
		2774, 1, 0, 0, 0, 2776, 2779, 1, 0, 0, 0, 2777, 2775, 1, 0, 0, 0, 2777,
		2778, 1, 0, 0, 0, 2778, 2780, 1, 0, 0, 0, 2779, 2777, 1, 0, 0, 0, 2780,
		2782, 3, 238, 119, 0, 2781, 2770, 1, 0, 0, 0, 2782, 2785, 1, 0, 0, 0, 2783,
		2781, 1, 0, 0, 0, 2783, 2784, 1, 0, 0, 0, 2784, 2793, 1, 0, 0, 0, 2785,
		2783, 1, 0, 0, 0, 2786, 2788, 5, 5, 0, 0, 2787, 2786, 1, 0, 0, 0, 2788,
		2791, 1, 0, 0, 0, 2789, 2787, 1, 0, 0, 0, 2789, 2790, 1, 0, 0, 0, 2790,
		2792, 1, 0, 0, 0, 2791, 2789, 1, 0, 0, 0, 2792, 2794, 5, 8, 0, 0, 2793,
		2789, 1, 0, 0, 0, 2793, 2794, 1, 0, 0, 0, 2794, 237, 1, 0, 0, 0, 2795,
		2814, 3, 66, 33, 0, 2796, 2811, 3, 68, 34, 0, 2797, 2799, 5, 5, 0, 0, 2798,
		2797, 1, 0, 0, 0, 2799, 2802, 1, 0, 0, 0, 2800, 2798, 1, 0, 0, 0, 2800,
		2801, 1, 0, 0, 0, 2801, 2803, 1, 0, 0, 0, 2802, 2800, 1, 0, 0, 0, 2803,
		2807, 5, 26, 0, 0, 2804, 2806, 5, 5, 0, 0, 2805, 2804, 1, 0, 0, 0, 2806,
		2809, 1, 0, 0, 0, 2807, 2805, 1, 0, 0, 0, 2807, 2808, 1, 0, 0, 0, 2808,
		2810, 1, 0, 0, 0, 2809, 2807, 1, 0, 0, 0, 2810, 2812, 3, 98, 49, 0, 2811,
		2800, 1, 0, 0, 0, 2811, 2812, 1, 0, 0, 0, 2812, 2814, 1, 0, 0, 0, 2813,
		2795, 1, 0, 0, 0, 2813, 2796, 1, 0, 0, 0, 2814, 239, 1, 0, 0, 0, 2815,
		2831, 5, 75, 0, 0, 2816, 2818, 5, 5, 0, 0, 2817, 2816, 1, 0, 0, 0, 2818,
		2821, 1, 0, 0, 0, 2819, 2817, 1, 0, 0, 0, 2819, 2820, 1, 0, 0, 0, 2820,
		2822, 1, 0, 0, 0, 2821, 2819, 1, 0, 0, 0, 2822, 2826, 3, 98, 49, 0, 2823,
		2825, 5, 5, 0, 0, 2824, 2823, 1, 0, 0, 0, 2825, 2828, 1, 0, 0, 0, 2826,
		2824, 1, 0, 0, 0, 2826, 2827, 1, 0, 0, 0, 2827, 2829, 1, 0, 0, 0, 2828,
		2826, 1, 0, 0, 0, 2829, 2830, 5, 7, 0, 0, 2830, 2832, 1, 0, 0, 0, 2831,
		2819, 1, 0, 0, 0, 2831, 2832, 1, 0, 0, 0, 2832, 2836, 1, 0, 0, 0, 2833,
		2835, 5, 5, 0, 0, 2834, 2833, 1, 0, 0, 0, 2835, 2838, 1, 0, 0, 0, 2836,
		2834, 1, 0, 0, 0, 2836, 2837, 1, 0, 0, 0, 2837, 2839, 1, 0, 0, 0, 2838,
		2836, 1, 0, 0, 0, 2839, 2854, 3, 78, 39, 0, 2840, 2842, 5, 5, 0, 0, 2841,
		2840, 1, 0, 0, 0, 2842, 2845, 1, 0, 0, 0, 2843, 2841, 1, 0, 0, 0, 2843,
		2844, 1, 0, 0, 0, 2844, 2846, 1, 0, 0, 0, 2845, 2843, 1, 0, 0, 0, 2846,
		2850, 5, 26, 0, 0, 2847, 2849, 5, 5, 0, 0, 2848, 2847, 1, 0, 0, 0, 2849,
		2852, 1, 0, 0, 0, 2850, 2848, 1, 0, 0, 0, 2850, 2851, 1, 0, 0, 0, 2851,
		2853, 1, 0, 0, 0, 2852, 2850, 1, 0, 0, 0, 2853, 2855, 3, 98, 49, 0, 2854,
		2843, 1, 0, 0, 0, 2854, 2855, 1, 0, 0, 0, 2855, 2863, 1, 0, 0, 0, 2856,
		2858, 5, 5, 0, 0, 2857, 2856, 1, 0, 0, 0, 2858, 2861, 1, 0, 0, 0, 2859,
		2857, 1, 0, 0, 0, 2859, 2860, 1, 0, 0, 0, 2860, 2862, 1, 0, 0, 0, 2861,
		2859, 1, 0, 0, 0, 2862, 2864, 3, 46, 23, 0, 2863, 2859, 1, 0, 0, 0, 2863,
		2864, 1, 0, 0, 0, 2864, 2872, 1, 0, 0, 0, 2865, 2867, 5, 5, 0, 0, 2866,
		2865, 1, 0, 0, 0, 2867, 2870, 1, 0, 0, 0, 2868, 2866, 1, 0, 0, 0, 2868,
		2869, 1, 0, 0, 0, 2869, 2871, 1, 0, 0, 0, 2870, 2868, 1, 0, 0, 0, 2871,
		2873, 3, 64, 32, 0, 2872, 2868, 1, 0, 0, 0, 2872, 2873, 1, 0, 0, 0, 2873,
		241, 1, 0, 0, 0, 2874, 2877, 3, 234, 117, 0, 2875, 2877, 3, 240, 120, 0,
		2876, 2874, 1, 0, 0, 0, 2876, 2875, 1, 0, 0, 0, 2877, 243, 1, 0, 0, 0,
		2878, 2899, 5, 76, 0, 0, 2879, 2881, 5, 5, 0, 0, 2880, 2879, 1, 0, 0, 0,
		2881, 2884, 1, 0, 0, 0, 2882, 2880, 1, 0, 0, 0, 2882, 2883, 1, 0, 0, 0,
		2883, 2885, 1, 0, 0, 0, 2884, 2882, 1, 0, 0, 0, 2885, 2889, 5, 26, 0, 0,
		2886, 2888, 5, 5, 0, 0, 2887, 2886, 1, 0, 0, 0, 2888, 2891, 1, 0, 0, 0,
		2889, 2887, 1, 0, 0, 0, 2889, 2890, 1, 0, 0, 0, 2890, 2892, 1, 0, 0, 0,
		2891, 2889, 1, 0, 0, 0, 2892, 2896, 3, 32, 16, 0, 2893, 2895, 5, 5, 0,
		0, 2894, 2893, 1, 0, 0, 0, 2895, 2898, 1, 0, 0, 0, 2896, 2894, 1, 0, 0,
		0, 2896, 2897, 1, 0, 0, 0, 2897, 2900, 1, 0, 0, 0, 2898, 2896, 1, 0, 0,
		0, 2899, 2882, 1, 0, 0, 0, 2899, 2900, 1, 0, 0, 0, 2900, 2908, 1, 0, 0,
		0, 2901, 2903, 5, 5, 0, 0, 2902, 2901, 1, 0, 0, 0, 2903, 2906, 1, 0, 0,
		0, 2904, 2902, 1, 0, 0, 0, 2904, 2905, 1, 0, 0, 0, 2905, 2907, 1, 0, 0,
		0, 2906, 2904, 1, 0, 0, 0, 2907, 2909, 3, 26, 13, 0, 2908, 2904, 1, 0,
		0, 0, 2908, 2909, 1, 0, 0, 0, 2909, 245, 1, 0, 0, 0, 2910, 2911, 7, 9,
		0, 0, 2911, 247, 1, 0, 0, 0, 2912, 2929, 5, 85, 0, 0, 2913, 2917, 5, 46,
		0, 0, 2914, 2916, 5, 5, 0, 0, 2915, 2914, 1, 0, 0, 0, 2916, 2919, 1, 0,
		0, 0, 2917, 2915, 1, 0, 0, 0, 2917, 2918, 1, 0, 0, 0, 2918, 2920, 1, 0,
		0, 0, 2919, 2917, 1, 0, 0, 0, 2920, 2924, 3, 98, 49, 0, 2921, 2923, 5,
		5, 0, 0, 2922, 2921, 1, 0, 0, 0, 2923, 2926, 1, 0, 0, 0, 2924, 2922, 1,
		0, 0, 0, 2924, 2925, 1, 0, 0, 0, 2925, 2927, 1, 0, 0, 0, 2926, 2924, 1,
		0, 0, 0, 2927, 2928, 5, 47, 0, 0, 2928, 2930, 1, 0, 0, 0, 2929, 2913, 1,
		0, 0, 0, 2929, 2930, 1, 0, 0, 0, 2930, 2933, 1, 0, 0, 0, 2931, 2932, 5,
		40, 0, 0, 2932, 2934, 3, 344, 172, 0, 2933, 2931, 1, 0, 0, 0, 2933, 2934,
		1, 0, 0, 0, 2934, 2937, 1, 0, 0, 0, 2935, 2937, 5, 61, 0, 0, 2936, 2912,
		1, 0, 0, 0, 2936, 2935, 1, 0, 0, 0, 2937, 249, 1, 0, 0, 0, 2938, 2942,
		5, 88, 0, 0, 2939, 2941, 5, 5, 0, 0, 2940, 2939, 1, 0, 0, 0, 2941, 2944,
		1, 0, 0, 0, 2942, 2940, 1, 0, 0, 0, 2942, 2943, 1, 0, 0, 0, 2943, 2945,
		1, 0, 0, 0, 2944, 2942, 1, 0, 0, 0, 2945, 2949, 5, 9, 0, 0, 2946, 2948,
		5, 5, 0, 0, 2947, 2946, 1, 0, 0, 0, 2948, 2951, 1, 0, 0, 0, 2949, 2947,
		1, 0, 0, 0, 2949, 2950, 1, 0, 0, 0, 2950, 2952, 1, 0, 0, 0, 2951, 2949,
		1, 0, 0, 0, 2952, 2956, 3, 152, 76, 0, 2953, 2955, 5, 5, 0, 0, 2954, 2953,
		1, 0, 0, 0, 2955, 2958, 1, 0, 0, 0, 2956, 2954, 1, 0, 0, 0, 2956, 2957,
		1, 0, 0, 0, 2957, 2959, 1, 0, 0, 0, 2958, 2956, 1, 0, 0, 0, 2959, 2963,
		5, 10, 0, 0, 2960, 2962, 5, 5, 0, 0, 2961, 2960, 1, 0, 0, 0, 2962, 2965,
		1, 0, 0, 0, 2963, 2961, 1, 0, 0, 0, 2963, 2964, 1, 0, 0, 0, 2964, 2997,
		1, 0, 0, 0, 2965, 2963, 1, 0, 0, 0, 2966, 2998, 3, 134, 67, 0, 2967, 2969,
		3, 134, 67, 0, 2968, 2967, 1, 0, 0, 0, 2968, 2969, 1, 0, 0, 0, 2969, 2973,
		1, 0, 0, 0, 2970, 2972, 5, 5, 0, 0, 2971, 2970, 1, 0, 0, 0, 2972, 2975,
		1, 0, 0, 0, 2973, 2971, 1, 0, 0, 0, 2973, 2974, 1, 0, 0, 0, 2974, 2977,
		1, 0, 0, 0, 2975, 2973, 1, 0, 0, 0, 2976, 2978, 5, 27, 0, 0, 2977, 2976,
		1, 0, 0, 0, 2977, 2978, 1, 0, 0, 0, 2978, 2982, 1, 0, 0, 0, 2979, 2981,
		5, 5, 0, 0, 2980, 2979, 1, 0, 0, 0, 2981, 2984, 1, 0, 0, 0, 2982, 2980,
		1, 0, 0, 0, 2982, 2983, 1, 0, 0, 0, 2983, 2985, 1, 0, 0, 0, 2984, 2982,
		1, 0, 0, 0, 2985, 2989, 5, 89, 0, 0, 2986, 2988, 5, 5, 0, 0, 2987, 2986,
		1, 0, 0, 0, 2988, 2991, 1, 0, 0, 0, 2989, 2987, 1, 0, 0, 0, 2989, 2990,
		1, 0, 0, 0, 2990, 2994, 1, 0, 0, 0, 2991, 2989, 1, 0, 0, 0, 2992, 2995,
		3, 134, 67, 0, 2993, 2995, 5, 27, 0, 0, 2994, 2992, 1, 0, 0, 0, 2994, 2993,
		1, 0, 0, 0, 2995, 2998, 1, 0, 0, 0, 2996, 2998, 5, 27, 0, 0, 2997, 2966,
		1, 0, 0, 0, 2997, 2968, 1, 0, 0, 0, 2997, 2996, 1, 0, 0, 0, 2998, 251,
		1, 0, 0, 0, 2999, 3033, 5, 9, 0, 0, 3000, 3002, 3, 334, 167, 0, 3001, 3000,
		1, 0, 0, 0, 3002, 3005, 1, 0, 0, 0, 3003, 3001, 1, 0, 0, 0, 3003, 3004,
		1, 0, 0, 0, 3004, 3009, 1, 0, 0, 0, 3005, 3003, 1, 0, 0, 0, 3006, 3008,
		5, 5, 0, 0, 3007, 3006, 1, 0, 0, 0, 3008, 3011, 1, 0, 0, 0, 3009, 3007,
		1, 0, 0, 0, 3009, 3010, 1, 0, 0, 0, 3010, 3012, 1, 0, 0, 0, 3011, 3009,
		1, 0, 0, 0, 3012, 3016, 5, 77, 0, 0, 3013, 3015, 5, 5, 0, 0, 3014, 3013,
		1, 0, 0, 0, 3015, 3018, 1, 0, 0, 0, 3016, 3014, 1, 0, 0, 0, 3016, 3017,
		1, 0, 0, 0, 3017, 3019, 1, 0, 0, 0, 3018, 3016, 1, 0, 0, 0, 3019, 3023,
		3, 66, 33, 0, 3020, 3022, 5, 5, 0, 0, 3021, 3020, 1, 0, 0, 0, 3022, 3025,
		1, 0, 0, 0, 3023, 3021, 1, 0, 0, 0, 3023, 3024, 1, 0, 0, 0, 3024, 3026,
		1, 0, 0, 0, 3025, 3023, 1, 0, 0, 0, 3026, 3030, 5, 28, 0, 0, 3027, 3029,
		5, 5, 0, 0, 3028, 3027, 1, 0, 0, 0, 3029, 3032, 1, 0, 0, 0, 3030, 3028,
		1, 0, 0, 0, 3030, 3031, 1, 0, 0, 0, 3031, 3034, 1, 0, 0, 0, 3032, 3030,
		1, 0, 0, 0, 3033, 3003, 1, 0, 0, 0, 3033, 3034, 1, 0, 0, 0, 3034, 3035,
		1, 0, 0, 0, 3035, 3036, 3, 152, 76, 0, 3036, 3037, 5, 10, 0, 0, 3037, 253,
		1, 0, 0, 0, 3038, 3042, 5, 90, 0, 0, 3039, 3041, 5, 5, 0, 0, 3040, 3039,
		1, 0, 0, 0, 3041, 3044, 1, 0, 0, 0, 3042, 3040, 1, 0, 0, 0, 3042, 3043,
		1, 0, 0, 0, 3043, 3046, 1, 0, 0, 0, 3044, 3042, 1, 0, 0, 0, 3045, 3047,
		3, 252, 126, 0, 3046, 3045, 1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 3051,
		1, 0, 0, 0, 3048, 3050, 5, 5, 0, 0, 3049, 3048, 1, 0, 0, 0, 3050, 3053,
		1, 0, 0, 0, 3051, 3049, 1, 0, 0, 0, 3051, 3052, 1, 0, 0, 0, 3052, 3054,
		1, 0, 0, 0, 3053, 3051, 1, 0, 0, 0, 3054, 3058, 5, 13, 0, 0, 3055, 3057,
		5, 5, 0, 0, 3056, 3055, 1, 0, 0, 0, 3057, 3060, 1, 0, 0, 0, 3058, 3056,
		1, 0, 0, 0, 3058, 3059, 1, 0, 0, 0, 3059, 3070, 1, 0, 0, 0, 3060, 3058,
		1, 0, 0, 0, 3061, 3065, 3, 256, 128, 0, 3062, 3064, 5, 5, 0, 0, 3063, 3062,
		1, 0, 0, 0, 3064, 3067, 1, 0, 0, 0, 3065, 3063, 1, 0, 0, 0, 3065, 3066,
		1, 0, 0, 0, 3066, 3069, 1, 0, 0, 0, 3067, 3065, 1, 0, 0, 0, 3068, 3061,
		1, 0, 0, 0, 3069, 3072, 1, 0, 0, 0, 3070, 3068, 1, 0, 0, 0, 3070, 3071,
		1, 0, 0, 0, 3071, 3076, 1, 0, 0, 0, 3072, 3070, 1, 0, 0, 0, 3073, 3075,
		5, 5, 0, 0, 3074, 3073, 1, 0, 0, 0, 3075, 3078, 1, 0, 0, 0, 3076, 3074,
		1, 0, 0, 0, 3076, 3077, 1, 0, 0, 0, 3077, 3079, 1, 0, 0, 0, 3078, 3076,
		1, 0, 0, 0, 3079, 3080, 5, 14, 0, 0, 3080, 255, 1, 0, 0, 0, 3081, 3098,
		3, 258, 129, 0, 3082, 3084, 5, 5, 0, 0, 3083, 3082, 1, 0, 0, 0, 3084, 3087,
		1, 0, 0, 0, 3085, 3083, 1, 0, 0, 0, 3085, 3086, 1, 0, 0, 0, 3086, 3088,
		1, 0, 0, 0, 3087, 3085, 1, 0, 0, 0, 3088, 3092, 5, 8, 0, 0, 3089, 3091,
		5, 5, 0, 0, 3090, 3089, 1, 0, 0, 0, 3091, 3094, 1, 0, 0, 0, 3092, 3090,
		1, 0, 0, 0, 3092, 3093, 1, 0, 0, 0, 3093, 3095, 1, 0, 0, 0, 3094, 3092,
		1, 0, 0, 0, 3095, 3097, 3, 258, 129, 0, 3096, 3085, 1, 0, 0, 0, 3097, 3100,
		1, 0, 0, 0, 3098, 3096, 1, 0, 0, 0, 3098, 3099, 1, 0, 0, 0, 3099, 3108,
		1, 0, 0, 0, 3100, 3098, 1, 0, 0, 0, 3101, 3103, 5, 5, 0, 0, 3102, 3101,
		1, 0, 0, 0, 3103, 3106, 1, 0, 0, 0, 3104, 3102, 1, 0, 0, 0, 3104, 3105,
		1, 0, 0, 0, 3105, 3107, 1, 0, 0, 0, 3106, 3104, 1, 0, 0, 0, 3107, 3109,
		5, 8, 0, 0, 3108, 3104, 1, 0, 0, 0, 3108, 3109, 1, 0, 0, 0, 3109, 3113,
		1, 0, 0, 0, 3110, 3112, 5, 5, 0, 0, 3111, 3110, 1, 0, 0, 0, 3112, 3115,
		1, 0, 0, 0, 3113, 3111, 1, 0, 0, 0, 3113, 3114, 1, 0, 0, 0, 3114, 3116,
		1, 0, 0, 0, 3115, 3113, 1, 0, 0, 0, 3116, 3120, 5, 34, 0, 0, 3117, 3119,
		5, 5, 0, 0, 3118, 3117, 1, 0, 0, 0, 3119, 3122, 1, 0, 0, 0, 3120, 3118,
		1, 0, 0, 0, 3120, 3121, 1, 0, 0, 0, 3121, 3123, 1, 0, 0, 0, 3122, 3120,
		1, 0, 0, 0, 3123, 3125, 3, 134, 67, 0, 3124, 3126, 3, 148, 74, 0, 3125,
		3124, 1, 0, 0, 0, 3125, 3126, 1, 0, 0, 0, 3126, 3146, 1, 0, 0, 0, 3127,
		3131, 5, 89, 0, 0, 3128, 3130, 5, 5, 0, 0, 3129, 3128, 1, 0, 0, 0, 3130,
		3133, 1, 0, 0, 0, 3131, 3129, 1, 0, 0, 0, 3131, 3132, 1, 0, 0, 0, 3132,
		3134, 1, 0, 0, 0, 3133, 3131, 1, 0, 0, 0, 3134, 3138, 5, 34, 0, 0, 3135,
		3137, 5, 5, 0, 0, 3136, 3135, 1, 0, 0, 0, 3137, 3140, 1, 0, 0, 0, 3138,
		3136, 1, 0, 0, 0, 3138, 3139, 1, 0, 0, 0, 3139, 3141, 1, 0, 0, 0, 3140,
		3138, 1, 0, 0, 0, 3141, 3143, 3, 134, 67, 0, 3142, 3144, 3, 148, 74, 0,
		3143, 3142, 1, 0, 0, 0, 3143, 3144, 1, 0, 0, 0, 3144, 3146, 1, 0, 0, 0,
		3145, 3081, 1, 0, 0, 0, 3145, 3127, 1, 0, 0, 0, 3146, 257, 1, 0, 0, 0,
		3147, 3151, 3, 152, 76, 0, 3148, 3151, 3, 260, 130, 0, 3149, 3151, 3, 262,
		131, 0, 3150, 3147, 1, 0, 0, 0, 3150, 3148, 1, 0, 0, 0, 3150, 3149, 1,
		0, 0, 0, 3151, 259, 1, 0, 0, 0, 3152, 3156, 3, 280, 140, 0, 3153, 3155,
		5, 5, 0, 0, 3154, 3153, 1, 0, 0, 0, 3155, 3158, 1, 0, 0, 0, 3156, 3154,
		1, 0, 0, 0, 3156, 3157, 1, 0, 0, 0, 3157, 3159, 1, 0, 0, 0, 3158, 3156,
		1, 0, 0, 0, 3159, 3160, 3, 152, 76, 0, 3160, 261, 1, 0, 0, 0, 3161, 3165,
		3, 282, 141, 0, 3162, 3164, 5, 5, 0, 0, 3163, 3162, 1, 0, 0, 0, 3164, 3167,
		1, 0, 0, 0, 3165, 3163, 1, 0, 0, 0, 3165, 3166, 1, 0, 0, 0, 3166, 3168,
		1, 0, 0, 0, 3167, 3165, 1, 0, 0, 0, 3168, 3169, 3, 98, 49, 0, 3169, 263,
		1, 0, 0, 0, 3170, 3174, 5, 91, 0, 0, 3171, 3173, 5, 5, 0, 0, 3172, 3171,
		1, 0, 0, 0, 3173, 3176, 1, 0, 0, 0, 3174, 3172, 1, 0, 0, 0, 3174, 3175,
		1, 0, 0, 0, 3175, 3177, 1, 0, 0, 0, 3176, 3174, 1, 0, 0, 0, 3177, 3205,
		3, 136, 68, 0, 3178, 3180, 5, 5, 0, 0, 3179, 3178, 1, 0, 0, 0, 3180, 3183,
		1, 0, 0, 0, 3181, 3179, 1, 0, 0, 0, 3181, 3182, 1, 0, 0, 0, 3182, 3184,
		1, 0, 0, 0, 3183, 3181, 1, 0, 0, 0, 3184, 3186, 3, 266, 133, 0, 3185, 3181,
		1, 0, 0, 0, 3186, 3187, 1, 0, 0, 0, 3187, 3185, 1, 0, 0, 0, 3187, 3188,
		1, 0, 0, 0, 3188, 3196, 1, 0, 0, 0, 3189, 3191, 5, 5, 0, 0, 3190, 3189,
		1, 0, 0, 0, 3191, 3194, 1, 0, 0, 0, 3192, 3190, 1, 0, 0, 0, 3192, 3193,
		1, 0, 0, 0, 3193, 3195, 1, 0, 0, 0, 3194, 3192, 1, 0, 0, 0, 3195, 3197,
		3, 268, 134, 0, 3196, 3192, 1, 0, 0, 0, 3196, 3197, 1, 0, 0, 0, 3197, 3206,
		1, 0, 0, 0, 3198, 3200, 5, 5, 0, 0, 3199, 3198, 1, 0, 0, 0, 3200, 3203,
		1, 0, 0, 0, 3201, 3199, 1, 0, 0, 0, 3201, 3202, 1, 0, 0, 0, 3202, 3204,
		1, 0, 0, 0, 3203, 3201, 1, 0, 0, 0, 3204, 3206, 3, 268, 134, 0, 3205, 3185,
		1, 0, 0, 0, 3205, 3201, 1, 0, 0, 0, 3206, 265, 1, 0, 0, 0, 3207, 3211,
		5, 92, 0, 0, 3208, 3210, 5, 5, 0, 0, 3209, 3208, 1, 0, 0, 0, 3210, 3213,
		1, 0, 0, 0, 3211, 3209, 1, 0, 0, 0, 3211, 3212, 1, 0, 0, 0, 3212, 3214,
		1, 0, 0, 0, 3213, 3211, 1, 0, 0, 0, 3214, 3218, 5, 9, 0, 0, 3215, 3217,
		3, 334, 167, 0, 3216, 3215, 1, 0, 0, 0, 3217, 3220, 1, 0, 0, 0, 3218, 3216,
		1, 0, 0, 0, 3218, 3219, 1, 0, 0, 0, 3219, 3221, 1, 0, 0, 0, 3220, 3218,
		1, 0, 0, 0, 3221, 3222, 3, 344, 172, 0, 3222, 3223, 5, 26, 0, 0, 3223,
		3231, 3, 98, 49, 0, 3224, 3226, 5, 5, 0, 0, 3225, 3224, 1, 0, 0, 0, 3226,
		3229, 1, 0, 0, 0, 3227, 3225, 1, 0, 0, 0, 3227, 3228, 1, 0, 0, 0, 3228,
		3230, 1, 0, 0, 0, 3229, 3227, 1, 0, 0, 0, 3230, 3232, 5, 8, 0, 0, 3231,
		3227, 1, 0, 0, 0, 3231, 3232, 1, 0, 0, 0, 3232, 3233, 1, 0, 0, 0, 3233,
		3237, 5, 10, 0, 0, 3234, 3236, 5, 5, 0, 0, 3235, 3234, 1, 0, 0, 0, 3236,
		3239, 1, 0, 0, 0, 3237, 3235, 1, 0, 0, 0, 3237, 3238, 1, 0, 0, 0, 3238,
		3240, 1, 0, 0, 0, 3239, 3237, 1, 0, 0, 0, 3240, 3241, 3, 136, 68, 0, 3241,
		267, 1, 0, 0, 0, 3242, 3246, 5, 93, 0, 0, 3243, 3245, 5, 5, 0, 0, 3244,
		3243, 1, 0, 0, 0, 3245, 3248, 1, 0, 0, 0, 3246, 3244, 1, 0, 0, 0, 3246,
		3247, 1, 0, 0, 0, 3247, 3249, 1, 0, 0, 0, 3248, 3246, 1, 0, 0, 0, 3249,
		3250, 3, 136, 68, 0, 3250, 269, 1, 0, 0, 0, 3251, 3255, 5, 97, 0, 0, 3252,
		3254, 5, 5, 0, 0, 3253, 3252, 1, 0, 0, 0, 3254, 3257, 1, 0, 0, 0, 3255,
		3253, 1, 0, 0, 0, 3255, 3256, 1, 0, 0, 0, 3256, 3258, 1, 0, 0, 0, 3257,
		3255, 1, 0, 0, 0, 3258, 3268, 3, 152, 76, 0, 3259, 3261, 7, 10, 0, 0, 3260,
		3262, 3, 152, 76, 0, 3261, 3260, 1, 0, 0, 0, 3261, 3262, 1, 0, 0, 0, 3262,
		3268, 1, 0, 0, 0, 3263, 3268, 5, 99, 0, 0, 3264, 3268, 5, 58, 0, 0, 3265,
		3268, 5, 100, 0, 0, 3266, 3268, 5, 59, 0, 0, 3267, 3251, 1, 0, 0, 0, 3267,
		3259, 1, 0, 0, 0, 3267, 3263, 1, 0, 0, 0, 3267, 3264, 1, 0, 0, 0, 3267,
		3265, 1, 0, 0, 0, 3267, 3266, 1, 0, 0, 0, 3268, 271, 1, 0, 0, 0, 3269,
		3271, 3, 122, 61, 0, 3270, 3269, 1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 3271,
		3272, 1, 0, 0, 0, 3272, 3276, 5, 37, 0, 0, 3273, 3275, 5, 5, 0, 0, 3274,
		3273, 1, 0, 0, 0, 3275, 3278, 1, 0, 0, 0, 3276, 3274, 1, 0, 0, 0, 3276,
		3277, 1, 0, 0, 0, 3277, 3281, 1, 0, 0, 0, 3278, 3276, 1, 0, 0, 0, 3279,
		3282, 3, 344, 172, 0, 3280, 3282, 5, 73, 0, 0, 3281, 3279, 1, 0, 0, 0,
		3281, 3280, 1, 0, 0, 0, 3282, 273, 1, 0, 0, 0, 3283, 3284, 7, 11, 0, 0,
		3284, 275, 1, 0, 0, 0, 3285, 3286, 7, 12, 0, 0, 3286, 277, 1, 0, 0, 0,
		3287, 3288, 7, 13, 0, 0, 3288, 279, 1, 0, 0, 0, 3289, 3290, 7, 14, 0, 0,
		3290, 281, 1, 0, 0, 0, 3291, 3292, 7, 15, 0, 0, 3292, 283, 1, 0, 0, 0,
		3293, 3294, 7, 16, 0, 0, 3294, 285, 1, 0, 0, 0, 3295, 3296, 7, 17, 0, 0,
		3296, 287, 1, 0, 0, 0, 3297, 3298, 7, 18, 0, 0, 3298, 289, 1, 0, 0, 0,
		3299, 3305, 5, 20, 0, 0, 3300, 3305, 5, 21, 0, 0, 3301, 3305, 5, 19, 0,
		0, 3302, 3305, 5, 18, 0, 0, 3303, 3305, 3, 294, 147, 0, 3304, 3299, 1,
		0, 0, 0, 3304, 3300, 1, 0, 0, 0, 3304, 3301, 1, 0, 0, 0, 3304, 3302, 1,
		0, 0, 0, 3304, 3303, 1, 0, 0, 0, 3305, 291, 1, 0, 0, 0, 3306, 3311, 5,
		20, 0, 0, 3307, 3311, 5, 21, 0, 0, 3308, 3309, 5, 25, 0, 0, 3309, 3311,
		3, 294, 147, 0, 3310, 3306, 1, 0, 0, 0, 3310, 3307, 1, 0, 0, 0, 3310, 3308,
		1, 0, 0, 0, 3311, 293, 1, 0, 0, 0, 3312, 3313, 7, 19, 0, 0, 3313, 295,
		1, 0, 0, 0, 3314, 3316, 5, 5, 0, 0, 3315, 3314, 1, 0, 0, 0, 3316, 3319,
		1, 0, 0, 0, 3317, 3315, 1, 0, 0, 0, 3317, 3318, 1, 0, 0, 0, 3318, 3320,
		1, 0, 0, 0, 3319, 3317, 1, 0, 0, 0, 3320, 3330, 5, 7, 0, 0, 3321, 3323,
		5, 5, 0, 0, 3322, 3321, 1, 0, 0, 0, 3323, 3326, 1, 0, 0, 0, 3324, 3322,
		1, 0, 0, 0, 3324, 3325, 1, 0, 0, 0, 3325, 3327, 1, 0, 0, 0, 3326, 3324,
		1, 0, 0, 0, 3327, 3330, 3, 298, 149, 0, 3328, 3330, 5, 37, 0, 0, 3329,
		3317, 1, 0, 0, 0, 3329, 3324, 1, 0, 0, 0, 3329, 3328, 1, 0, 0, 0, 3330,
		297, 1, 0, 0, 0, 3331, 3332, 5, 45, 0, 0, 3332, 3333, 5, 7, 0, 0, 3333,
		299, 1, 0, 0, 0, 3334, 3337, 3, 334, 167, 0, 3335, 3337, 3, 304, 152, 0,
		3336, 3334, 1, 0, 0, 0, 3336, 3335, 1, 0, 0, 0, 3337, 3338, 1, 0, 0, 0,
		3338, 3336, 1, 0, 0, 0, 3338, 3339, 1, 0, 0, 0, 3339, 301, 1, 0, 0, 0,
		3340, 3343, 3, 334, 167, 0, 3341, 3343, 3, 328, 164, 0, 3342, 3340, 1,
		0, 0, 0, 3342, 3341, 1, 0, 0, 0, 3343, 3344, 1, 0, 0, 0, 3344, 3342, 1,
		0, 0, 0, 3344, 3345, 1, 0, 0, 0, 3345, 303, 1, 0, 0, 0, 3346, 3355, 3,
		310, 155, 0, 3347, 3355, 3, 312, 156, 0, 3348, 3355, 3, 314, 157, 0, 3349,
		3355, 3, 322, 161, 0, 3350, 3355, 3, 324, 162, 0, 3351, 3355, 3, 326, 163,
		0, 3352, 3355, 3, 328, 164, 0, 3353, 3355, 3, 332, 166, 0, 3354, 3346,
		1, 0, 0, 0, 3354, 3347, 1, 0, 0, 0, 3354, 3348, 1, 0, 0, 0, 3354, 3349,
		1, 0, 0, 0, 3354, 3350, 1, 0, 0, 0, 3354, 3351, 1, 0, 0, 0, 3354, 3352,
		1, 0, 0, 0, 3354, 3353, 1, 0, 0, 0, 3355, 3359, 1, 0, 0, 0, 3356, 3358,
		5, 5, 0, 0, 3357, 3356, 1, 0, 0, 0, 3358, 3361, 1, 0, 0, 0, 3359, 3357,
		1, 0, 0, 0, 3359, 3360, 1, 0, 0, 0, 3360, 305, 1, 0, 0, 0, 3361, 3359,
		1, 0, 0, 0, 3362, 3364, 3, 308, 154, 0, 3363, 3362, 1, 0, 0, 0, 3364, 3365,
		1, 0, 0, 0, 3365, 3363, 1, 0, 0, 0, 3365, 3366, 1, 0, 0, 0, 3366, 307,
		1, 0, 0, 0, 3367, 3376, 3, 334, 167, 0, 3368, 3372, 5, 123, 0, 0, 3369,
		3371, 5, 5, 0, 0, 3370, 3369, 1, 0, 0, 0, 3371, 3374, 1, 0, 0, 0, 3372,
		3370, 1, 0, 0, 0, 3372, 3373, 1, 0, 0, 0, 3373, 3376, 1, 0, 0, 0, 3374,
		3372, 1, 0, 0, 0, 3375, 3367, 1, 0, 0, 0, 3375, 3368, 1, 0, 0, 0, 3376,
		309, 1, 0, 0, 0, 3377, 3378, 7, 20, 0, 0, 3378, 311, 1, 0, 0, 0, 3379,
		3380, 7, 21, 0, 0, 3380, 313, 1, 0, 0, 0, 3381, 3382, 7, 22, 0, 0, 3382,
		315, 1, 0, 0, 0, 3383, 3384, 7, 23, 0, 0, 3384, 317, 1, 0, 0, 0, 3385,
		3387, 3, 320, 160, 0, 3386, 3385, 1, 0, 0, 0, 3387, 3388, 1, 0, 0, 0, 3388,
		3386, 1, 0, 0, 0, 3388, 3389, 1, 0, 0, 0, 3389, 319, 1, 0, 0, 0, 3390,
		3394, 3, 330, 165, 0, 3391, 3393, 5, 5, 0, 0, 3392, 3391, 1, 0, 0, 0, 3393,
		3396, 1, 0, 0, 0, 3394, 3392, 1, 0, 0, 0, 3394, 3395, 1, 0, 0, 0, 3395,
		3406, 1, 0, 0, 0, 3396, 3394, 1, 0, 0, 0, 3397, 3401, 3, 316, 158, 0, 3398,
		3400, 5, 5, 0, 0, 3399, 3398, 1, 0, 0, 0, 3400, 3403, 1, 0, 0, 0, 3401,
		3399, 1, 0, 0, 0, 3401, 3402, 1, 0, 0, 0, 3402, 3406, 1, 0, 0, 0, 3403,
		3401, 1, 0, 0, 0, 3404, 3406, 3, 334, 167, 0, 3405, 3390, 1, 0, 0, 0, 3405,
		3397, 1, 0, 0, 0, 3405, 3404, 1, 0, 0, 0, 3406, 321, 1, 0, 0, 0, 3407,
		3408, 7, 24, 0, 0, 3408, 323, 1, 0, 0, 0, 3409, 3410, 5, 128, 0, 0, 3410,
		325, 1, 0, 0, 0, 3411, 3412, 7, 25, 0, 0, 3412, 327, 1, 0, 0, 0, 3413,
		3414, 7, 26, 0, 0, 3414, 329, 1, 0, 0, 0, 3415, 3416, 5, 133, 0, 0, 3416,
		331, 1, 0, 0, 0, 3417, 3418, 7, 27, 0, 0, 3418, 333, 1, 0, 0, 0, 3419,
		3422, 3, 336, 168, 0, 3420, 3422, 3, 338, 169, 0, 3421, 3419, 1, 0, 0,
		0, 3421, 3420, 1, 0, 0, 0, 3422, 3426, 1, 0, 0, 0, 3423, 3425, 5, 5, 0,
		0, 3424, 3423, 1, 0, 0, 0, 3425, 3428, 1, 0, 0, 0, 3426, 3424, 1, 0, 0,
		0, 3426, 3427, 1, 0, 0, 0, 3427, 335, 1, 0, 0, 0, 3428, 3426, 1, 0, 0,
		0, 3429, 3433, 3, 340, 170, 0, 3430, 3432, 5, 5, 0, 0, 3431, 3430, 1, 0,
		0, 0, 3432, 3435, 1, 0, 0, 0, 3433, 3431, 1, 0, 0, 0, 3433, 3434, 1, 0,
		0, 0, 3434, 3439, 1, 0, 0, 0, 3435, 3433, 1, 0, 0, 0, 3436, 3439, 5, 40,
		0, 0, 3437, 3439, 5, 42, 0, 0, 3438, 3429, 1, 0, 0, 0, 3438, 3436, 1, 0,
		0, 0, 3438, 3437, 1, 0, 0, 0, 3439, 3440, 1, 0, 0, 0, 3440, 3441, 3, 342,
		171, 0, 3441, 337, 1, 0, 0, 0, 3442, 3446, 3, 340, 170, 0, 3443, 3445,
		5, 5, 0, 0, 3444, 3443, 1, 0, 0, 0, 3445, 3448, 1, 0, 0, 0, 3446, 3444,
		1, 0, 0, 0, 3446, 3447, 1, 0, 0, 0, 3447, 3452, 1, 0, 0, 0, 3448, 3446,
		1, 0, 0, 0, 3449, 3452, 5, 40, 0, 0, 3450, 3452, 5, 42, 0, 0, 3451, 3442,
		1, 0, 0, 0, 3451, 3449, 1, 0, 0, 0, 3451, 3450, 1, 0, 0, 0, 3452, 3453,
		1, 0, 0, 0, 3453, 3455, 5, 11, 0, 0, 3454, 3456, 3, 342, 171, 0, 3455,
		3454, 1, 0, 0, 0, 3456, 3457, 1, 0, 0, 0, 3457, 3455, 1, 0, 0, 0, 3457,
		3458, 1, 0, 0, 0, 3458, 3459, 1, 0, 0, 0, 3459, 3460, 5, 12, 0, 0, 3460,
		339, 1, 0, 0, 0, 3461, 3462, 7, 0, 0, 0, 3462, 3466, 7, 28, 0, 0, 3463,
		3465, 5, 5, 0, 0, 3464, 3463, 1, 0, 0, 0, 3465, 3468, 1, 0, 0, 0, 3466,
		3464, 1, 0, 0, 0, 3466, 3467, 1, 0, 0, 0, 3467, 3469, 1, 0, 0, 0, 3468,
		3466, 1, 0, 0, 0, 3469, 3470, 5, 26, 0, 0, 3470, 341, 1, 0, 0, 0, 3471,
		3474, 3, 36, 18, 0, 3472, 3474, 3, 106, 53, 0, 3473, 3471, 1, 0, 0, 0,
		3473, 3472, 1, 0, 0, 0, 3474, 343, 1, 0, 0, 0, 3475, 3476, 7, 29, 0, 0,
		3476, 345, 1, 0, 0, 0, 3477, 3488, 3, 344, 172, 0, 3478, 3480, 5, 5, 0,
		0, 3479, 3478, 1, 0, 0, 0, 3480, 3483, 1, 0, 0, 0, 3481, 3479, 1, 0, 0,
		0, 3481, 3482, 1, 0, 0, 0, 3482, 3484, 1, 0, 0, 0, 3483, 3481, 1, 0, 0,
		0, 3484, 3485, 5, 7, 0, 0, 3485, 3487, 3, 344, 172, 0, 3486, 3481, 1, 0,
		0, 0, 3487, 3490, 1, 0, 0, 0, 3488, 3486, 1, 0, 0, 0, 3488, 3489, 1, 0,
		0, 0, 3489, 347, 1, 0, 0, 0, 3490, 3488, 1, 0, 0, 0, 536, 349, 354, 360,
		368, 374, 379, 385, 395, 404, 411, 418, 425, 430, 435, 441, 443, 448, 456,
		459, 466, 469, 475, 482, 486, 491, 498, 508, 511, 518, 521, 524, 529, 536,
		540, 545, 549, 554, 561, 565, 570, 574, 579, 586, 590, 593, 599, 602, 610,
		617, 626, 633, 640, 646, 652, 656, 658, 663, 669, 672, 677, 685, 692, 699,
		703, 709, 716, 722, 733, 737, 743, 751, 757, 764, 769, 776, 785, 792, 799,
		805, 811, 815, 820, 826, 831, 838, 845, 849, 855, 862, 869, 875, 881, 888,
		895, 902, 906, 913, 919, 925, 931, 938, 942, 947, 954, 958, 963, 967, 973,
		980, 987, 993, 999, 1003, 1005, 1010, 1016, 1022, 1029, 1033, 1036, 1042,
		1046, 1051, 1058, 1063, 1068, 1075, 1082, 1089, 1093, 1098, 1102, 1107,
		1111, 1118, 1122, 1127, 1133, 1140, 1147, 1151, 1157, 1164, 1171, 1177,
		1183, 1187, 1192, 1198, 1204, 1208, 1213, 1220, 1225, 1230, 1235, 1240,
		1244, 1249, 1256, 1261, 1263, 1268, 1271, 1276, 1280, 1285, 1289, 1292,
		1295, 1300, 1304, 1307, 1309, 1315, 1321, 1327, 1334, 1341, 1348, 1352,
		1357, 1361, 1364, 1370, 1377, 1384, 1388, 1393, 1400, 1407, 1411, 1416,
		1421, 1427, 1434, 1441, 1447, 1453, 1457, 1459, 1464, 1470, 1476, 1483,
		1487, 1493, 1500, 1504, 1510, 1517, 1523, 1529, 1536, 1543, 1547, 1552,
		1556, 1559, 1565, 1572, 1579, 1583, 1588, 1592, 1598, 1607, 1611, 1616,
		1623, 1627, 1632, 1641, 1648, 1654, 1660, 1664, 1670, 1673, 1679, 1683,
		1688, 1692, 1695, 1702, 1706, 1710, 1715, 1721, 1729, 1736, 1742, 1749,
		1753, 1756, 1760, 1765, 1771, 1775, 1781, 1788, 1791, 1797, 1804, 1813,
		1818, 1823, 1830, 1835, 1839, 1845, 1849, 1854, 1863, 1870, 1876, 1881,
		1887, 1892, 1897, 1903, 1907, 1912, 1919, 1923, 1927, 1935, 1938, 1941,
		1945, 1947, 1954, 1961, 1966, 1972, 1979, 1987, 1993, 2000, 2005, 2013,
		2017, 2023, 2032, 2037, 2043, 2047, 2052, 2059, 2072, 2077, 2086, 2092,
		2100, 2107, 2113, 2120, 2127, 2133, 2141, 2148, 2156, 2163, 2170, 2178,
		2187, 2192, 2194, 2201, 2208, 2215, 2226, 2233, 2241, 2247, 2255, 2262,
		2270, 2277, 2284, 2291, 2298, 2304, 2315, 2318, 2324, 2332, 2339, 2345,
		2352, 2359, 2365, 2372, 2380, 2386, 2393, 2400, 2406, 2412, 2416, 2421,
		2430, 2436, 2439, 2442, 2446, 2451, 2455, 2460, 2469, 2476, 2483, 2489,
		2495, 2499, 2504, 2513, 2520, 2527, 2533, 2539, 2543, 2548, 2551, 2556,
		2561, 2568, 2575, 2578, 2581, 2586, 2605, 2611, 2618, 2627, 2634, 2641,
		2647, 2653, 2657, 2662, 2665, 2673, 2678, 2680, 2689, 2691, 2702, 2709,
		2720, 2727, 2736, 2740, 2745, 2752, 2755, 2761, 2770, 2777, 2783, 2789,
		2793, 2800, 2807, 2811, 2813, 2819, 2826, 2831, 2836, 2843, 2850, 2854,
		2859, 2863, 2868, 2872, 2876, 2882, 2889, 2896, 2899, 2904, 2908, 2917,
		2924, 2929, 2933, 2936, 2942, 2949, 2956, 2963, 2968, 2973, 2977, 2982,
		2989, 2994, 2997, 3003, 3009, 3016, 3023, 3030, 3033, 3042, 3046, 3051,
		3058, 3065, 3070, 3076, 3085, 3092, 3098, 3104, 3108, 3113, 3120, 3125,
		3131, 3138, 3143, 3145, 3150, 3156, 3165, 3174, 3181, 3187, 3192, 3196,
		3201, 3205, 3211, 3218, 3227, 3231, 3237, 3246, 3255, 3261, 3267, 3270,
		3276, 3281, 3304, 3310, 3317, 3324, 3329, 3336, 3338, 3342, 3344, 3354,
		3359, 3365, 3372, 3375, 3388, 3394, 3401, 3405, 3421, 3426, 3433, 3438,
		3446, 3451, 3457, 3466, 3473, 3481, 3488,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// KotlinParserInit initializes any static state used to implement KotlinParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewKotlinParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func KotlinParserInit() {
	staticData := &kotlinparserParserStaticData
	staticData.once.Do(kotlinparserParserInit)
}

// NewKotlinParser produces a new parser instance for the optional input antlr.TokenStream.
func NewKotlinParser(input antlr.TokenStream) *KotlinParser {
	KotlinParserInit()

	staticData := &kotlinparserParserStaticData

	predictionContextCache := antlr.NewPredictionContextCache()
	deserializer := antlr.NewATNDeserializer(nil)
	atn := deserializer.Deserialize(staticData.serializedATN)
	decisionToDFA := make([]*antlr.DFA, len(atn.DecisionToState))
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}

	this := new(KotlinParser)
	this.BaseParser = antlr.NewBaseParser(input)
	this.Interpreter = antlr.NewParserATNSimulator(this, atn, decisionToDFA, predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "KotlinParser.g4"

	return this
}

// KotlinParser tokens.
const (
	KotlinParserEOF                   = antlr.TokenEOF
	KotlinParserShebangLine           = 1
	KotlinParserDelimitedComment      = 2
	KotlinParserLineComment           = 3
	KotlinParserWS                    = 4
	KotlinParserNL                    = 5
	KotlinParserRESERVED              = 6
	KotlinParserDOT                   = 7
	KotlinParserCOMMA                 = 8
	KotlinParserLPAREN                = 9
	KotlinParserRPAREN                = 10
	KotlinParserLSQUARE               = 11
	KotlinParserRSQUARE               = 12
	KotlinParserLCURL                 = 13
	KotlinParserRCURL                 = 14
	KotlinParserMULT                  = 15
	KotlinParserMOD                   = 16
	KotlinParserDIV                   = 17
	KotlinParserADD                   = 18
	KotlinParserSUB                   = 19
	KotlinParserINCR                  = 20
	KotlinParserDECR                  = 21
	KotlinParserCONJ                  = 22
	KotlinParserDISJ                  = 23
	KotlinParserEXCL_WS               = 24
	KotlinParserEXCL_NO_WS            = 25
	KotlinParserCOLON                 = 26
	KotlinParserSEMICOLON             = 27
	KotlinParserASSIGNMENT            = 28
	KotlinParserADD_ASSIGNMENT        = 29
	KotlinParserSUB_ASSIGNMENT        = 30
	KotlinParserMULT_ASSIGNMENT       = 31
	KotlinParserDIV_ASSIGNMENT        = 32
	KotlinParserMOD_ASSIGNMENT        = 33
	KotlinParserARROW                 = 34
	KotlinParserDOUBLE_ARROW          = 35
	KotlinParserRANGE                 = 36
	KotlinParserCOLONCOLON            = 37
	KotlinParserDOUBLE_SEMICOLON      = 38
	KotlinParserHASH                  = 39
	KotlinParserAT_NO_WS              = 40
	KotlinParserAT_POST_WS            = 41
	KotlinParserAT_PRE_WS             = 42
	KotlinParserAT_BOTH_WS            = 43
	KotlinParserQUEST_WS              = 44
	KotlinParserQUEST_NO_WS           = 45
	KotlinParserLANGLE                = 46
	KotlinParserRANGLE                = 47
	KotlinParserLE                    = 48
	KotlinParserGE                    = 49
	KotlinParserEXCL_EQ               = 50
	KotlinParserEXCL_EQEQ             = 51
	KotlinParserAS_SAFE               = 52
	KotlinParserEQEQ                  = 53
	KotlinParserEQEQEQ                = 54
	KotlinParserSINGLE_QUOTE          = 55
	KotlinParserAMP                   = 56
	KotlinParserRETURN_AT             = 57
	KotlinParserCONTINUE_AT           = 58
	KotlinParserBREAK_AT              = 59
	KotlinParserTHIS_AT               = 60
	KotlinParserSUPER_AT              = 61
	KotlinParserFILE                  = 62
	KotlinParserFIELD                 = 63
	KotlinParserPROPERTY              = 64
	KotlinParserGET                   = 65
	KotlinParserSET                   = 66
	KotlinParserRECEIVER              = 67
	KotlinParserPARAM                 = 68
	KotlinParserSETPARAM              = 69
	KotlinParserDELEGATE              = 70
	KotlinParserPACKAGE               = 71
	KotlinParserIMPORT                = 72
	KotlinParserCLASS                 = 73
	KotlinParserINTERFACE             = 74
	KotlinParserFUN                   = 75
	KotlinParserOBJECT                = 76
	KotlinParserVAL                   = 77
	KotlinParserVAR                   = 78
	KotlinParserTYPE_ALIAS            = 79
	KotlinParserCONSTRUCTOR           = 80
	KotlinParserBY                    = 81
	KotlinParserCOMPANION             = 82
	KotlinParserINIT                  = 83
	KotlinParserTHIS                  = 84
	KotlinParserSUPER                 = 85
	KotlinParserTYPEOF                = 86
	KotlinParserWHERE                 = 87
	KotlinParserIF                    = 88
	KotlinParserELSE                  = 89
	KotlinParserWHEN                  = 90
	KotlinParserTRY                   = 91
	KotlinParserCATCH                 = 92
	KotlinParserFINALLY               = 93
	KotlinParserFOR                   = 94
	KotlinParserDO                    = 95
	KotlinParserWHILE                 = 96
	KotlinParserTHROW                 = 97
	KotlinParserRETURN                = 98
	KotlinParserCONTINUE              = 99
	KotlinParserBREAK                 = 100
	KotlinParserAS                    = 101
	KotlinParserIS                    = 102
	KotlinParserIN                    = 103
	KotlinParserNOT_IS                = 104
	KotlinParserNOT_IN                = 105
	KotlinParserOUT                   = 106
	KotlinParserDYNAMIC               = 107
	KotlinParserPUBLIC                = 108
	KotlinParserPRIVATE               = 109
	KotlinParserPROTECTED             = 110
	KotlinParserINTERNAL              = 111
	KotlinParserENUM                  = 112
	KotlinParserSEALED                = 113
	KotlinParserANNOTATION            = 114
	KotlinParserDATA                  = 115
	KotlinParserINNER                 = 116
	KotlinParserVALUE                 = 117
	KotlinParserTAILREC               = 118
	KotlinParserOPERATOR              = 119
	KotlinParserINLINE                = 120
	KotlinParserINFIX                 = 121
	KotlinParserEXTERNAL              = 122
	KotlinParserSUSPEND               = 123
	KotlinParserOVERRIDE              = 124
	KotlinParserABSTRACT              = 125
	KotlinParserFINAL                 = 126
	KotlinParserOPEN                  = 127
	KotlinParserCONST                 = 128
	KotlinParserLATEINIT              = 129
	KotlinParserVARARG                = 130
	KotlinParserNOINLINE              = 131
	KotlinParserCROSSINLINE           = 132
	KotlinParserREIFIED               = 133
	KotlinParserEXPECT                = 134
	KotlinParserACTUAL                = 135
	KotlinParserRealLiteral           = 136
	KotlinParserFloatLiteral          = 137
	KotlinParserDoubleLiteral         = 138
	KotlinParserIntegerLiteral        = 139
	KotlinParserHexLiteral            = 140
	KotlinParserBinLiteral            = 141
	KotlinParserUnsignedLiteral       = 142
	KotlinParserLongLiteral           = 143
	KotlinParserBooleanLiteral        = 144
	KotlinParserNullLiteral           = 145
	KotlinParserCharacterLiteral      = 146
	KotlinParserIdentifier            = 147
	KotlinParserIdentifierOrSoftKey   = 148
	KotlinParserFieldIdentifier       = 149
	KotlinParserQUOTE_OPEN            = 150
	KotlinParserTRIPLE_QUOTE_OPEN     = 151
	KotlinParserUNICODE_CLASS_LL      = 152
	KotlinParserUNICODE_CLASS_LM      = 153
	KotlinParserUNICODE_CLASS_LO      = 154
	KotlinParserUNICODE_CLASS_LT      = 155
	KotlinParserUNICODE_CLASS_LU      = 156
	KotlinParserUNICODE_CLASS_ND      = 157
	KotlinParserUNICODE_CLASS_NL      = 158
	KotlinParserQUOTE_CLOSE           = 159
	KotlinParserLineStrRef            = 160
	KotlinParserLineStrText           = 161
	KotlinParserLineStrEscapedChar    = 162
	KotlinParserLineStrExprStart      = 163
	KotlinParserTRIPLE_QUOTE_CLOSE    = 164
	KotlinParserMultiLineStringQuote  = 165
	KotlinParserMultiLineStrRef       = 166
	KotlinParserMultiLineStrText      = 167
	KotlinParserMultiLineStrExprStart = 168
	KotlinParserInside_Comment        = 169
	KotlinParserInside_WS             = 170
	KotlinParserInside_NL             = 171
	KotlinParserErrorCharacter        = 172
)

// KotlinParser rules.
const (
	KotlinParserRULE_kotlinFile                                = 0
	KotlinParserRULE_script                                    = 1
	KotlinParserRULE_shebangLine                               = 2
	KotlinParserRULE_fileAnnotation                            = 3
	KotlinParserRULE_packageHeader                             = 4
	KotlinParserRULE_importList                                = 5
	KotlinParserRULE_importHeader                              = 6
	KotlinParserRULE_importAlias                               = 7
	KotlinParserRULE_topLevelObject                            = 8
	KotlinParserRULE_typeAlias                                 = 9
	KotlinParserRULE_declaration                               = 10
	KotlinParserRULE_classDeclaration                          = 11
	KotlinParserRULE_primaryConstructor                        = 12
	KotlinParserRULE_classBody                                 = 13
	KotlinParserRULE_classParameters                           = 14
	KotlinParserRULE_classParameter                            = 15
	KotlinParserRULE_delegationSpecifiers                      = 16
	KotlinParserRULE_delegationSpecifier                       = 17
	KotlinParserRULE_constructorInvocation                     = 18
	KotlinParserRULE_annotatedDelegationSpecifier              = 19
	KotlinParserRULE_explicitDelegation                        = 20
	KotlinParserRULE_typeParameters                            = 21
	KotlinParserRULE_typeParameter                             = 22
	KotlinParserRULE_typeConstraints                           = 23
	KotlinParserRULE_typeConstraint                            = 24
	KotlinParserRULE_classMemberDeclarations                   = 25
	KotlinParserRULE_classMemberDeclaration                    = 26
	KotlinParserRULE_anonymousInitializer                      = 27
	KotlinParserRULE_companionObject                           = 28
	KotlinParserRULE_functionValueParameters                   = 29
	KotlinParserRULE_functionValueParameter                    = 30
	KotlinParserRULE_functionDeclaration                       = 31
	KotlinParserRULE_functionBody                              = 32
	KotlinParserRULE_variableDeclaration                       = 33
	KotlinParserRULE_multiVariableDeclaration                  = 34
	KotlinParserRULE_propertyDeclaration                       = 35
	KotlinParserRULE_propertyDelegate                          = 36
	KotlinParserRULE_getter                                    = 37
	KotlinParserRULE_setter                                    = 38
	KotlinParserRULE_parametersWithOptionalType                = 39
	KotlinParserRULE_functionValueParameterWithOptionalType    = 40
	KotlinParserRULE_parameterWithOptionalType                 = 41
	KotlinParserRULE_parameter                                 = 42
	KotlinParserRULE_objectDeclaration                         = 43
	KotlinParserRULE_secondaryConstructor                      = 44
	KotlinParserRULE_constructorDelegationCall                 = 45
	KotlinParserRULE_enumClassBody                             = 46
	KotlinParserRULE_enumEntries                               = 47
	KotlinParserRULE_enumEntry                                 = 48
	KotlinParserRULE_type                                      = 49
	KotlinParserRULE_typeReference                             = 50
	KotlinParserRULE_nullableType                              = 51
	KotlinParserRULE_quest                                     = 52
	KotlinParserRULE_userType                                  = 53
	KotlinParserRULE_simpleUserType                            = 54
	KotlinParserRULE_typeProjection                            = 55
	KotlinParserRULE_typeProjectionModifiers                   = 56
	KotlinParserRULE_typeProjectionModifier                    = 57
	KotlinParserRULE_functionType                              = 58
	KotlinParserRULE_functionTypeParameters                    = 59
	KotlinParserRULE_parenthesizedType                         = 60
	KotlinParserRULE_receiverType                              = 61
	KotlinParserRULE_parenthesizedUserType                     = 62
	KotlinParserRULE_definitelyNonNullableType                 = 63
	KotlinParserRULE_statements                                = 64
	KotlinParserRULE_statement                                 = 65
	KotlinParserRULE_label                                     = 66
	KotlinParserRULE_controlStructureBody                      = 67
	KotlinParserRULE_block                                     = 68
	KotlinParserRULE_loopStatement                             = 69
	KotlinParserRULE_forStatement                              = 70
	KotlinParserRULE_whileStatement                            = 71
	KotlinParserRULE_doWhileStatement                          = 72
	KotlinParserRULE_assignment                                = 73
	KotlinParserRULE_semi                                      = 74
	KotlinParserRULE_semis                                     = 75
	KotlinParserRULE_expression                                = 76
	KotlinParserRULE_disjunction                               = 77
	KotlinParserRULE_conjunction                               = 78
	KotlinParserRULE_equality                                  = 79
	KotlinParserRULE_comparison                                = 80
	KotlinParserRULE_genericCallLikeComparison                 = 81
	KotlinParserRULE_infixOperation                            = 82
	KotlinParserRULE_elvisExpression                           = 83
	KotlinParserRULE_elvis                                     = 84
	KotlinParserRULE_infixFunctionCall                         = 85
	KotlinParserRULE_rangeExpression                           = 86
	KotlinParserRULE_additiveExpression                        = 87
	KotlinParserRULE_multiplicativeExpression                  = 88
	KotlinParserRULE_asExpression                              = 89
	KotlinParserRULE_prefixUnaryExpression                     = 90
	KotlinParserRULE_unaryPrefix                               = 91
	KotlinParserRULE_postfixUnaryExpression                    = 92
	KotlinParserRULE_postfixUnarySuffix                        = 93
	KotlinParserRULE_directlyAssignableExpression              = 94
	KotlinParserRULE_parenthesizedDirectlyAssignableExpression = 95
	KotlinParserRULE_assignableExpression                      = 96
	KotlinParserRULE_parenthesizedAssignableExpression         = 97
	KotlinParserRULE_assignableSuffix                          = 98
	KotlinParserRULE_indexingSuffix                            = 99
	KotlinParserRULE_navigationSuffix                          = 100
	KotlinParserRULE_callSuffix                                = 101
	KotlinParserRULE_annotatedLambda                           = 102
	KotlinParserRULE_typeArguments                             = 103
	KotlinParserRULE_valueArguments                            = 104
	KotlinParserRULE_valueArgument                             = 105
	KotlinParserRULE_primaryExpression                         = 106
	KotlinParserRULE_parenthesizedExpression                   = 107
	KotlinParserRULE_collectionLiteral                         = 108
	KotlinParserRULE_literalConstant                           = 109
	KotlinParserRULE_stringLiteral                             = 110
	KotlinParserRULE_lineStringLiteral                         = 111
	KotlinParserRULE_multiLineStringLiteral                    = 112
	KotlinParserRULE_lineStringContent                         = 113
	KotlinParserRULE_lineStringExpression                      = 114
	KotlinParserRULE_multiLineStringContent                    = 115
	KotlinParserRULE_multiLineStringExpression                 = 116
	KotlinParserRULE_lambdaLiteral                             = 117
	KotlinParserRULE_lambdaParameters                          = 118
	KotlinParserRULE_lambdaParameter                           = 119
	KotlinParserRULE_anonymousFunction                         = 120
	KotlinParserRULE_functionLiteral                           = 121
	KotlinParserRULE_objectLiteral                             = 122
	KotlinParserRULE_thisExpression                            = 123
	KotlinParserRULE_superExpression                           = 124
	KotlinParserRULE_ifExpression                              = 125
	KotlinParserRULE_whenSubject                               = 126
	KotlinParserRULE_whenExpression                            = 127
	KotlinParserRULE_whenEntry                                 = 128
	KotlinParserRULE_whenCondition                             = 129
	KotlinParserRULE_rangeTest                                 = 130
	KotlinParserRULE_typeTest                                  = 131
	KotlinParserRULE_tryExpression                             = 132
	KotlinParserRULE_catchBlock                                = 133
	KotlinParserRULE_finallyBlock                              = 134
	KotlinParserRULE_jumpExpression                            = 135
	KotlinParserRULE_callableReference                         = 136
	KotlinParserRULE_assignmentAndOperator                     = 137
	KotlinParserRULE_equalityOperator                          = 138
	KotlinParserRULE_comparisonOperator                        = 139
	KotlinParserRULE_inOperator                                = 140
	KotlinParserRULE_isOperator                                = 141
	KotlinParserRULE_additiveOperator                          = 142
	KotlinParserRULE_multiplicativeOperator                    = 143
	KotlinParserRULE_asOperator                                = 144
	KotlinParserRULE_prefixUnaryOperator                       = 145
	KotlinParserRULE_postfixUnaryOperator                      = 146
	KotlinParserRULE_excl                                      = 147
	KotlinParserRULE_memberAccessOperator                      = 148
	KotlinParserRULE_safeNav                                   = 149
	KotlinParserRULE_modifiers                                 = 150
	KotlinParserRULE_parameterModifiers                        = 151
	KotlinParserRULE_modifier                                  = 152
	KotlinParserRULE_typeModifiers                             = 153
	KotlinParserRULE_typeModifier                              = 154
	KotlinParserRULE_classModifier                             = 155
	KotlinParserRULE_memberModifier                            = 156
	KotlinParserRULE_visibilityModifier                        = 157
	KotlinParserRULE_varianceModifier                          = 158
	KotlinParserRULE_typeParameterModifiers                    = 159
	KotlinParserRULE_typeParameterModifier                     = 160
	KotlinParserRULE_functionModifier                          = 161
	KotlinParserRULE_propertyModifier                          = 162
	KotlinParserRULE_inheritanceModifier                       = 163
	KotlinParserRULE_parameterModifier                         = 164
	KotlinParserRULE_reificationModifier                       = 165
	KotlinParserRULE_platformModifier                          = 166
	KotlinParserRULE_annotation                                = 167
	KotlinParserRULE_singleAnnotation                          = 168
	KotlinParserRULE_multiAnnotation                           = 169
	KotlinParserRULE_annotationUseSiteTarget                   = 170
	KotlinParserRULE_unescapedAnnotation                       = 171
	KotlinParserRULE_simpleIdentifier                          = 172
	KotlinParserRULE_identifier                                = 173
)

// IKotlinFileContext is an interface to support dynamic dispatch.
type IKotlinFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageHeader() IPackageHeaderContext
	ImportList() IImportListContext
	EOF() antlr.TerminalNode
	ShebangLine() IShebangLineContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFileAnnotation() []IFileAnnotationContext
	FileAnnotation(i int) IFileAnnotationContext
	AllTopLevelObject() []ITopLevelObjectContext
	TopLevelObject(i int) ITopLevelObjectContext

	// IsKotlinFileContext differentiates from other interfaces.
	IsKotlinFileContext()
}

type KotlinFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKotlinFileContext() *KotlinFileContext {
	var p = new(KotlinFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_kotlinFile
	return p
}

func (*KotlinFileContext) IsKotlinFileContext() {}

func NewKotlinFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KotlinFileContext {
	var p = new(KotlinFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_kotlinFile

	return p
}

func (s *KotlinFileContext) GetParser() antlr.Parser { return s.parser }

func (s *KotlinFileContext) PackageHeader() IPackageHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageHeaderContext)
}

func (s *KotlinFileContext) ImportList() IImportListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportListContext)
}

func (s *KotlinFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *KotlinFileContext) ShebangLine() IShebangLineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShebangLineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShebangLineContext)
}

func (s *KotlinFileContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *KotlinFileContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *KotlinFileContext) AllFileAnnotation() []IFileAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IFileAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileAnnotationContext); ok {
			tst[i] = t.(IFileAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *KotlinFileContext) FileAnnotation(i int) IFileAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationContext)
}

func (s *KotlinFileContext) AllTopLevelObject() []ITopLevelObjectContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopLevelObjectContext); ok {
			len++
		}
	}

	tst := make([]ITopLevelObjectContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopLevelObjectContext); ok {
			tst[i] = t.(ITopLevelObjectContext)
			i++
		}
	}

	return tst
}

func (s *KotlinFileContext) TopLevelObject(i int) ITopLevelObjectContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopLevelObjectContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopLevelObjectContext)
}

func (s *KotlinFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KotlinFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KotlinFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterKotlinFile(s)
	}
}

func (s *KotlinFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitKotlinFile(s)
	}
}

func (p *KotlinParser) KotlinFile() (localctx IKotlinFileContext) {
	this := p
	_ = this

	localctx = NewKotlinFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KotlinParserRULE_kotlinFile)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserShebangLine {
		{
			p.SetState(348)
			p.ShebangLine()
		}

	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(351)
			p.Match(KotlinParserNL)
		}

		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(357)
				p.FileAnnotation()
			}

		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}
	{
		p.SetState(363)
		p.PackageHeader()
	}
	{
		p.SetState(364)
		p.ImportList()
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&8070450497888190591) != 0) {
		{
			p.SetState(365)
			p.TopLevelObject()
		}

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(371)
		p.Match(KotlinParserEOF)
	}

	return localctx
}

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageHeader() IPackageHeaderContext
	ImportList() IImportListContext
	EOF() antlr.TerminalNode
	ShebangLine() IShebangLineContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFileAnnotation() []IFileAnnotationContext
	FileAnnotation(i int) IFileAnnotationContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSemi() []ISemiContext
	Semi(i int) ISemiContext

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_script
	return p
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) PackageHeader() IPackageHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageHeaderContext)
}

func (s *ScriptContext) ImportList() IImportListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportListContext)
}

func (s *ScriptContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *ScriptContext) ShebangLine() IShebangLineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShebangLineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShebangLineContext)
}

func (s *ScriptContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ScriptContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ScriptContext) AllFileAnnotation() []IFileAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IFileAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileAnnotationContext); ok {
			tst[i] = t.(IFileAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ScriptContext) FileAnnotation(i int) IFileAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationContext)
}

func (s *ScriptContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *ScriptContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ScriptContext) AllSemi() []ISemiContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISemiContext); ok {
			len++
		}
	}

	tst := make([]ISemiContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISemiContext); ok {
			tst[i] = t.(ISemiContext)
			i++
		}
	}

	return tst
}

func (s *ScriptContext) Semi(i int) ISemiContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitScript(s)
	}
}

func (p *KotlinParser) Script() (localctx IScriptContext) {
	this := p
	_ = this

	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KotlinParserRULE_script)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserShebangLine {
		{
			p.SetState(373)
			p.ShebangLine()
		}

	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(376)
			p.Match(KotlinParserNL)
		}

		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(382)
				p.FileAnnotation()
			}

		}
		p.SetState(387)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}
	{
		p.SetState(388)
		p.PackageHeader()
	}
	{
		p.SetState(389)
		p.ImportList()
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-144109553024488960) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4260645306497) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&13629951) != 0) {
		{
			p.SetState(390)
			p.Statement()
		}
		{
			p.SetState(391)
			p.Semi()
		}

		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(398)
		p.Match(KotlinParserEOF)
	}

	return localctx
}

// IShebangLineContext is an interface to support dynamic dispatch.
type IShebangLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ShebangLine() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsShebangLineContext differentiates from other interfaces.
	IsShebangLineContext()
}

type ShebangLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShebangLineContext() *ShebangLineContext {
	var p = new(ShebangLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_shebangLine
	return p
}

func (*ShebangLineContext) IsShebangLineContext() {}

func NewShebangLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShebangLineContext {
	var p = new(ShebangLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_shebangLine

	return p
}

func (s *ShebangLineContext) GetParser() antlr.Parser { return s.parser }

func (s *ShebangLineContext) ShebangLine() antlr.TerminalNode {
	return s.GetToken(KotlinParserShebangLine, 0)
}

func (s *ShebangLineContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ShebangLineContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ShebangLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShebangLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShebangLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterShebangLine(s)
	}
}

func (s *ShebangLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitShebangLine(s)
	}
}

func (p *KotlinParser) ShebangLine() (localctx IShebangLineContext) {
	this := p
	_ = this

	localctx = NewShebangLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KotlinParserRULE_shebangLine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.Match(KotlinParserShebangLine)
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(401)
				p.Match(KotlinParserNL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IFileAnnotationContext is an interface to support dynamic dispatch.
type IFileAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	LSQUARE() antlr.TerminalNode
	RSQUARE() antlr.TerminalNode
	AllUnescapedAnnotation() []IUnescapedAnnotationContext
	UnescapedAnnotation(i int) IUnescapedAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFileAnnotationContext differentiates from other interfaces.
	IsFileAnnotationContext()
}

type FileAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileAnnotationContext() *FileAnnotationContext {
	var p = new(FileAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_fileAnnotation
	return p
}

func (*FileAnnotationContext) IsFileAnnotationContext() {}

func NewFileAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileAnnotationContext {
	var p = new(FileAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_fileAnnotation

	return p
}

func (s *FileAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *FileAnnotationContext) FILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, 0)
}

func (s *FileAnnotationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *FileAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *FileAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *FileAnnotationContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *FileAnnotationContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *FileAnnotationContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IUnescapedAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnescapedAnnotationContext); ok {
			tst[i] = t.(IUnescapedAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *FileAnnotationContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *FileAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FileAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FileAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFileAnnotation(s)
	}
}

func (s *FileAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFileAnnotation(s)
	}
}

func (p *KotlinParser) FileAnnotation() (localctx IFileAnnotationContext) {
	this := p
	_ = this

	localctx = NewFileAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KotlinParserRULE_fileAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(407)
		p.Match(KotlinParserFILE)
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(408)
			p.Match(KotlinParserNL)
		}

		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(414)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(415)
			p.Match(KotlinParserNL)
		}

		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLSQUARE:
		{
			p.SetState(421)
			p.Match(KotlinParserLSQUARE)
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&-17588927330817) != 0) || ((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&2098175) != 0) {
			{
				p.SetState(422)
				p.UnescapedAnnotation()
			}

			p.SetState(425)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(427)
			p.Match(KotlinParserRSQUARE)
		}

	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(429)
			p.UnescapedAnnotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(432)
			p.Match(KotlinParserNL)
		}

		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPackageHeaderContext is an interface to support dynamic dispatch.
type IPackageHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKAGE() antlr.TerminalNode
	Identifier() IIdentifierContext
	Semi() ISemiContext

	// IsPackageHeaderContext differentiates from other interfaces.
	IsPackageHeaderContext()
}

type PackageHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageHeaderContext() *PackageHeaderContext {
	var p = new(PackageHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_packageHeader
	return p
}

func (*PackageHeaderContext) IsPackageHeaderContext() {}

func NewPackageHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageHeaderContext {
	var p = new(PackageHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_packageHeader

	return p
}

func (s *PackageHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageHeaderContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPACKAGE, 0)
}

func (s *PackageHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageHeaderContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PackageHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPackageHeader(s)
	}
}

func (s *PackageHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPackageHeader(s)
	}
}

func (p *KotlinParser) PackageHeader() (localctx IPackageHeaderContext) {
	this := p
	_ = this

	localctx = NewPackageHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KotlinParserRULE_packageHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserPACKAGE {
		{
			p.SetState(438)
			p.Match(KotlinParserPACKAGE)
		}
		{
			p.SetState(439)
			p.Identifier()
		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
			{
				p.SetState(440)
				p.Semi()
			}

		}

	}

	return localctx
}

// IImportListContext is an interface to support dynamic dispatch.
type IImportListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportHeader() []IImportHeaderContext
	ImportHeader(i int) IImportHeaderContext

	// IsImportListContext differentiates from other interfaces.
	IsImportListContext()
}

type ImportListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportListContext() *ImportListContext {
	var p = new(ImportListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importList
	return p
}

func (*ImportListContext) IsImportListContext() {}

func NewImportListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportListContext {
	var p = new(ImportListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importList

	return p
}

func (s *ImportListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportListContext) AllImportHeader() []IImportHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportHeaderContext); ok {
			len++
		}
	}

	tst := make([]IImportHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportHeaderContext); ok {
			tst[i] = t.(IImportHeaderContext)
			i++
		}
	}

	return tst
}

func (s *ImportListContext) ImportHeader(i int) IImportHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportHeaderContext)
}

func (s *ImportListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportList(s)
	}
}

func (s *ImportListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportList(s)
	}
}

func (p *KotlinParser) ImportList() (localctx IImportListContext) {
	this := p
	_ = this

	localctx = NewImportListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KotlinParserRULE_importList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(445)
				p.ImportHeader()
			}

		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IImportHeaderContext is an interface to support dynamic dispatch.
type IImportHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	MULT() antlr.TerminalNode
	ImportAlias() IImportAliasContext
	Semi() ISemiContext

	// IsImportHeaderContext differentiates from other interfaces.
	IsImportHeaderContext()
}

type ImportHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportHeaderContext() *ImportHeaderContext {
	var p = new(ImportHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importHeader
	return p
}

func (*ImportHeaderContext) IsImportHeaderContext() {}

func NewImportHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportHeaderContext {
	var p = new(ImportHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importHeader

	return p
}

func (s *ImportHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportHeaderContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *ImportHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportHeaderContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *ImportHeaderContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ImportHeaderContext) ImportAlias() IImportAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAliasContext)
}

func (s *ImportHeaderContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *ImportHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportHeader(s)
	}
}

func (s *ImportHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportHeader(s)
	}
}

func (p *KotlinParser) ImportHeader() (localctx IImportHeaderContext) {
	this := p
	_ = this

	localctx = NewImportHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KotlinParserRULE_importHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(KotlinParserIMPORT)
	}
	{
		p.SetState(452)
		p.Identifier()
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserDOT:
		{
			p.SetState(453)
			p.Match(KotlinParserDOT)
		}
		{
			p.SetState(454)
			p.Match(KotlinParserMULT)
		}

	case KotlinParserAS:
		{
			p.SetState(455)
			p.ImportAlias()
		}

	case KotlinParserEOF, KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserSEMICOLON, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:

	default:
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
		{
			p.SetState(458)
			p.Semi()
		}

	}

	return localctx
}

// IImportAliasContext is an interface to support dynamic dispatch.
type IImportAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext

	// IsImportAliasContext differentiates from other interfaces.
	IsImportAliasContext()
}

type ImportAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasContext() *ImportAliasContext {
	var p = new(ImportAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importAlias
	return p
}

func (*ImportAliasContext) IsImportAliasContext() {}

func NewImportAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasContext {
	var p = new(ImportAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importAlias

	return p
}

func (s *ImportAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *ImportAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ImportAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportAlias(s)
	}
}

func (s *ImportAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportAlias(s)
	}
}

func (p *KotlinParser) ImportAlias() (localctx IImportAliasContext) {
	this := p
	_ = this

	localctx = NewImportAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KotlinParserRULE_importAlias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(KotlinParserAS)
	}
	{
		p.SetState(462)
		p.SimpleIdentifier()
	}

	return localctx
}

// ITopLevelObjectContext is an interface to support dynamic dispatch.
type ITopLevelObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	Semis() ISemisContext

	// IsTopLevelObjectContext differentiates from other interfaces.
	IsTopLevelObjectContext()
}

type TopLevelObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopLevelObjectContext() *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_topLevelObject
	return p
}

func (*TopLevelObjectContext) IsTopLevelObjectContext() {}

func NewTopLevelObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_topLevelObject

	return p
}

func (s *TopLevelObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *TopLevelObjectContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *TopLevelObjectContext) Semis() ISemisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *TopLevelObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopLevelObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopLevelObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTopLevelObject(s)
	}
}

func (s *TopLevelObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTopLevelObject(s)
	}
}

func (p *KotlinParser) TopLevelObject() (localctx ITopLevelObjectContext) {
	this := p
	_ = this

	localctx = NewTopLevelObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KotlinParserRULE_topLevelObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Declaration()
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
		{
			p.SetState(465)
			p.Semis()
		}

	}

	return localctx
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE_ALIAS() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	ASSIGNMENT() antlr.TerminalNode
	Type_() ITypeContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	TypeParameters() ITypeParametersContext

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeAlias
	return p
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) TYPE_ALIAS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTYPE_ALIAS, 0)
}

func (s *TypeAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeAliasContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *TypeAliasContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeAliasContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *TypeAliasContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeAliasContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeAliasContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (p *KotlinParser) TypeAlias() (localctx ITypeAliasContext) {
	this := p
	_ = this

	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KotlinParserRULE_typeAlias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(468)
			p.Modifiers()
		}

	}
	{
		p.SetState(471)
		p.Match(KotlinParserTYPE_ALIAS)
	}
	p.SetState(475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(472)
			p.Match(KotlinParserNL)
		}

		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(478)
		p.SimpleIdentifier()
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(479)
				p.Match(KotlinParserNL)
			}

			p.SetState(484)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(485)
			p.TypeParameters()
		}

	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(488)
			p.Match(KotlinParserNL)
		}

		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(494)
		p.Match(KotlinParserASSIGNMENT)
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(495)
			p.Match(KotlinParserNL)
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(501)
		p.Type_()
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	ObjectDeclaration() IObjectDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	PropertyDeclaration() IPropertyDeclarationContext
	TypeAlias() ITypeAliasContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclarationContext) ObjectDeclaration() IObjectDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *DeclarationContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *KotlinParser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KotlinParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(503)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(504)
			p.ObjectDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(505)
			p.FunctionDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(506)
			p.PropertyDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(507)
			p.TypeAlias()
		}

	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	CLASS() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	PrimaryConstructor() IPrimaryConstructorContext
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	TypeConstraints() ITypeConstraintsContext
	ClassBody() IClassBodyContext
	EnumClassBody() IEnumClassBodyContext
	FUN() antlr.TerminalNode

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *ClassDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERFACE, 0)
}

func (s *ClassDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) PrimaryConstructor() IPrimaryConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryConstructorContext)
}

func (s *ClassDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ClassDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) EnumClassBody() IEnumClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumClassBodyContext)
}

func (s *ClassDeclarationContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *KotlinParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KotlinParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(510)
			p.Modifiers()
		}

	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserCLASS:
		{
			p.SetState(513)
			p.Match(KotlinParserCLASS)
		}

	case KotlinParserINTERFACE, KotlinParserFUN:
		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserFUN {
			{
				p.SetState(514)
				p.Match(KotlinParserFUN)
			}
			p.SetState(518)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(515)
					p.Match(KotlinParserNL)
				}

				p.SetState(520)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(523)
			p.Match(KotlinParserINTERFACE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(526)
			p.Match(KotlinParserNL)
		}

		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(532)
		p.SimpleIdentifier()
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(533)
				p.Match(KotlinParserNL)
			}

			p.SetState(538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(539)
			p.TypeParameters()
		}

	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(542)
				p.Match(KotlinParserNL)
			}

			p.SetState(547)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(548)
			p.PrimaryConstructor()
		}

	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(551)
				p.Match(KotlinParserNL)
			}

			p.SetState(556)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(557)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(558)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(563)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
		}
		{
			p.SetState(564)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(567)
				p.Match(KotlinParserNL)
			}

			p.SetState(572)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(573)
			p.TypeConstraints()
		}

	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(576)
				p.Match(KotlinParserNL)
			}

			p.SetState(581)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(582)
			p.ClassBody()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 2 {
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(583)
				p.Match(KotlinParserNL)
			}

			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(589)
			p.EnumClassBody()
		}

	}

	return localctx
}

// IPrimaryConstructorContext is an interface to support dynamic dispatch.
type IPrimaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassParameters() IClassParametersContext
	CONSTRUCTOR() antlr.TerminalNode
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsPrimaryConstructorContext differentiates from other interfaces.
	IsPrimaryConstructorContext()
}

type PrimaryConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryConstructorContext() *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryConstructor
	return p
}

func (*PrimaryConstructorContext) IsPrimaryConstructorContext() {}

func NewPrimaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_primaryConstructor

	return p
}

func (s *PrimaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryConstructorContext) ClassParameters() IClassParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParametersContext)
}

func (s *PrimaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *PrimaryConstructorContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *PrimaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PrimaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PrimaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrimaryConstructor(s)
	}
}

func (s *PrimaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrimaryConstructor(s)
	}
}

func (p *KotlinParser) PrimaryConstructor() (localctx IPrimaryConstructorContext) {
	this := p
	_ = this

	localctx = NewPrimaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KotlinParserRULE_primaryConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&63050394514751489) != 0) {
		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
			{
				p.SetState(592)
				p.Modifiers()
			}

		}
		{
			p.SetState(595)
			p.Match(KotlinParserCONSTRUCTOR)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(596)
				p.Match(KotlinParserNL)
			}

			p.SetState(601)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(604)
		p.ClassParameters()
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	ClassMemberDeclarations() IClassMemberDeclarationsContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *ClassBodyContext) ClassMemberDeclarations() IClassMemberDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationsContext)
}

func (s *ClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *ClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *KotlinParser) ClassBody() (localctx IClassBodyContext) {
	this := p
	_ = this

	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KotlinParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(607)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}
	{
		p.SetState(613)
		p.ClassMemberDeclarations()
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(614)
			p.Match(KotlinParserNL)
		}

		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(620)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IClassParametersContext is an interface to support dynamic dispatch.
type IClassParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllClassParameter() []IClassParameterContext
	ClassParameter(i int) IClassParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClassParametersContext differentiates from other interfaces.
	IsClassParametersContext()
}

type ClassParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParametersContext() *ClassParametersContext {
	var p = new(ClassParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameters
	return p
}

func (*ClassParametersContext) IsClassParametersContext() {}

func NewClassParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParametersContext {
	var p = new(ClassParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameters

	return p
}

func (s *ClassParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ClassParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ClassParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassParametersContext) AllClassParameter() []IClassParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassParameterContext); ok {
			len++
		}
	}

	tst := make([]IClassParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassParameterContext); ok {
			tst[i] = t.(IClassParameterContext)
			i++
		}
	}

	return tst
}

func (s *ClassParametersContext) ClassParameter(i int) IClassParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParameterContext)
}

func (s *ClassParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ClassParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ClassParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameters(s)
	}
}

func (s *ClassParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameters(s)
	}
}

func (p *KotlinParser) ClassParameters() (localctx IClassParametersContext) {
	this := p
	_ = this

	localctx = NewClassParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KotlinParserRULE_classParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(623)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(629)
			p.ClassParameter()
		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(633)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(630)
						p.Match(KotlinParserNL)
					}

					p.SetState(635)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(636)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(640)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(637)
							p.Match(KotlinParserNL)
						}

					}
					p.SetState(642)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
				}
				{
					p.SetState(643)
					p.ClassParameter()
				}

			}
			p.SetState(648)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
		}
		p.SetState(656)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			p.SetState(652)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(649)
					p.Match(KotlinParserNL)
				}

				p.SetState(654)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(655)
				p.Match(KotlinParserCOMMA)
			}

		}

	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(660)
			p.Match(KotlinParserNL)
		}

		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(666)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IClassParameterContext is an interface to support dynamic dispatch.
type IClassParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	VAL() antlr.TerminalNode
	VAR() antlr.TerminalNode

	// IsClassParameterContext differentiates from other interfaces.
	IsClassParameterContext()
}

type ClassParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParameterContext() *ClassParameterContext {
	var p = new(ClassParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameter
	return p
}

func (*ClassParameterContext) IsClassParameterContext() {}

func NewClassParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParameterContext {
	var p = new(ClassParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameter

	return p
}

func (s *ClassParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ClassParameterContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ClassParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassParameterContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *ClassParameterContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *ClassParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameter(s)
	}
}

func (s *ClassParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameter(s)
	}
}

func (p *KotlinParser) ClassParameter() (localctx IClassParameterContext) {
	this := p
	_ = this

	localctx = NewClassParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KotlinParserRULE_classParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(669)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(668)
			p.Modifiers()
		}

	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserVAL || _la == KotlinParserVAR {
		{
			p.SetState(671)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(674)
			p.Match(KotlinParserNL)
		}

		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(680)
		p.SimpleIdentifier()
	}
	{
		p.SetState(681)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(682)
			p.Match(KotlinParserNL)
		}

		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(688)
		p.Type_()
	}
	p.SetState(703)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(689)
				p.Match(KotlinParserNL)
			}

			p.SetState(694)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(695)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(696)
				p.Match(KotlinParserNL)
			}

			p.SetState(701)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(702)
			p.Expression()
		}

	}

	return localctx
}

// IDelegationSpecifiersContext is an interface to support dynamic dispatch.
type IDelegationSpecifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotatedDelegationSpecifier() []IAnnotatedDelegationSpecifierContext
	AnnotatedDelegationSpecifier(i int) IAnnotatedDelegationSpecifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDelegationSpecifiersContext differentiates from other interfaces.
	IsDelegationSpecifiersContext()
}

type DelegationSpecifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifiersContext() *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers
	return p
}

func (*DelegationSpecifiersContext) IsDelegationSpecifiersContext() {}

func NewDelegationSpecifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers

	return p
}

func (s *DelegationSpecifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifiersContext) AllAnnotatedDelegationSpecifier() []IAnnotatedDelegationSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotatedDelegationSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IAnnotatedDelegationSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotatedDelegationSpecifierContext); ok {
			tst[i] = t.(IAnnotatedDelegationSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DelegationSpecifiersContext) AnnotatedDelegationSpecifier(i int) IAnnotatedDelegationSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotatedDelegationSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotatedDelegationSpecifierContext)
}

func (s *DelegationSpecifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *DelegationSpecifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *DelegationSpecifiersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DelegationSpecifiersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DelegationSpecifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifiers(s)
	}
}

func (s *DelegationSpecifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifiers(s)
	}
}

func (p *KotlinParser) DelegationSpecifiers() (localctx IDelegationSpecifiersContext) {
	this := p
	_ = this

	localctx = NewDelegationSpecifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KotlinParserRULE_delegationSpecifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.AnnotatedDelegationSpecifier()
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(709)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(706)
					p.Match(KotlinParserNL)
				}

				p.SetState(711)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(712)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(716)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(713)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(718)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
			}
			{
				p.SetState(719)
				p.AnnotatedDelegationSpecifier()
			}

		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}

	return localctx
}

// IDelegationSpecifierContext is an interface to support dynamic dispatch.
type IDelegationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorInvocation() IConstructorInvocationContext
	ExplicitDelegation() IExplicitDelegationContext
	UserType() IUserTypeContext
	FunctionType() IFunctionTypeContext
	SUSPEND() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDelegationSpecifierContext differentiates from other interfaces.
	IsDelegationSpecifierContext()
}

type DelegationSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifierContext() *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifier
	return p
}

func (*DelegationSpecifierContext) IsDelegationSpecifierContext() {}

func NewDelegationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifier

	return p
}

func (s *DelegationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifierContext) ConstructorInvocation() IConstructorInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorInvocationContext)
}

func (s *DelegationSpecifierContext) ExplicitDelegation() IExplicitDelegationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitDelegationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitDelegationContext)
}

func (s *DelegationSpecifierContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *DelegationSpecifierContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *DelegationSpecifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *DelegationSpecifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DelegationSpecifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DelegationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifier(s)
	}
}

func (s *DelegationSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifier(s)
	}
}

func (p *KotlinParser) DelegationSpecifier() (localctx IDelegationSpecifierContext) {
	this := p
	_ = this

	localctx = NewDelegationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KotlinParserRULE_delegationSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(725)
			p.ConstructorInvocation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(726)
			p.ExplicitDelegation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(727)
			p.UserType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(728)
			p.FunctionType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(729)
			p.Match(KotlinParserSUSPEND)
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(730)
				p.Match(KotlinParserNL)
			}

			p.SetState(735)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(736)
			p.FunctionType()
		}

	}

	return localctx
}

// IConstructorInvocationContext is an interface to support dynamic dispatch.
type IConstructorInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserType() IUserTypeContext
	ValueArguments() IValueArgumentsContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsConstructorInvocationContext differentiates from other interfaces.
	IsConstructorInvocationContext()
}

type ConstructorInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorInvocationContext() *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorInvocation
	return p
}

func (*ConstructorInvocationContext) IsConstructorInvocationContext() {}

func NewConstructorInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorInvocation

	return p
}

func (s *ConstructorInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorInvocationContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ConstructorInvocationContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *ConstructorInvocationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConstructorInvocationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConstructorInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorInvocation(s)
	}
}

func (s *ConstructorInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorInvocation(s)
	}
}

func (p *KotlinParser) ConstructorInvocation() (localctx IConstructorInvocationContext) {
	this := p
	_ = this

	localctx = NewConstructorInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KotlinParserRULE_constructorInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.UserType()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(740)
			p.Match(KotlinParserNL)
		}

		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(746)
		p.ValueArguments()
	}

	return localctx
}

// IAnnotatedDelegationSpecifierContext is an interface to support dynamic dispatch.
type IAnnotatedDelegationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DelegationSpecifier() IDelegationSpecifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotatedDelegationSpecifierContext differentiates from other interfaces.
	IsAnnotatedDelegationSpecifierContext()
}

type AnnotatedDelegationSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedDelegationSpecifierContext() *AnnotatedDelegationSpecifierContext {
	var p = new(AnnotatedDelegationSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedDelegationSpecifier
	return p
}

func (*AnnotatedDelegationSpecifierContext) IsAnnotatedDelegationSpecifierContext() {}

func NewAnnotatedDelegationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedDelegationSpecifierContext {
	var p = new(AnnotatedDelegationSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotatedDelegationSpecifier

	return p
}

func (s *AnnotatedDelegationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedDelegationSpecifierContext) DelegationSpecifier() IDelegationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifierContext)
}

func (s *AnnotatedDelegationSpecifierContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotatedDelegationSpecifierContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotatedDelegationSpecifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotatedDelegationSpecifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotatedDelegationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedDelegationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedDelegationSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotatedDelegationSpecifier(s)
	}
}

func (s *AnnotatedDelegationSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotatedDelegationSpecifier(s)
	}
}

func (p *KotlinParser) AnnotatedDelegationSpecifier() (localctx IAnnotatedDelegationSpecifierContext) {
	this := p
	_ = this

	localctx = NewAnnotatedDelegationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KotlinParserRULE_annotatedDelegationSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(748)
				p.Annotation()
			}

		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(754)
			p.Match(KotlinParserNL)
		}

		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(760)
		p.DelegationSpecifier()
	}

	return localctx
}

// IExplicitDelegationContext is an interface to support dynamic dispatch.
type IExplicitDelegationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BY() antlr.TerminalNode
	Expression() IExpressionContext
	UserType() IUserTypeContext
	FunctionType() IFunctionTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsExplicitDelegationContext differentiates from other interfaces.
	IsExplicitDelegationContext()
}

type ExplicitDelegationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitDelegationContext() *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_explicitDelegation
	return p
}

func (*ExplicitDelegationContext) IsExplicitDelegationContext() {}

func NewExplicitDelegationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_explicitDelegation

	return p
}

func (s *ExplicitDelegationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitDelegationContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *ExplicitDelegationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExplicitDelegationContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ExplicitDelegationContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *ExplicitDelegationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ExplicitDelegationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ExplicitDelegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitDelegationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitDelegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExplicitDelegation(s)
	}
}

func (s *ExplicitDelegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExplicitDelegation(s)
	}
}

func (p *KotlinParser) ExplicitDelegation() (localctx IExplicitDelegationContext) {
	this := p
	_ = this

	localctx = NewExplicitDelegationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KotlinParserRULE_explicitDelegation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(762)
			p.UserType()
		}

	case 2:
		{
			p.SetState(763)
			p.FunctionType()
		}

	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(766)
			p.Match(KotlinParserNL)
		}

		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(772)
		p.Match(KotlinParserBY)
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(773)
			p.Match(KotlinParserNL)
		}

		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(779)
		p.Expression()
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGLE() antlr.TerminalNode
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext
	RANGLE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *KotlinParser) TypeParameters() (localctx ITypeParametersContext) {
	this := p
	_ = this

	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KotlinParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(KotlinParserLANGLE)
	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(782)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(787)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
	}
	{
		p.SetState(788)
		p.TypeParameter()
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(792)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(789)
					p.Match(KotlinParserNL)
				}

				p.SetState(794)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(795)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(799)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(796)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(801)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
			}
			{
				p.SetState(802)
				p.TypeParameter()
			}

		}
		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}
	p.SetState(815)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(808)
				p.Match(KotlinParserNL)
			}

			p.SetState(813)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(814)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(817)
			p.Match(KotlinParserNL)
		}

		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(823)
		p.Match(KotlinParserRANGLE)
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	TypeParameterModifiers() ITypeParameterModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeParameterContext) TypeParameterModifiers() ITypeParameterModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifiersContext)
}

func (s *TypeParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *KotlinParser) TypeParameter() (localctx ITypeParameterContext) {
	this := p
	_ = this

	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KotlinParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(825)
			p.TypeParameterModifiers()
		}

	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(828)
			p.Match(KotlinParserNL)
		}

		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(834)
		p.SimpleIdentifier()
	}
	p.SetState(849)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(835)
				p.Match(KotlinParserNL)
			}

			p.SetState(840)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(841)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(845)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(842)
				p.Match(KotlinParserNL)
			}

			p.SetState(847)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(848)
			p.Type_()
		}

	}

	return localctx
}

// ITypeConstraintsContext is an interface to support dynamic dispatch.
type ITypeConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	AllTypeConstraint() []ITypeConstraintContext
	TypeConstraint(i int) ITypeConstraintContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeConstraintsContext differentiates from other interfaces.
	IsTypeConstraintsContext()
}

type TypeConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintsContext() *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraints
	return p
}

func (*TypeConstraintsContext) IsTypeConstraintsContext() {}

func NewTypeConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraints

	return p
}

func (s *TypeConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintsContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *TypeConstraintsContext) AllTypeConstraint() []ITypeConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeConstraintContext); ok {
			len++
		}
	}

	tst := make([]ITypeConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeConstraintContext); ok {
			tst[i] = t.(ITypeConstraintContext)
			i++
		}
	}

	return tst
}

func (s *TypeConstraintsContext) TypeConstraint(i int) ITypeConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintContext)
}

func (s *TypeConstraintsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeConstraintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraints(s)
	}
}

func (s *TypeConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraints(s)
	}
}

func (p *KotlinParser) TypeConstraints() (localctx ITypeConstraintsContext) {
	this := p
	_ = this

	localctx = NewTypeConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KotlinParserRULE_typeConstraints)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Match(KotlinParserWHERE)
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(852)
			p.Match(KotlinParserNL)
		}

		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(858)
		p.TypeConstraint()
	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(862)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(859)
					p.Match(KotlinParserNL)
				}

				p.SetState(864)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(865)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(869)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(866)
					p.Match(KotlinParserNL)
				}

				p.SetState(871)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(872)
				p.TypeConstraint()
			}

		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeConstraintContext is an interface to support dynamic dispatch.
type ITypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsTypeConstraintContext differentiates from other interfaces.
	IsTypeConstraintContext()
}

type TypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintContext() *TypeConstraintContext {
	var p = new(TypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraint
	return p
}

func (*TypeConstraintContext) IsTypeConstraintContext() {}

func NewTypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintContext {
	var p = new(TypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraint

	return p
}

func (s *TypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeConstraintContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeConstraintContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeConstraintContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeConstraintContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeConstraintContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraint(s)
	}
}

func (s *TypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraint(s)
	}
}

func (p *KotlinParser) TypeConstraint() (localctx ITypeConstraintContext) {
	this := p
	_ = this

	localctx = NewTypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KotlinParserRULE_typeConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(878)
			p.Annotation()
		}

		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(884)
		p.SimpleIdentifier()
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(885)
			p.Match(KotlinParserNL)
		}

		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(891)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(892)
			p.Match(KotlinParserNL)
		}

		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(898)
		p.Type_()
	}

	return localctx
}

// IClassMemberDeclarationsContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassMemberDeclaration() []IClassMemberDeclarationContext
	ClassMemberDeclaration(i int) IClassMemberDeclarationContext
	AllSemis() []ISemisContext
	Semis(i int) ISemisContext

	// IsClassMemberDeclarationsContext differentiates from other interfaces.
	IsClassMemberDeclarationsContext()
}

type ClassMemberDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationsContext() *ClassMemberDeclarationsContext {
	var p = new(ClassMemberDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclarations
	return p
}

func (*ClassMemberDeclarationsContext) IsClassMemberDeclarationsContext() {}

func NewClassMemberDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationsContext {
	var p = new(ClassMemberDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classMemberDeclarations

	return p
}

func (s *ClassMemberDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationsContext) AllClassMemberDeclaration() []IClassMemberDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassMemberDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassMemberDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassMemberDeclarationContext); ok {
			tst[i] = t.(IClassMemberDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassMemberDeclarationsContext) ClassMemberDeclaration(i int) IClassMemberDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationContext)
}

func (s *ClassMemberDeclarationsContext) AllSemis() []ISemisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISemisContext); ok {
			len++
		}
	}

	tst := make([]ISemisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISemisContext); ok {
			tst[i] = t.(ISemisContext)
			i++
		}
	}

	return tst
}

func (s *ClassMemberDeclarationsContext) Semis(i int) ISemisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *ClassMemberDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassMemberDeclarations(s)
	}
}

func (s *ClassMemberDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassMemberDeclarations(s)
	}
}

func (p *KotlinParser) ClassMemberDeclarations() (localctx IClassMemberDeclarationsContext) {
	this := p
	_ = this

	localctx = NewClassMemberDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KotlinParserRULE_classMemberDeclarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&8070450497888192255) != 0) {
		{
			p.SetState(900)
			p.ClassMemberDeclaration()
		}
		p.SetState(902)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(901)
				p.Semis()
			}

		}

		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IClassMemberDeclarationContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	CompanionObject() ICompanionObjectContext
	AnonymousInitializer() IAnonymousInitializerContext
	SecondaryConstructor() ISecondaryConstructorContext

	// IsClassMemberDeclarationContext differentiates from other interfaces.
	IsClassMemberDeclarationContext()
}

type ClassMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationContext() *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration
	return p
}

func (*ClassMemberDeclarationContext) IsClassMemberDeclarationContext() {}

func NewClassMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration

	return p
}

func (s *ClassMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ClassMemberDeclarationContext) CompanionObject() ICompanionObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompanionObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompanionObjectContext)
}

func (s *ClassMemberDeclarationContext) AnonymousInitializer() IAnonymousInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousInitializerContext)
}

func (s *ClassMemberDeclarationContext) SecondaryConstructor() ISecondaryConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISecondaryConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISecondaryConstructorContext)
}

func (s *ClassMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassMemberDeclaration(s)
	}
}

func (s *ClassMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassMemberDeclaration(s)
	}
}

func (p *KotlinParser) ClassMemberDeclaration() (localctx IClassMemberDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KotlinParserRULE_classMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(909)
			p.Declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(910)
			p.CompanionObject()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(911)
			p.AnonymousInitializer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(912)
			p.SecondaryConstructor()
		}

	}

	return localctx
}

// IAnonymousInitializerContext is an interface to support dynamic dispatch.
type IAnonymousInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INIT() antlr.TerminalNode
	Block() IBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnonymousInitializerContext differentiates from other interfaces.
	IsAnonymousInitializerContext()
}

type AnonymousInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousInitializerContext() *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousInitializer
	return p
}

func (*AnonymousInitializerContext) IsAnonymousInitializerContext() {}

func NewAnonymousInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anonymousInitializer

	return p
}

func (s *AnonymousInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousInitializerContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *AnonymousInitializerContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *AnonymousInitializerContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnonymousInitializerContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnonymousInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnonymousInitializer(s)
	}
}

func (s *AnonymousInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnonymousInitializer(s)
	}
}

func (p *KotlinParser) AnonymousInitializer() (localctx IAnonymousInitializerContext) {
	this := p
	_ = this

	localctx = NewAnonymousInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KotlinParserRULE_anonymousInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(915)
		p.Match(KotlinParserINIT)
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(916)
			p.Match(KotlinParserNL)
		}

		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(922)
		p.Block()
	}

	return localctx
}

// ICompanionObjectContext is an interface to support dynamic dispatch.
type ICompanionObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPANION() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	ClassBody() IClassBodyContext

	// IsCompanionObjectContext differentiates from other interfaces.
	IsCompanionObjectContext()
}

type CompanionObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompanionObjectContext() *CompanionObjectContext {
	var p = new(CompanionObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_companionObject
	return p
}

func (*CompanionObjectContext) IsCompanionObjectContext() {}

func NewCompanionObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompanionObjectContext {
	var p = new(CompanionObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_companionObject

	return p
}

func (s *CompanionObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *CompanionObjectContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *CompanionObjectContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *CompanionObjectContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *CompanionObjectContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CompanionObjectContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CompanionObjectContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CompanionObjectContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CompanionObjectContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *CompanionObjectContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *CompanionObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompanionObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompanionObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCompanionObject(s)
	}
}

func (s *CompanionObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCompanionObject(s)
	}
}

func (p *KotlinParser) CompanionObject() (localctx ICompanionObjectContext) {
	this := p
	_ = this

	localctx = NewCompanionObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KotlinParserRULE_companionObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(924)
			p.Modifiers()
		}

	}
	{
		p.SetState(927)
		p.Match(KotlinParserCOMPANION)
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(928)
			p.Match(KotlinParserNL)
		}

		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(934)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(935)
				p.Match(KotlinParserNL)
			}

			p.SetState(940)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(941)
			p.SimpleIdentifier()
		}

	}
	p.SetState(958)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(944)
				p.Match(KotlinParserNL)
			}

			p.SetState(949)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(950)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(951)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(956)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())
		}
		{
			p.SetState(957)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(960)
				p.Match(KotlinParserNL)
			}

			p.SetState(965)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(966)
			p.ClassBody()
		}

	}

	return localctx
}

// IFunctionValueParametersContext is an interface to support dynamic dispatch.
type IFunctionValueParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFunctionValueParameter() []IFunctionValueParameterContext
	FunctionValueParameter(i int) IFunctionValueParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionValueParametersContext differentiates from other interfaces.
	IsFunctionValueParametersContext()
}

type FunctionValueParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParametersContext() *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameters
	return p
}

func (*FunctionValueParametersContext) IsFunctionValueParametersContext() {}

func NewFunctionValueParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameters

	return p
}

func (s *FunctionValueParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionValueParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionValueParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParametersContext) AllFunctionValueParameter() []IFunctionValueParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionValueParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionValueParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionValueParameterContext); ok {
			tst[i] = t.(IFunctionValueParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionValueParametersContext) FunctionValueParameter(i int) IFunctionValueParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterContext)
}

func (s *FunctionValueParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionValueParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionValueParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameters(s)
	}
}

func (s *FunctionValueParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameters(s)
	}
}

func (p *KotlinParser) FunctionValueParameters() (localctx IFunctionValueParametersContext) {
	this := p
	_ = this

	localctx = NewFunctionValueParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KotlinParserRULE_functionValueParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(970)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-40)) & ^0x3f) == 0 && ((int64(1)<<(_la-40))&13668035483140101) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&2200096997375) != 0) {
		{
			p.SetState(976)
			p.FunctionValueParameter()
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(980)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(977)
						p.Match(KotlinParserNL)
					}

					p.SetState(982)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(983)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(987)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(984)
						p.Match(KotlinParserNL)
					}

					p.SetState(989)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(990)
					p.FunctionValueParameter()
				}

			}
			p.SetState(995)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext())
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			p.SetState(999)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(996)
					p.Match(KotlinParserNL)
				}

				p.SetState(1001)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1002)
				p.Match(KotlinParserCOMMA)
			}

		}

	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1007)
			p.Match(KotlinParserNL)
		}

		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1013)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IFunctionValueParameterContext is an interface to support dynamic dispatch.
type IFunctionValueParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameter() IParameterContext
	ParameterModifiers() IParameterModifiersContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionValueParameterContext differentiates from other interfaces.
	IsFunctionValueParameterContext()
}

type FunctionValueParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParameterContext() *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameter
	return p
}

func (*FunctionValueParameterContext) IsFunctionValueParameterContext() {}

func NewFunctionValueParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameter

	return p
}

func (s *FunctionValueParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParameterContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionValueParameterContext) ParameterModifiers() IParameterModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifiersContext)
}

func (s *FunctionValueParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionValueParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionValueParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameter(s)
	}
}

func (s *FunctionValueParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameter(s)
	}
}

func (p *KotlinParser) FunctionValueParameter() (localctx IFunctionValueParameterContext) {
	this := p
	_ = this

	localctx = NewFunctionValueParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KotlinParserRULE_functionValueParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1015)
			p.ParameterModifiers()
		}

	}
	{
		p.SetState(1018)
		p.Parameter()
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1019)
				p.Match(KotlinParserNL)
			}

			p.SetState(1024)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1025)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1026)
				p.Match(KotlinParserNL)
			}

			p.SetState(1031)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1032)
			p.Expression()
		}

	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUN() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	FunctionValueParameters() IFunctionValueParametersContext
	Modifiers() IModifiersContext
	TypeParameters() ITypeParametersContext
	ReceiverType() IReceiverTypeContext
	DOT() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	TypeConstraints() ITypeConstraintsContext
	FunctionBody() IFunctionBodyContext

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *FunctionDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *FunctionDeclarationContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *FunctionDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *FunctionDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionDeclarationContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *FunctionDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *FunctionDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *KotlinParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	this := p
	_ = this

	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KotlinParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(1035)
			p.Modifiers()
		}

	}
	{
		p.SetState(1038)
		p.Match(KotlinParserFUN)
	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1039)
				p.Match(KotlinParserNL)
			}

			p.SetState(1044)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1045)
			p.TypeParameters()
		}

	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		p.SetState(1051)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1048)
				p.Match(KotlinParserNL)
			}

			p.SetState(1053)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1054)
			p.ReceiverType()
		}
		p.SetState(1058)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1055)
				p.Match(KotlinParserNL)
			}

			p.SetState(1060)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1061)
			p.Match(KotlinParserDOT)
		}

	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1065)
			p.Match(KotlinParserNL)
		}

		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1071)
		p.SimpleIdentifier()
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1072)
			p.Match(KotlinParserNL)
		}

		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1078)
		p.FunctionValueParameters()
	}
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1079)
				p.Match(KotlinParserNL)
			}

			p.SetState(1084)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1085)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1089)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1086)
				p.Match(KotlinParserNL)
			}

			p.SetState(1091)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1092)
			p.Type_()
		}

	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1095)
				p.Match(KotlinParserNL)
			}

			p.SetState(1100)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1101)
			p.TypeConstraints()
		}

	}
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1104)
				p.Match(KotlinParserNL)
			}

			p.SetState(1109)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1110)
			p.FunctionBody()
		}

	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionBodyContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *KotlinParser) FunctionBody() (localctx IFunctionBodyContext) {
	this := p
	_ = this

	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KotlinParserRULE_functionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1122)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLCURL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1113)
			p.Block()
		}

	case KotlinParserASSIGNMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1114)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1115)
				p.Match(KotlinParserNL)
			}

			p.SetState(1120)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1121)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *VariableDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *VariableDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *VariableDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *VariableDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *KotlinParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KotlinParserRULE_variableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(1124)
			p.Annotation()
		}

		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1133)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1130)
			p.Match(KotlinParserNL)
		}

		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1136)
		p.SimpleIdentifier()
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1137)
				p.Match(KotlinParserNL)
			}

			p.SetState(1142)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1143)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1144)
				p.Match(KotlinParserNL)
			}

			p.SetState(1149)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1150)
			p.Type_()
		}

	}

	return localctx
}

// IMultiVariableDeclarationContext is an interface to support dynamic dispatch.
type IMultiVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultiVariableDeclarationContext differentiates from other interfaces.
	IsMultiVariableDeclarationContext()
}

type MultiVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiVariableDeclarationContext() *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration
	return p
}

func (*MultiVariableDeclarationContext) IsMultiVariableDeclarationContext() {}

func NewMultiVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration

	return p
}

func (s *MultiVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiVariableDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *MultiVariableDeclarationContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *MultiVariableDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiVariableDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiVariableDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *MultiVariableDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *MultiVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiVariableDeclaration(s)
	}
}

func (s *MultiVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiVariableDeclaration(s)
	}
}

func (p *KotlinParser) MultiVariableDeclaration() (localctx IMultiVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewMultiVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KotlinParserRULE_multiVariableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1154)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}
	{
		p.SetState(1160)
		p.VariableDeclaration()
	}
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1164)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1161)
					p.Match(KotlinParserNL)
				}

				p.SetState(1166)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1167)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1171)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1168)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1173)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
			}
			{
				p.SetState(1174)
				p.VariableDeclaration()
			}

		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())
	}
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1180)
				p.Match(KotlinParserNL)
			}

			p.SetState(1185)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1186)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1189)
			p.Match(KotlinParserNL)
		}

		p.SetState(1194)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1195)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAL() antlr.TerminalNode
	VAR() antlr.TerminalNode
	Modifiers() IModifiersContext
	TypeParameters() ITypeParametersContext
	ReceiverType() IReceiverTypeContext
	DOT() antlr.TerminalNode
	TypeConstraints() ITypeConstraintsContext
	SEMICOLON() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	MultiVariableDeclaration() IMultiVariableDeclarationContext
	VariableDeclaration() IVariableDeclarationContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	PropertyDelegate() IPropertyDelegateContext
	Getter() IGetterContext
	Setter() ISetterContext
	Semi() ISemiContext

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDeclaration
	return p
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *PropertyDeclarationContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *PropertyDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *PropertyDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *PropertyDeclarationContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *PropertyDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *PropertyDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *PropertyDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *PropertyDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PropertyDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PropertyDeclarationContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *PropertyDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDeclarationContext) PropertyDelegate() IPropertyDelegateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDelegateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDelegateContext)
}

func (s *PropertyDeclarationContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyDeclarationContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertyDeclarationContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (p *KotlinParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	this := p
	_ = this

	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KotlinParserRULE_propertyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(1197)
			p.Modifiers()
		}

	}
	{
		p.SetState(1200)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1208)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1201)
				p.Match(KotlinParserNL)
			}

			p.SetState(1206)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1207)
			p.TypeParameters()
		}

	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1210)
				p.Match(KotlinParserNL)
			}

			p.SetState(1215)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1216)
			p.ReceiverType()
		}
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1217)
				p.Match(KotlinParserNL)
			}

			p.SetState(1222)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1223)
			p.Match(KotlinParserDOT)
		}

	}

	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1227)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1232)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())
	}
	p.SetState(1235)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN:
		{
			p.SetState(1233)
			p.MultiVariableDeclaration()
		}

	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1234)
			p.VariableDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	p.SetState(1244)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		p.SetState(1240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1237)
				p.Match(KotlinParserNL)
			}

			p.SetState(1242)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1243)
			p.TypeConstraints()
		}

	}
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		p.SetState(1249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1246)
				p.Match(KotlinParserNL)
			}

			p.SetState(1251)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserASSIGNMENT:
			{
				p.SetState(1252)
				p.Match(KotlinParserASSIGNMENT)
			}
			p.SetState(1256)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1253)
					p.Match(KotlinParserNL)
				}

				p.SetState(1258)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1259)
				p.Expression()
			}

		case KotlinParserBY:
			{
				p.SetState(1260)
				p.PropertyDelegate()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
		p.SetState(1266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KotlinParserNL {
			{
				p.SetState(1265)
				p.Match(KotlinParserNL)
			}

			p.SetState(1268)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1270)
			p.Match(KotlinParserSEMICOLON)
		}

	}
	p.SetState(1276)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1273)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext())
	}
	p.SetState(1309)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1280)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1279)
				p.Getter()
			}

		}
		p.SetState(1292)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
			p.SetState(1285)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1282)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1287)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
			}
			p.SetState(1289)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
				{
					p.SetState(1288)
					p.Semi()
				}

			}
			{
				p.SetState(1291)
				p.Setter()
			}

		}

	case 2:
		p.SetState(1295)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1294)
				p.Setter()
			}

		}
		p.SetState(1307)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
			p.SetState(1300)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1297)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1302)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())
			}
			p.SetState(1304)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
				{
					p.SetState(1303)
					p.Semi()
				}

			}
			{
				p.SetState(1306)
				p.Getter()
			}

		}

	}

	return localctx
}

// IPropertyDelegateContext is an interface to support dynamic dispatch.
type IPropertyDelegateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BY() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsPropertyDelegateContext differentiates from other interfaces.
	IsPropertyDelegateContext()
}

type PropertyDelegateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDelegateContext() *PropertyDelegateContext {
	var p = new(PropertyDelegateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDelegate
	return p
}

func (*PropertyDelegateContext) IsPropertyDelegateContext() {}

func NewPropertyDelegateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDelegateContext {
	var p = new(PropertyDelegateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyDelegate

	return p
}

func (s *PropertyDelegateContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDelegateContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *PropertyDelegateContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDelegateContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PropertyDelegateContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PropertyDelegateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDelegateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDelegateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyDelegate(s)
	}
}

func (s *PropertyDelegateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyDelegate(s)
	}
}

func (p *KotlinParser) PropertyDelegate() (localctx IPropertyDelegateContext) {
	this := p
	_ = this

	localctx = NewPropertyDelegateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KotlinParserRULE_propertyDelegate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1311)
		p.Match(KotlinParserBY)
	}
	p.SetState(1315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1312)
			p.Match(KotlinParserNL)
		}

		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1318)
		p.Expression()
	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	Modifiers() IModifiersContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *GetterContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *GetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *GetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *GetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *GetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *GetterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *GetterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (p *KotlinParser) Getter() (localctx IGetterContext) {
	this := p
	_ = this

	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KotlinParserRULE_getter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(1320)
			p.Modifiers()
		}

	}
	{
		p.SetState(1323)
		p.Match(KotlinParserGET)
	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1324)
				p.Match(KotlinParserNL)
			}

			p.SetState(1329)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1330)
			p.Match(KotlinParserLPAREN)
		}
		p.SetState(1334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1331)
				p.Match(KotlinParserNL)
			}

			p.SetState(1336)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1337)
			p.Match(KotlinParserRPAREN)
		}
		p.SetState(1352)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			p.SetState(1341)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1338)
					p.Match(KotlinParserNL)
				}

				p.SetState(1343)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1344)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(1348)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1345)
					p.Match(KotlinParserNL)
				}

				p.SetState(1350)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1351)
				p.Type_()
			}

		}
		p.SetState(1357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1354)
				p.Match(KotlinParserNL)
			}

			p.SetState(1359)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1360)
			p.FunctionBody()
		}

	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	Modifiers() IModifiersContext
	LPAREN() antlr.TerminalNode
	FunctionValueParameterWithOptionalType() IFunctionValueParameterWithOptionalTypeContext
	RPAREN() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *SetterContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *SetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *SetterContext) FunctionValueParameterWithOptionalType() IFunctionValueParameterWithOptionalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterWithOptionalTypeContext)
}

func (s *SetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *SetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *SetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SetterContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, 0)
}

func (s *SetterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *SetterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (p *KotlinParser) Setter() (localctx ISetterContext) {
	this := p
	_ = this

	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KotlinParserRULE_setter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(1363)
			p.Modifiers()
		}

	}
	{
		p.SetState(1366)
		p.Match(KotlinParserSET)
	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1367)
				p.Match(KotlinParserNL)
			}

			p.SetState(1372)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1373)
			p.Match(KotlinParserLPAREN)
		}
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1374)
				p.Match(KotlinParserNL)
			}

			p.SetState(1379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1380)
			p.FunctionValueParameterWithOptionalType()
		}
		p.SetState(1388)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
			p.SetState(1384)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1381)
					p.Match(KotlinParserNL)
				}

				p.SetState(1386)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1387)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1390)
				p.Match(KotlinParserNL)
			}

			p.SetState(1395)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1396)
			p.Match(KotlinParserRPAREN)
		}
		p.SetState(1411)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			p.SetState(1400)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1397)
					p.Match(KotlinParserNL)
				}

				p.SetState(1402)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1403)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(1407)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1404)
					p.Match(KotlinParserNL)
				}

				p.SetState(1409)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1410)
				p.Type_()
			}

		}
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1413)
				p.Match(KotlinParserNL)
			}

			p.SetState(1418)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1419)
			p.FunctionBody()
		}

	}

	return localctx
}

// IParametersWithOptionalTypeContext is an interface to support dynamic dispatch.
type IParametersWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFunctionValueParameterWithOptionalType() []IFunctionValueParameterWithOptionalTypeContext
	FunctionValueParameterWithOptionalType(i int) IFunctionValueParameterWithOptionalTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersWithOptionalTypeContext differentiates from other interfaces.
	IsParametersWithOptionalTypeContext()
}

type ParametersWithOptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersWithOptionalTypeContext() *ParametersWithOptionalTypeContext {
	var p = new(ParametersWithOptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parametersWithOptionalType
	return p
}

func (*ParametersWithOptionalTypeContext) IsParametersWithOptionalTypeContext() {}

func NewParametersWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersWithOptionalTypeContext {
	var p = new(ParametersWithOptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parametersWithOptionalType

	return p
}

func (s *ParametersWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersWithOptionalTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParametersWithOptionalTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParametersWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParametersWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParametersWithOptionalTypeContext) AllFunctionValueParameterWithOptionalType() []IFunctionValueParameterWithOptionalTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			len++
		}
	}

	tst := make([]IFunctionValueParameterWithOptionalTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			tst[i] = t.(IFunctionValueParameterWithOptionalTypeContext)
			i++
		}
	}

	return tst
}

func (s *ParametersWithOptionalTypeContext) FunctionValueParameterWithOptionalType(i int) IFunctionValueParameterWithOptionalTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterWithOptionalTypeContext)
}

func (s *ParametersWithOptionalTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ParametersWithOptionalTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ParametersWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParametersWithOptionalType(s)
	}
}

func (s *ParametersWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParametersWithOptionalType(s)
	}
}

func (p *KotlinParser) ParametersWithOptionalType() (localctx IParametersWithOptionalTypeContext) {
	this := p
	_ = this

	localctx = NewParametersWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KotlinParserRULE_parametersWithOptionalType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1423)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1424)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1429)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext())
	}
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-40)) & ^0x3f) == 0 && ((int64(1)<<(_la-40))&13668035483140101) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&2200096997375) != 0) {
		{
			p.SetState(1430)
			p.FunctionValueParameterWithOptionalType()
		}
		p.SetState(1447)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1434)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(1431)
						p.Match(KotlinParserNL)
					}

					p.SetState(1436)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1437)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(1441)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(1438)
						p.Match(KotlinParserNL)
					}

					p.SetState(1443)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1444)
					p.FunctionValueParameterWithOptionalType()
				}

			}
			p.SetState(1449)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext())
		}
		p.SetState(1457)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) == 1 {
			p.SetState(1453)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1450)
					p.Match(KotlinParserNL)
				}

				p.SetState(1455)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1456)
				p.Match(KotlinParserCOMMA)
			}

		}

	}
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1461)
			p.Match(KotlinParserNL)
		}

		p.SetState(1466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1467)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IFunctionValueParameterWithOptionalTypeContext is an interface to support dynamic dispatch.
type IFunctionValueParameterWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterWithOptionalType() IParameterWithOptionalTypeContext
	ParameterModifiers() IParameterModifiersContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionValueParameterWithOptionalTypeContext differentiates from other interfaces.
	IsFunctionValueParameterWithOptionalTypeContext()
}

type FunctionValueParameterWithOptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParameterWithOptionalTypeContext() *FunctionValueParameterWithOptionalTypeContext {
	var p = new(FunctionValueParameterWithOptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameterWithOptionalType
	return p
}

func (*FunctionValueParameterWithOptionalTypeContext) IsFunctionValueParameterWithOptionalTypeContext() {
}

func NewFunctionValueParameterWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParameterWithOptionalTypeContext {
	var p = new(FunctionValueParameterWithOptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameterWithOptionalType

	return p
}

func (s *FunctionValueParameterWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParameterWithOptionalTypeContext) ParameterWithOptionalType() IParameterWithOptionalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterWithOptionalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterWithOptionalTypeContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) ParameterModifiers() IParameterModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifiersContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionValueParameterWithOptionalTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParameterWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParameterWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParameterWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParameterWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameterWithOptionalType(s)
	}
}

func (s *FunctionValueParameterWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameterWithOptionalType(s)
	}
}

func (p *KotlinParser) FunctionValueParameterWithOptionalType() (localctx IFunctionValueParameterWithOptionalTypeContext) {
	this := p
	_ = this

	localctx = NewFunctionValueParameterWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, KotlinParserRULE_functionValueParameterWithOptionalType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1469)
			p.ParameterModifiers()
		}

	}
	{
		p.SetState(1472)
		p.ParameterWithOptionalType()
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1473)
				p.Match(KotlinParserNL)
			}

			p.SetState(1478)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1479)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(1483)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1480)
				p.Match(KotlinParserNL)
			}

			p.SetState(1485)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1486)
			p.Expression()
		}

	}

	return localctx
}

// IParameterWithOptionalTypeContext is an interface to support dynamic dispatch.
type IParameterWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsParameterWithOptionalTypeContext differentiates from other interfaces.
	IsParameterWithOptionalTypeContext()
}

type ParameterWithOptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterWithOptionalTypeContext() *ParameterWithOptionalTypeContext {
	var p = new(ParameterWithOptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterWithOptionalType
	return p
}

func (*ParameterWithOptionalTypeContext) IsParameterWithOptionalTypeContext() {}

func NewParameterWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterWithOptionalTypeContext {
	var p = new(ParameterWithOptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterWithOptionalType

	return p
}

func (s *ParameterWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterWithOptionalTypeContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ParameterWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParameterWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParameterWithOptionalTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ParameterWithOptionalTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterWithOptionalType(s)
	}
}

func (s *ParameterWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterWithOptionalType(s)
	}
}

func (p *KotlinParser) ParameterWithOptionalType() (localctx IParameterWithOptionalTypeContext) {
	this := p
	_ = this

	localctx = NewParameterWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KotlinParserRULE_parameterWithOptionalType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1489)
		p.SimpleIdentifier()
	}
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1490)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext())
	}
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCOLON {
		{
			p.SetState(1496)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1497)
				p.Match(KotlinParserNL)
			}

			p.SetState(1502)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1503)
			p.Type_()
		}

	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *KotlinParser) Parameter() (localctx IParameterContext) {
	this := p
	_ = this

	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, KotlinParserRULE_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1506)
		p.SimpleIdentifier()
	}
	p.SetState(1510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1507)
			p.Match(KotlinParserNL)
		}

		p.SetState(1512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1513)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1514)
			p.Match(KotlinParserNL)
		}

		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1520)
		p.Type_()
	}

	return localctx
}

// IObjectDeclarationContext is an interface to support dynamic dispatch.
type IObjectDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	ClassBody() IClassBodyContext

	// IsObjectDeclarationContext differentiates from other interfaces.
	IsObjectDeclarationContext()
}

type ObjectDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectDeclarationContext() *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_objectDeclaration
	return p
}

func (*ObjectDeclarationContext) IsObjectDeclarationContext() {}

func NewObjectDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectDeclaration

	return p
}

func (s *ObjectDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectDeclarationContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ObjectDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ObjectDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectDeclaration(s)
	}
}

func (s *ObjectDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectDeclaration(s)
	}
}

func (p *KotlinParser) ObjectDeclaration() (localctx IObjectDeclarationContext) {
	this := p
	_ = this

	localctx = NewObjectDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, KotlinParserRULE_objectDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(1522)
			p.Modifiers()
		}

	}
	{
		p.SetState(1525)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1526)
			p.Match(KotlinParserNL)
		}

		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1532)
		p.SimpleIdentifier()
	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
		p.SetState(1536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1533)
				p.Match(KotlinParserNL)
			}

			p.SetState(1538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1539)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1543)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1540)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1545)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext())
		}
		{
			p.SetState(1546)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
		p.SetState(1552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1549)
				p.Match(KotlinParserNL)
			}

			p.SetState(1554)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1555)
			p.ClassBody()
		}

	}

	return localctx
}

// ISecondaryConstructorContext is an interface to support dynamic dispatch.
type ISecondaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSTRUCTOR() antlr.TerminalNode
	FunctionValueParameters() IFunctionValueParametersContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	ConstructorDelegationCall() IConstructorDelegationCallContext
	Block() IBlockContext

	// IsSecondaryConstructorContext differentiates from other interfaces.
	IsSecondaryConstructorContext()
}

type SecondaryConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondaryConstructorContext() *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_secondaryConstructor
	return p
}

func (*SecondaryConstructorContext) IsSecondaryConstructorContext() {}

func NewSecondaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_secondaryConstructor

	return p
}

func (s *SecondaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *SecondaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SecondaryConstructorContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *SecondaryConstructorContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *SecondaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SecondaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SecondaryConstructorContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *SecondaryConstructorContext) ConstructorDelegationCall() IConstructorDelegationCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDelegationCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDelegationCallContext)
}

func (s *SecondaryConstructorContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SecondaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecondaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecondaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSecondaryConstructor(s)
	}
}

func (s *SecondaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSecondaryConstructor(s)
	}
}

func (p *KotlinParser) SecondaryConstructor() (localctx ISecondaryConstructorContext) {
	this := p
	_ = this

	localctx = NewSecondaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KotlinParserRULE_secondaryConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&234881023) != 0) {
		{
			p.SetState(1558)
			p.Modifiers()
		}

	}
	{
		p.SetState(1561)
		p.Match(KotlinParserCONSTRUCTOR)
	}
	p.SetState(1565)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1562)
			p.Match(KotlinParserNL)
		}

		p.SetState(1567)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1568)
		p.FunctionValueParameters()
	}
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
		p.SetState(1572)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1569)
				p.Match(KotlinParserNL)
			}

			p.SetState(1574)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1575)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1576)
				p.Match(KotlinParserNL)
			}

			p.SetState(1581)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1582)
			p.ConstructorDelegationCall()
		}

	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1585)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext())
	}
	p.SetState(1592)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLCURL {
		{
			p.SetState(1591)
			p.Block()
		}

	}

	return localctx
}

// IConstructorDelegationCallContext is an interface to support dynamic dispatch.
type IConstructorDelegationCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueArguments() IValueArgumentsContext
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsConstructorDelegationCallContext differentiates from other interfaces.
	IsConstructorDelegationCallContext()
}

type ConstructorDelegationCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDelegationCallContext() *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall
	return p
}

func (*ConstructorDelegationCallContext) IsConstructorDelegationCallContext() {}

func NewConstructorDelegationCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall

	return p
}

func (s *ConstructorDelegationCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDelegationCallContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *ConstructorDelegationCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ConstructorDelegationCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *ConstructorDelegationCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConstructorDelegationCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConstructorDelegationCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDelegationCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDelegationCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorDelegationCall(s)
	}
}

func (s *ConstructorDelegationCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorDelegationCall(s)
	}
}

func (p *KotlinParser) ConstructorDelegationCall() (localctx IConstructorDelegationCallContext) {
	this := p
	_ = this

	localctx = NewConstructorDelegationCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KotlinParserRULE_constructorDelegationCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1594)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserTHIS || _la == KotlinParserSUPER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1598)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1595)
			p.Match(KotlinParserNL)
		}

		p.SetState(1600)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1601)
		p.ValueArguments()
	}

	return localctx
}

// IEnumClassBodyContext is an interface to support dynamic dispatch.
type IEnumClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	EnumEntries() IEnumEntriesContext
	SEMICOLON() antlr.TerminalNode
	ClassMemberDeclarations() IClassMemberDeclarationsContext

	// IsEnumClassBodyContext differentiates from other interfaces.
	IsEnumClassBodyContext()
}

type EnumClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumClassBodyContext() *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumClassBody
	return p
}

func (*EnumClassBodyContext) IsEnumClassBodyContext() {}

func NewEnumClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumClassBody

	return p
}

func (s *EnumClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *EnumClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *EnumClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumClassBodyContext) EnumEntries() IEnumEntriesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumEntriesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumEntriesContext)
}

func (s *EnumClassBodyContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *EnumClassBodyContext) ClassMemberDeclarations() IClassMemberDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationsContext)
}

func (s *EnumClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumClassBody(s)
	}
}

func (s *EnumClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumClassBody(s)
	}
}

func (p *KotlinParser) EnumClassBody() (localctx IEnumClassBodyContext) {
	this := p
	_ = this

	localctx = NewEnumClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KotlinParserRULE_enumClassBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1603)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1604)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext())
	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-40)) & ^0x3f) == 0 && ((int64(1)<<(_la-40))&13668035483140101) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&2200096997375) != 0) {
		{
			p.SetState(1610)
			p.EnumEntries()
		}

	}
	p.SetState(1627)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext()) == 1 {
		p.SetState(1616)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1613)
				p.Match(KotlinParserNL)
			}

			p.SetState(1618)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1619)
			p.Match(KotlinParserSEMICOLON)
		}
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1620)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1625)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext())
		}
		{
			p.SetState(1626)
			p.ClassMemberDeclarations()
		}

	}
	p.SetState(1632)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1629)
			p.Match(KotlinParserNL)
		}

		p.SetState(1634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1635)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IEnumEntriesContext is an interface to support dynamic dispatch.
type IEnumEntriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumEntry() []IEnumEntryContext
	EnumEntry(i int) IEnumEntryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsEnumEntriesContext differentiates from other interfaces.
	IsEnumEntriesContext()
}

type EnumEntriesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntriesContext() *EnumEntriesContext {
	var p = new(EnumEntriesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntries
	return p
}

func (*EnumEntriesContext) IsEnumEntriesContext() {}

func NewEnumEntriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntriesContext {
	var p = new(EnumEntriesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntries

	return p
}

func (s *EnumEntriesContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntriesContext) AllEnumEntry() []IEnumEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumEntryContext); ok {
			len++
		}
	}

	tst := make([]IEnumEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumEntryContext); ok {
			tst[i] = t.(IEnumEntryContext)
			i++
		}
	}

	return tst
}

func (s *EnumEntriesContext) EnumEntry(i int) IEnumEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumEntryContext)
}

func (s *EnumEntriesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *EnumEntriesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *EnumEntriesContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntriesContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntries(s)
	}
}

func (s *EnumEntriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntries(s)
	}
}

func (p *KotlinParser) EnumEntries() (localctx IEnumEntriesContext) {
	this := p
	_ = this

	localctx = NewEnumEntriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KotlinParserRULE_enumEntries)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1637)
		p.EnumEntry()
	}
	p.SetState(1654)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1641)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1638)
					p.Match(KotlinParserNL)
				}

				p.SetState(1643)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1644)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1648)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1645)
					p.Match(KotlinParserNL)
				}

				p.SetState(1650)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1651)
				p.EnumEntry()
			}

		}
		p.SetState(1656)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext())
	}
	p.SetState(1660)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 235, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1657)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1662)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 235, p.GetParserRuleContext())
	}
	p.SetState(1664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCOMMA {
		{
			p.SetState(1663)
			p.Match(KotlinParserCOMMA)
		}

	}

	return localctx
}

// IEnumEntryContext is an interface to support dynamic dispatch.
type IEnumEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	Modifiers() IModifiersContext
	ValueArguments() IValueArgumentsContext
	ClassBody() IClassBodyContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsEnumEntryContext differentiates from other interfaces.
	IsEnumEntryContext()
}

type EnumEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntryContext() *EnumEntryContext {
	var p = new(EnumEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntry
	return p
}

func (*EnumEntryContext) IsEnumEntryContext() {}

func NewEnumEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntryContext {
	var p = new(EnumEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntry

	return p
}

func (s *EnumEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntryContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *EnumEntryContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *EnumEntryContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *EnumEntryContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntry(s)
	}
}

func (s *EnumEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntry(s)
	}
}

func (p *KotlinParser) EnumEntry() (localctx IEnumEntryContext) {
	this := p
	_ = this

	localctx = NewEnumEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KotlinParserRULE_enumEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1673)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1666)
			p.Modifiers()
		}
		p.SetState(1670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1667)
				p.Match(KotlinParserNL)
			}

			p.SetState(1672)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1675)
		p.SimpleIdentifier()
	}
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1676)
				p.Match(KotlinParserNL)
			}

			p.SetState(1681)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1682)
			p.ValueArguments()
		}

	}
	p.SetState(1692)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext()) == 1 {
		p.SetState(1688)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1685)
				p.Match(KotlinParserNL)
			}

			p.SetState(1690)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1691)
			p.ClassBody()
		}

	}

	return localctx
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionType() IFunctionTypeContext
	ParenthesizedType() IParenthesizedTypeContext
	NullableType() INullableTypeContext
	TypeReference() ITypeReferenceContext
	DefinitelyNonNullableType() IDefinitelyNonNullableTypeContext
	TypeModifiers() ITypeModifiersContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_type
	return p
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *TypeContext) NullableType() INullableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *TypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *TypeContext) DefinitelyNonNullableType() IDefinitelyNonNullableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitelyNonNullableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitelyNonNullableTypeContext)
}

func (s *TypeContext) TypeModifiers() ITypeModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *KotlinParser) Type_() (localctx ITypeContext) {
	this := p
	_ = this

	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KotlinParserRULE_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1695)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1694)
			p.TypeModifiers()
		}

	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1697)
			p.FunctionType()
		}

	case 2:
		{
			p.SetState(1698)
			p.ParenthesizedType()
		}

	case 3:
		{
			p.SetState(1699)
			p.NullableType()
		}

	case 4:
		{
			p.SetState(1700)
			p.TypeReference()
		}

	case 5:
		{
			p.SetState(1701)
			p.DefinitelyNonNullableType()
		}

	}

	return localctx
}

// ITypeReferenceContext is an interface to support dynamic dispatch.
type ITypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserType() IUserTypeContext
	DYNAMIC() antlr.TerminalNode

	// IsTypeReferenceContext differentiates from other interfaces.
	IsTypeReferenceContext()
}

type TypeReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeReferenceContext() *TypeReferenceContext {
	var p = new(TypeReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeReference
	return p
}

func (*TypeReferenceContext) IsTypeReferenceContext() {}

func NewTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeReferenceContext {
	var p = new(TypeReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeReference

	return p
}

func (s *TypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeReferenceContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *TypeReferenceContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *TypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeReference(s)
	}
}

func (s *TypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeReference(s)
	}
}

func (p *KotlinParser) TypeReference() (localctx ITypeReferenceContext) {
	this := p
	_ = this

	localctx = NewTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KotlinParserRULE_typeReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1706)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1704)
			p.UserType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1705)
			p.Match(KotlinParserDYNAMIC)
		}

	}

	return localctx
}

// INullableTypeContext is an interface to support dynamic dispatch.
type INullableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeReference() ITypeReferenceContext
	ParenthesizedType() IParenthesizedTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllQuest() []IQuestContext
	Quest(i int) IQuestContext

	// IsNullableTypeContext differentiates from other interfaces.
	IsNullableTypeContext()
}

type NullableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullableTypeContext() *NullableTypeContext {
	var p = new(NullableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_nullableType
	return p
}

func (*NullableTypeContext) IsNullableTypeContext() {}

func NewNullableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullableTypeContext {
	var p = new(NullableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_nullableType

	return p
}

func (s *NullableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NullableTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *NullableTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *NullableTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NullableTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NullableTypeContext) AllQuest() []IQuestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuestContext); ok {
			len++
		}
	}

	tst := make([]IQuestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuestContext); ok {
			tst[i] = t.(IQuestContext)
			i++
		}
	}

	return tst
}

func (s *NullableTypeContext) Quest(i int) IQuestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuestContext)
}

func (s *NullableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNullableType(s)
	}
}

func (s *NullableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNullableType(s)
	}
}

func (p *KotlinParser) NullableType() (localctx INullableTypeContext) {
	this := p
	_ = this

	localctx = NewNullableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KotlinParserRULE_nullableType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1710)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1708)
			p.TypeReference()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1709)
			p.ParenthesizedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1712)
			p.Match(KotlinParserNL)
		}

		p.SetState(1717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1718)
				p.Quest()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1721)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext())
	}

	return localctx
}

// IQuestContext is an interface to support dynamic dispatch.
type IQuestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUEST_NO_WS() antlr.TerminalNode
	QUEST_WS() antlr.TerminalNode

	// IsQuestContext differentiates from other interfaces.
	IsQuestContext()
}

type QuestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuestContext() *QuestContext {
	var p = new(QuestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_quest
	return p
}

func (*QuestContext) IsQuestContext() {}

func NewQuestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuestContext {
	var p = new(QuestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_quest

	return p
}

func (s *QuestContext) GetParser() antlr.Parser { return s.parser }

func (s *QuestContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *QuestContext) QUEST_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_WS, 0)
}

func (s *QuestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterQuest(s)
	}
}

func (s *QuestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitQuest(s)
	}
}

func (p *KotlinParser) Quest() (localctx IQuestContext) {
	this := p
	_ = this

	localctx = NewQuestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KotlinParserRULE_quest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1723)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserQUEST_WS || _la == KotlinParserQUEST_NO_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUserTypeContext is an interface to support dynamic dispatch.
type IUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleUserType() []ISimpleUserTypeContext
	SimpleUserType(i int) ISimpleUserTypeContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsUserTypeContext differentiates from other interfaces.
	IsUserTypeContext()
}

type UserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserTypeContext() *UserTypeContext {
	var p = new(UserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_userType
	return p
}

func (*UserTypeContext) IsUserTypeContext() {}

func NewUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserTypeContext {
	var p = new(UserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_userType

	return p
}

func (s *UserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UserTypeContext) AllSimpleUserType() []ISimpleUserTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleUserTypeContext); ok {
			len++
		}
	}

	tst := make([]ISimpleUserTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleUserTypeContext); ok {
			tst[i] = t.(ISimpleUserTypeContext)
			i++
		}
	}

	return tst
}

func (s *UserTypeContext) SimpleUserType(i int) ISimpleUserTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleUserTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleUserTypeContext)
}

func (s *UserTypeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *UserTypeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *UserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *UserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *UserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUserType(s)
	}
}

func (s *UserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUserType(s)
	}
}

func (p *KotlinParser) UserType() (localctx IUserTypeContext) {
	this := p
	_ = this

	localctx = NewUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KotlinParserRULE_userType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1725)
		p.SimpleUserType()
	}
	p.SetState(1742)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1729)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1726)
					p.Match(KotlinParserNL)
				}

				p.SetState(1731)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1732)
				p.Match(KotlinParserDOT)
			}
			p.SetState(1736)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1733)
					p.Match(KotlinParserNL)
				}

				p.SetState(1738)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1739)
				p.SimpleUserType()
			}

		}
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleUserTypeContext is an interface to support dynamic dispatch.
type ISimpleUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	TypeArguments() ITypeArgumentsContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSimpleUserTypeContext differentiates from other interfaces.
	IsSimpleUserTypeContext()
}

type SimpleUserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleUserTypeContext() *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleUserType
	return p
}

func (*SimpleUserTypeContext) IsSimpleUserTypeContext() {}

func NewSimpleUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleUserType

	return p
}

func (s *SimpleUserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleUserTypeContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleUserTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *SimpleUserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SimpleUserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SimpleUserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleUserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleUserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleUserType(s)
	}
}

func (s *SimpleUserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleUserType(s)
	}
}

func (p *KotlinParser) SimpleUserType() (localctx ISimpleUserTypeContext) {
	this := p
	_ = this

	localctx = NewSimpleUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KotlinParserRULE_simpleUserType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1745)
		p.SimpleIdentifier()
	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
		p.SetState(1749)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1746)
				p.Match(KotlinParserNL)
			}

			p.SetState(1751)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1752)
			p.TypeArguments()
		}

	}

	return localctx
}

// ITypeProjectionContext is an interface to support dynamic dispatch.
type ITypeProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	TypeProjectionModifiers() ITypeProjectionModifiersContext
	MULT() antlr.TerminalNode

	// IsTypeProjectionContext differentiates from other interfaces.
	IsTypeProjectionContext()
}

type TypeProjectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionContext() *TypeProjectionContext {
	var p = new(TypeProjectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjection
	return p
}

func (*TypeProjectionContext) IsTypeProjectionContext() {}

func NewTypeProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionContext {
	var p = new(TypeProjectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjection

	return p
}

func (s *TypeProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeProjectionContext) TypeProjectionModifiers() ITypeProjectionModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeProjectionModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionModifiersContext)
}

func (s *TypeProjectionContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *TypeProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjection(s)
	}
}

func (s *TypeProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjection(s)
	}
}

func (p *KotlinParser) TypeProjection() (localctx ITypeProjectionContext) {
	this := p
	_ = this

	localctx = NewTypeProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KotlinParserRULE_typeProjection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1760)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserIN, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1756)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1755)
				p.TypeProjectionModifiers()
			}

		}
		{
			p.SetState(1758)
			p.Type_()
		}

	case KotlinParserMULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1759)
			p.Match(KotlinParserMULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeProjectionModifiersContext is an interface to support dynamic dispatch.
type ITypeProjectionModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeProjectionModifier() []ITypeProjectionModifierContext
	TypeProjectionModifier(i int) ITypeProjectionModifierContext

	// IsTypeProjectionModifiersContext differentiates from other interfaces.
	IsTypeProjectionModifiersContext()
}

type TypeProjectionModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionModifiersContext() *TypeProjectionModifiersContext {
	var p = new(TypeProjectionModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifiers
	return p
}

func (*TypeProjectionModifiersContext) IsTypeProjectionModifiersContext() {}

func NewTypeProjectionModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionModifiersContext {
	var p = new(TypeProjectionModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjectionModifiers

	return p
}

func (s *TypeProjectionModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionModifiersContext) AllTypeProjectionModifier() []ITypeProjectionModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeProjectionModifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeProjectionModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeProjectionModifierContext); ok {
			tst[i] = t.(ITypeProjectionModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeProjectionModifiersContext) TypeProjectionModifier(i int) ITypeProjectionModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeProjectionModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionModifierContext)
}

func (s *TypeProjectionModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjectionModifiers(s)
	}
}

func (s *TypeProjectionModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjectionModifiers(s)
	}
}

func (p *KotlinParser) TypeProjectionModifiers() (localctx ITypeProjectionModifiersContext) {
	this := p
	_ = this

	localctx = NewTypeProjectionModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KotlinParserRULE_typeProjectionModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1762)
				p.TypeProjectionModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1765)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 256, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeProjectionModifierContext is an interface to support dynamic dispatch.
type ITypeProjectionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarianceModifier() IVarianceModifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	Annotation() IAnnotationContext

	// IsTypeProjectionModifierContext differentiates from other interfaces.
	IsTypeProjectionModifierContext()
}

type TypeProjectionModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionModifierContext() *TypeProjectionModifierContext {
	var p = new(TypeProjectionModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifier
	return p
}

func (*TypeProjectionModifierContext) IsTypeProjectionModifierContext() {}

func NewTypeProjectionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionModifierContext {
	var p = new(TypeProjectionModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjectionModifier

	return p
}

func (s *TypeProjectionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionModifierContext) VarianceModifier() IVarianceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarianceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarianceModifierContext)
}

func (s *TypeProjectionModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeProjectionModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeProjectionModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeProjectionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjectionModifier(s)
	}
}

func (s *TypeProjectionModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjectionModifier(s)
	}
}

func (p *KotlinParser) TypeProjectionModifier() (localctx ITypeProjectionModifierContext) {
	this := p
	_ = this

	localctx = NewTypeProjectionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KotlinParserRULE_typeProjectionModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1775)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserIN, KotlinParserOUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1767)
			p.VarianceModifier()
		}
		p.SetState(1771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1768)
				p.Match(KotlinParserNL)
			}

			p.SetState(1773)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1774)
			p.Annotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionTypeParameters() IFunctionTypeParametersContext
	ARROW() antlr.TerminalNode
	Type_() ITypeContext
	ReceiverType() IReceiverTypeContext
	DOT() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionType
	return p
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FunctionTypeParameters() IFunctionTypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParametersContext)
}

func (s *FunctionTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *FunctionTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionTypeContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *FunctionTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (p *KotlinParser) FunctionType() (localctx IFunctionTypeContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KotlinParserRULE_functionType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 261, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1777)
			p.ReceiverType()
		}
		p.SetState(1781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1778)
				p.Match(KotlinParserNL)
			}

			p.SetState(1783)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1784)
			p.Match(KotlinParserDOT)
		}
		p.SetState(1788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1785)
				p.Match(KotlinParserNL)
			}

			p.SetState(1790)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1793)
		p.FunctionTypeParameters()
	}
	p.SetState(1797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1794)
			p.Match(KotlinParserNL)
		}

		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1800)
		p.Match(KotlinParserARROW)
	}
	p.SetState(1804)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1801)
			p.Match(KotlinParserNL)
		}

		p.SetState(1806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1807)
		p.Type_()
	}

	return localctx
}

// IFunctionTypeParametersContext is an interface to support dynamic dispatch.
type IFunctionTypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionTypeParametersContext differentiates from other interfaces.
	IsFunctionTypeParametersContext()
}

type FunctionTypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParametersContext() *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionTypeParameters
	return p
}

func (*FunctionTypeParametersContext) IsFunctionTypeParametersContext() {}

func NewFunctionTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionTypeParameters

	return p
}

func (s *FunctionTypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionTypeParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionTypeParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionTypeParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionTypeParametersContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionTypeParametersContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionTypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionTypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionTypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionTypeParameters(s)
	}
}

func (s *FunctionTypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionTypeParameters(s)
	}
}

func (p *KotlinParser) FunctionTypeParameters() (localctx IFunctionTypeParametersContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KotlinParserRULE_functionTypeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1809)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1813)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 264, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1810)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 264, p.GetParserRuleContext())
	}
	p.SetState(1818)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1816)
			p.Parameter()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1817)
			p.Type_()
		}

	}
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 269, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1823)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1820)
					p.Match(KotlinParserNL)
				}

				p.SetState(1825)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1826)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1830)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1827)
					p.Match(KotlinParserNL)
				}

				p.SetState(1832)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1835)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 268, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1833)
					p.Parameter()
				}

			case 2:
				{
					p.SetState(1834)
					p.Type_()
				}

			}

		}
		p.SetState(1841)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 269, p.GetParserRuleContext())
	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) == 1 {
		p.SetState(1845)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1842)
				p.Match(KotlinParserNL)
			}

			p.SetState(1847)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1848)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(1854)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1851)
			p.Match(KotlinParserNL)
		}

		p.SetState(1856)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1857)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IParenthesizedTypeContext is an interface to support dynamic dispatch.
type IParenthesizedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Type_() ITypeContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedTypeContext differentiates from other interfaces.
	IsParenthesizedTypeContext()
}

type ParenthesizedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedTypeContext() *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedType
	return p
}

func (*ParenthesizedTypeContext) IsParenthesizedTypeContext() {}

func NewParenthesizedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedType

	return p
}

func (s *ParenthesizedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParenthesizedTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedType(s)
	}
}

func (s *ParenthesizedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedType(s)
	}
}

func (p *KotlinParser) ParenthesizedType() (localctx IParenthesizedTypeContext) {
	this := p
	_ = this

	localctx = NewParenthesizedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KotlinParserRULE_parenthesizedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1859)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1863)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1860)
			p.Match(KotlinParserNL)
		}

		p.SetState(1865)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1866)
		p.Type_()
	}
	p.SetState(1870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1867)
			p.Match(KotlinParserNL)
		}

		p.SetState(1872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1873)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IReceiverTypeContext is an interface to support dynamic dispatch.
type IReceiverTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParenthesizedType() IParenthesizedTypeContext
	NullableType() INullableTypeContext
	TypeReference() ITypeReferenceContext
	TypeModifiers() ITypeModifiersContext

	// IsReceiverTypeContext differentiates from other interfaces.
	IsReceiverTypeContext()
}

type ReceiverTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverTypeContext() *ReceiverTypeContext {
	var p = new(ReceiverTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_receiverType
	return p
}

func (*ReceiverTypeContext) IsReceiverTypeContext() {}

func NewReceiverTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverTypeContext {
	var p = new(ReceiverTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_receiverType

	return p
}

func (s *ReceiverTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *ReceiverTypeContext) NullableType() INullableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *ReceiverTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ReceiverTypeContext) TypeModifiers() ITypeModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *ReceiverTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterReceiverType(s)
	}
}

func (s *ReceiverTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitReceiverType(s)
	}
}

func (p *KotlinParser) ReceiverType() (localctx IReceiverTypeContext) {
	this := p
	_ = this

	localctx = NewReceiverTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, KotlinParserRULE_receiverType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1876)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1875)
			p.TypeModifiers()
		}

	}
	p.SetState(1881)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1878)
			p.ParenthesizedType()
		}

	case 2:
		{
			p.SetState(1879)
			p.NullableType()
		}

	case 3:
		{
			p.SetState(1880)
			p.TypeReference()
		}

	}

	return localctx
}

// IParenthesizedUserTypeContext is an interface to support dynamic dispatch.
type IParenthesizedUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	UserType() IUserTypeContext
	ParenthesizedUserType() IParenthesizedUserTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedUserTypeContext differentiates from other interfaces.
	IsParenthesizedUserTypeContext()
}

type ParenthesizedUserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedUserTypeContext() *ParenthesizedUserTypeContext {
	var p = new(ParenthesizedUserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedUserType
	return p
}

func (*ParenthesizedUserTypeContext) IsParenthesizedUserTypeContext() {}

func NewParenthesizedUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedUserTypeContext {
	var p = new(ParenthesizedUserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedUserType

	return p
}

func (s *ParenthesizedUserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedUserTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedUserTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedUserTypeContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ParenthesizedUserTypeContext) ParenthesizedUserType() IParenthesizedUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedUserTypeContext)
}

func (s *ParenthesizedUserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedUserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedUserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedUserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedUserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedUserType(s)
	}
}

func (s *ParenthesizedUserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedUserType(s)
	}
}

func (p *KotlinParser) ParenthesizedUserType() (localctx IParenthesizedUserTypeContext) {
	this := p
	_ = this

	localctx = NewParenthesizedUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, KotlinParserRULE_parenthesizedUserType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1883)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1884)
			p.Match(KotlinParserNL)
		}

		p.SetState(1889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1892)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1890)
			p.UserType()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1891)
			p.ParenthesizedUserType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1894)
			p.Match(KotlinParserNL)
		}

		p.SetState(1899)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1900)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IDefinitelyNonNullableTypeContext is an interface to support dynamic dispatch.
type IDefinitelyNonNullableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AMP() antlr.TerminalNode
	AllUserType() []IUserTypeContext
	UserType(i int) IUserTypeContext
	AllParenthesizedUserType() []IParenthesizedUserTypeContext
	ParenthesizedUserType(i int) IParenthesizedUserTypeContext
	AllTypeModifiers() []ITypeModifiersContext
	TypeModifiers(i int) ITypeModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDefinitelyNonNullableTypeContext differentiates from other interfaces.
	IsDefinitelyNonNullableTypeContext()
}

type DefinitelyNonNullableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitelyNonNullableTypeContext() *DefinitelyNonNullableTypeContext {
	var p = new(DefinitelyNonNullableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_definitelyNonNullableType
	return p
}

func (*DefinitelyNonNullableTypeContext) IsDefinitelyNonNullableTypeContext() {}

func NewDefinitelyNonNullableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitelyNonNullableTypeContext {
	var p = new(DefinitelyNonNullableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_definitelyNonNullableType

	return p
}

func (s *DefinitelyNonNullableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitelyNonNullableTypeContext) AMP() antlr.TerminalNode {
	return s.GetToken(KotlinParserAMP, 0)
}

func (s *DefinitelyNonNullableTypeContext) AllUserType() []IUserTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserTypeContext); ok {
			len++
		}
	}

	tst := make([]IUserTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserTypeContext); ok {
			tst[i] = t.(IUserTypeContext)
			i++
		}
	}

	return tst
}

func (s *DefinitelyNonNullableTypeContext) UserType(i int) IUserTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *DefinitelyNonNullableTypeContext) AllParenthesizedUserType() []IParenthesizedUserTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParenthesizedUserTypeContext); ok {
			len++
		}
	}

	tst := make([]IParenthesizedUserTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParenthesizedUserTypeContext); ok {
			tst[i] = t.(IParenthesizedUserTypeContext)
			i++
		}
	}

	return tst
}

func (s *DefinitelyNonNullableTypeContext) ParenthesizedUserType(i int) IParenthesizedUserTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedUserTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedUserTypeContext)
}

func (s *DefinitelyNonNullableTypeContext) AllTypeModifiers() []ITypeModifiersContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			len++
		}
	}

	tst := make([]ITypeModifiersContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeModifiersContext); ok {
			tst[i] = t.(ITypeModifiersContext)
			i++
		}
	}

	return tst
}

func (s *DefinitelyNonNullableTypeContext) TypeModifiers(i int) ITypeModifiersContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *DefinitelyNonNullableTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DefinitelyNonNullableTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DefinitelyNonNullableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitelyNonNullableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitelyNonNullableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDefinitelyNonNullableType(s)
	}
}

func (s *DefinitelyNonNullableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDefinitelyNonNullableType(s)
	}
}

func (p *KotlinParser) DefinitelyNonNullableType() (localctx IDefinitelyNonNullableTypeContext) {
	this := p
	_ = this

	localctx = NewDefinitelyNonNullableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, KotlinParserRULE_definitelyNonNullableType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1902)
			p.TypeModifiers()
		}

	}
	p.SetState(1907)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1905)
			p.UserType()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1906)
			p.ParenthesizedUserType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1909)
			p.Match(KotlinParserNL)
		}

		p.SetState(1914)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1915)
		p.Match(KotlinParserAMP)
	}
	p.SetState(1919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1916)
			p.Match(KotlinParserNL)
		}

		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1923)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1922)
			p.TypeModifiers()
		}

	}
	p.SetState(1927)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1925)
			p.UserType()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1926)
			p.ParenthesizedUserType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSemis() []ISemisContext
	Semis(i int) ISemisContext

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSemis() []ISemisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISemisContext); ok {
			len++
		}
	}

	tst := make([]ISemisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISemisContext); ok {
			tst[i] = t.(ISemisContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Semis(i int) ISemisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *KotlinParser) Statements() (localctx IStatementsContext) {
	this := p
	_ = this

	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, KotlinParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-144109553024488960) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4260645306497) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&13629951) != 0) {
		{
			p.SetState(1929)
			p.Statement()
		}
		p.SetState(1935)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 286, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1930)
					p.Semis()
				}
				{
					p.SetState(1931)
					p.Statement()
				}

			}
			p.SetState(1937)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 286, p.GetParserRuleContext())
		}

	}
	p.SetState(1941)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 288, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1940)
			p.Semis()
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	Assignment() IAssignmentContext
	LoopStatement() ILoopStatementContext
	Expression() IExpressionContext
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StatementContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *StatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *KotlinParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, KotlinParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1947)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1945)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
				{
					p.SetState(1943)
					p.Label()
				}

			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(1944)
					p.Annotation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1949)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())
	}
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 291, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1950)
			p.Declaration()
		}

	case 2:
		{
			p.SetState(1951)
			p.Assignment()
		}

	case 3:
		{
			p.SetState(1952)
			p.LoopStatement()
		}

	case 4:
		{
			p.SetState(1953)
			p.Expression()
		}

	}

	return localctx
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	AT_NO_WS() antlr.TerminalNode
	AT_POST_WS() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_label
	return p
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *LabelContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *LabelContext) AT_POST_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_POST_WS, 0)
}

func (s *LabelContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LabelContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *KotlinParser) Label() (localctx ILabelContext) {
	this := p
	_ = this

	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, KotlinParserRULE_label)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1956)
		p.SimpleIdentifier()
	}
	{
		p.SetState(1957)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_POST_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1958)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1963)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())
	}

	return localctx
}

// IControlStructureBodyContext is an interface to support dynamic dispatch.
type IControlStructureBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	Statement() IStatementContext

	// IsControlStructureBodyContext differentiates from other interfaces.
	IsControlStructureBodyContext()
}

type ControlStructureBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlStructureBodyContext() *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_controlStructureBody
	return p
}

func (*ControlStructureBodyContext) IsControlStructureBodyContext() {}

func NewControlStructureBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_controlStructureBody

	return p
}

func (s *ControlStructureBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ControlStructureBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ControlStructureBodyContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ControlStructureBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ControlStructureBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ControlStructureBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterControlStructureBody(s)
	}
}

func (s *ControlStructureBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitControlStructureBody(s)
	}
}

func (p *KotlinParser) ControlStructureBody() (localctx IControlStructureBodyContext) {
	this := p
	_ = this

	localctx = NewControlStructureBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, KotlinParserRULE_controlStructureBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1966)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1964)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1965)
			p.Statement()
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	Statements() IStatementsContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *BlockContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *BlockContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *BlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *BlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *KotlinParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, KotlinParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1968)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(1972)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 294, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1969)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1974)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 294, p.GetParserRuleContext())
	}
	{
		p.SetState(1975)
		p.Statements()
	}
	p.SetState(1979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1976)
			p.Match(KotlinParserNL)
		}

		p.SetState(1981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1982)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForStatement() IForStatementContext
	WhileStatement() IWhileStatementContext
	DoWhileStatement() IDoWhileStatementContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_loopStatement
	return p
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *LoopStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *LoopStatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (p *KotlinParser) LoopStatement() (localctx ILoopStatementContext) {
	this := p
	_ = this

	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, KotlinParserRULE_loopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1987)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1984)
			p.ForStatement()
		}

	case KotlinParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1985)
			p.WhileStatement()
		}

	case KotlinParserDO:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1986)
			p.DoWhileStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	VariableDeclaration() IVariableDeclarationContext
	MultiVariableDeclaration() IMultiVariableDeclarationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	ControlStructureBody() IControlStructureBodyContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserFOR, 0)
}

func (s *ForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ForStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForStatementContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *ForStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ForStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ForStatementContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ForStatementContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ForStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *KotlinParser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, KotlinParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1989)
		p.Match(KotlinParserFOR)
	}
	p.SetState(1993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1990)
			p.Match(KotlinParserNL)
		}

		p.SetState(1995)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1996)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1997)
				p.Annotation()
			}

		}
		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext())
	}
	p.SetState(2005)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(2003)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(2004)
			p.MultiVariableDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2007)
		p.Match(KotlinParserIN)
	}
	{
		p.SetState(2008)
		p.Expression()
	}
	{
		p.SetState(2009)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2013)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 300, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2010)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2015)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 300, p.GetParserRuleContext())
	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 301, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2016)
			p.ControlStructureBody()
		}

	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	ControlStructureBody() IControlStructureBodyContext
	SEMICOLON() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *WhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhileStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhileStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *WhileStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhileStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *KotlinParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, KotlinParserRULE_whileStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2019)
		p.Match(KotlinParserWHILE)
	}
	p.SetState(2023)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2020)
			p.Match(KotlinParserNL)
		}

		p.SetState(2025)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2026)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(2027)
		p.Expression()
	}
	{
		p.SetState(2028)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2029)
			p.Match(KotlinParserNL)
		}

		p.SetState(2034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		{
			p.SetState(2035)
			p.ControlStructureBody()
		}

	case KotlinParserSEMICOLON:
		{
			p.SetState(2036)
			p.Match(KotlinParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	ControlStructureBody() IControlStructureBodyContext

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_doWhileStatement
	return p
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(KotlinParserDO, 0)
}

func (s *DoWhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *DoWhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *DoWhileStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DoWhileStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DoWhileStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (p *KotlinParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	this := p
	_ = this

	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, KotlinParserRULE_doWhileStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2039)
		p.Match(KotlinParserDO)
	}
	p.SetState(2043)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 305, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2040)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2045)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 305, p.GetParserRuleContext())
	}
	p.SetState(2047)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2046)
			p.ControlStructureBody()
		}

	}
	p.SetState(2052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2049)
			p.Match(KotlinParserNL)
		}

		p.SetState(2054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2055)
		p.Match(KotlinParserWHILE)
	}
	p.SetState(2059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2056)
			p.Match(KotlinParserNL)
		}

		p.SetState(2061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2062)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(2063)
		p.Expression()
	}
	{
		p.SetState(2064)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DirectlyAssignableExpression() IDirectlyAssignableExpressionContext
	ASSIGNMENT() antlr.TerminalNode
	AssignableExpression() IAssignableExpressionContext
	AssignmentAndOperator() IAssignmentAndOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) DirectlyAssignableExpression() IDirectlyAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectlyAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectlyAssignableExpressionContext)
}

func (s *AssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *AssignmentContext) AssignableExpression() IAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *AssignmentContext) AssignmentAndOperator() IAssignmentAndOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentAndOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentAndOperatorContext)
}

func (s *AssignmentContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AssignmentContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *KotlinParser) Assignment() (localctx IAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, KotlinParserRULE_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2072)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 309, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2066)
			p.DirectlyAssignableExpression()
		}
		{
			p.SetState(2067)
			p.Match(KotlinParserASSIGNMENT)
		}

	case 2:
		{
			p.SetState(2069)
			p.AssignableExpression()
		}
		{
			p.SetState(2070)
			p.AssignmentAndOperator()
		}

	}
	p.SetState(2077)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2074)
			p.Match(KotlinParserNL)
		}

		p.SetState(2079)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2080)
		p.Expression()
	}

	return localctx
}

// ISemiContext is an interface to support dynamic dispatch.
type ISemiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSemiContext differentiates from other interfaces.
	IsSemiContext()
}

type SemiContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemiContext() *SemiContext {
	var p = new(SemiContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_semi
	return p
}

func (*SemiContext) IsSemiContext() {}

func NewSemiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemiContext {
	var p = new(SemiContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_semi

	return p
}

func (s *SemiContext) GetParser() antlr.Parser { return s.parser }

func (s *SemiContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *SemiContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SemiContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SemiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSemi(s)
	}
}

func (s *SemiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSemi(s)
	}
}

func (p *KotlinParser) Semi() (localctx ISemiContext) {
	this := p
	_ = this

	localctx = NewSemiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, KotlinParserRULE_semi)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2082)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserNL || _la == KotlinParserSEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2086)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 311, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2083)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2088)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 311, p.GetParserRuleContext())
	}

	return localctx
}

// ISemisContext is an interface to support dynamic dispatch.
type ISemisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSemisContext differentiates from other interfaces.
	IsSemisContext()
}

type SemisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemisContext() *SemisContext {
	var p = new(SemisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_semis
	return p
}

func (*SemisContext) IsSemisContext() {}

func NewSemisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemisContext {
	var p = new(SemisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_semis

	return p
}

func (s *SemisContext) GetParser() antlr.Parser { return s.parser }

func (s *SemisContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserSEMICOLON)
}

func (s *SemisContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, i)
}

func (s *SemisContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SemisContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SemisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSemis(s)
	}
}

func (s *SemisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSemis(s)
	}
}

func (p *KotlinParser) Semis() (localctx ISemisContext) {
	this := p
	_ = this

	localctx = NewSemisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, KotlinParserRULE_semis)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2090)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2089)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KotlinParserNL || _la == KotlinParserSEMICOLON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2092)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 312, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Disjunction() IDisjunctionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Disjunction() IDisjunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisjunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisjunctionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *KotlinParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, KotlinParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2094)
		p.Disjunction()
	}

	return localctx
}

// IDisjunctionContext is an interface to support dynamic dispatch.
type IDisjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConjunction() []IConjunctionContext
	Conjunction(i int) IConjunctionContext
	AllDISJ() []antlr.TerminalNode
	DISJ(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDisjunctionContext differentiates from other interfaces.
	IsDisjunctionContext()
}

type DisjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionContext() *DisjunctionContext {
	var p = new(DisjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_disjunction
	return p
}

func (*DisjunctionContext) IsDisjunctionContext() {}

func NewDisjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionContext {
	var p = new(DisjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_disjunction

	return p
}

func (s *DisjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionContext) AllConjunction() []IConjunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConjunctionContext); ok {
			len++
		}
	}

	tst := make([]IConjunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConjunctionContext); ok {
			tst[i] = t.(IConjunctionContext)
			i++
		}
	}

	return tst
}

func (s *DisjunctionContext) Conjunction(i int) IConjunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConjunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConjunctionContext)
}

func (s *DisjunctionContext) AllDISJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDISJ)
}

func (s *DisjunctionContext) DISJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDISJ, i)
}

func (s *DisjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DisjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DisjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDisjunction(s)
	}
}

func (s *DisjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDisjunction(s)
	}
}

func (p *KotlinParser) Disjunction() (localctx IDisjunctionContext) {
	this := p
	_ = this

	localctx = NewDisjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, KotlinParserRULE_disjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2096)
		p.Conjunction()
	}
	p.SetState(2113)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2100)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2097)
					p.Match(KotlinParserNL)
				}

				p.SetState(2102)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2103)
				p.Match(KotlinParserDISJ)
			}
			p.SetState(2107)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2104)
					p.Match(KotlinParserNL)
				}

				p.SetState(2109)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2110)
				p.Conjunction()
			}

		}
		p.SetState(2115)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext())
	}

	return localctx
}

// IConjunctionContext is an interface to support dynamic dispatch.
type IConjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEquality() []IEqualityContext
	Equality(i int) IEqualityContext
	AllCONJ() []antlr.TerminalNode
	CONJ(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsConjunctionContext differentiates from other interfaces.
	IsConjunctionContext()
}

type ConjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionContext() *ConjunctionContext {
	var p = new(ConjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_conjunction
	return p
}

func (*ConjunctionContext) IsConjunctionContext() {}

func NewConjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionContext {
	var p = new(ConjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_conjunction

	return p
}

func (s *ConjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionContext) AllEquality() []IEqualityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityContext); ok {
			len++
		}
	}

	tst := make([]IEqualityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityContext); ok {
			tst[i] = t.(IEqualityContext)
			i++
		}
	}

	return tst
}

func (s *ConjunctionContext) Equality(i int) IEqualityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityContext)
}

func (s *ConjunctionContext) AllCONJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCONJ)
}

func (s *ConjunctionContext) CONJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCONJ, i)
}

func (s *ConjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConjunction(s)
	}
}

func (s *ConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConjunction(s)
	}
}

func (p *KotlinParser) Conjunction() (localctx IConjunctionContext) {
	this := p
	_ = this

	localctx = NewConjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, KotlinParserRULE_conjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2116)
		p.Equality()
	}
	p.SetState(2133)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2120)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2117)
					p.Match(KotlinParserNL)
				}

				p.SetState(2122)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2123)
				p.Match(KotlinParserCONJ)
			}
			p.SetState(2127)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2124)
					p.Match(KotlinParserNL)
				}

				p.SetState(2129)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2130)
				p.Equality()
			}

		}
		p.SetState(2135)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())
	}

	return localctx
}

// IEqualityContext is an interface to support dynamic dispatch.
type IEqualityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComparison() []IComparisonContext
	Comparison(i int) IComparisonContext
	AllEqualityOperator() []IEqualityOperatorContext
	EqualityOperator(i int) IEqualityOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsEqualityContext differentiates from other interfaces.
	IsEqualityContext()
}

type EqualityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityContext() *EqualityContext {
	var p = new(EqualityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_equality
	return p
}

func (*EqualityContext) IsEqualityContext() {}

func NewEqualityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityContext {
	var p = new(EqualityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equality

	return p
}

func (s *EqualityContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityContext) AllComparison() []IComparisonContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonContext); ok {
			len++
		}
	}

	tst := make([]IComparisonContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonContext); ok {
			tst[i] = t.(IComparisonContext)
			i++
		}
	}

	return tst
}

func (s *EqualityContext) Comparison(i int) IComparisonContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *EqualityContext) AllEqualityOperator() []IEqualityOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityOperatorContext); ok {
			len++
		}
	}

	tst := make([]IEqualityOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityOperatorContext); ok {
			tst[i] = t.(IEqualityOperatorContext)
			i++
		}
	}

	return tst
}

func (s *EqualityContext) EqualityOperator(i int) IEqualityOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityOperatorContext)
}

func (s *EqualityContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EqualityContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EqualityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEquality(s)
	}
}

func (s *EqualityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEquality(s)
	}
}

func (p *KotlinParser) Equality() (localctx IEqualityContext) {
	this := p
	_ = this

	localctx = NewEqualityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, KotlinParserRULE_equality)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2136)
		p.Comparison()
	}
	p.SetState(2148)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 320, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2137)
				p.EqualityOperator()
			}
			p.SetState(2141)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2138)
					p.Match(KotlinParserNL)
				}

				p.SetState(2143)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2144)
				p.Comparison()
			}

		}
		p.SetState(2150)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 320, p.GetParserRuleContext())
	}

	return localctx
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericCallLikeComparison() []IGenericCallLikeComparisonContext
	GenericCallLikeComparison(i int) IGenericCallLikeComparisonContext
	AllComparisonOperator() []IComparisonOperatorContext
	ComparisonOperator(i int) IComparisonOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllGenericCallLikeComparison() []IGenericCallLikeComparisonContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericCallLikeComparisonContext); ok {
			len++
		}
	}

	tst := make([]IGenericCallLikeComparisonContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericCallLikeComparisonContext); ok {
			tst[i] = t.(IGenericCallLikeComparisonContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) GenericCallLikeComparison(i int) IGenericCallLikeComparisonContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericCallLikeComparisonContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericCallLikeComparisonContext)
}

func (s *ComparisonContext) AllComparisonOperator() []IComparisonOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			len++
		}
	}

	tst := make([]IComparisonOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonOperatorContext); ok {
			tst[i] = t.(IComparisonOperatorContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ComparisonOperator(i int) IComparisonOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ComparisonContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *KotlinParser) Comparison() (localctx IComparisonContext) {
	this := p
	_ = this

	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, KotlinParserRULE_comparison)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2151)
		p.GenericCallLikeComparison()
	}
	p.SetState(2163)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 322, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2152)
				p.ComparisonOperator()
			}
			p.SetState(2156)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2153)
					p.Match(KotlinParserNL)
				}

				p.SetState(2158)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2159)
				p.GenericCallLikeComparison()
			}

		}
		p.SetState(2165)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 322, p.GetParserRuleContext())
	}

	return localctx
}

// IGenericCallLikeComparisonContext is an interface to support dynamic dispatch.
type IGenericCallLikeComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InfixOperation() IInfixOperationContext
	AllCallSuffix() []ICallSuffixContext
	CallSuffix(i int) ICallSuffixContext

	// IsGenericCallLikeComparisonContext differentiates from other interfaces.
	IsGenericCallLikeComparisonContext()
}

type GenericCallLikeComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericCallLikeComparisonContext() *GenericCallLikeComparisonContext {
	var p = new(GenericCallLikeComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_genericCallLikeComparison
	return p
}

func (*GenericCallLikeComparisonContext) IsGenericCallLikeComparisonContext() {}

func NewGenericCallLikeComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericCallLikeComparisonContext {
	var p = new(GenericCallLikeComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_genericCallLikeComparison

	return p
}

func (s *GenericCallLikeComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericCallLikeComparisonContext) InfixOperation() IInfixOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInfixOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInfixOperationContext)
}

func (s *GenericCallLikeComparisonContext) AllCallSuffix() []ICallSuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallSuffixContext); ok {
			len++
		}
	}

	tst := make([]ICallSuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallSuffixContext); ok {
			tst[i] = t.(ICallSuffixContext)
			i++
		}
	}

	return tst
}

func (s *GenericCallLikeComparisonContext) CallSuffix(i int) ICallSuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *GenericCallLikeComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericCallLikeComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericCallLikeComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterGenericCallLikeComparison(s)
	}
}

func (s *GenericCallLikeComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitGenericCallLikeComparison(s)
	}
}

func (p *KotlinParser) GenericCallLikeComparison() (localctx IGenericCallLikeComparisonContext) {
	this := p
	_ = this

	localctx = NewGenericCallLikeComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, KotlinParserRULE_genericCallLikeComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2166)
		p.InfixOperation()
	}
	p.SetState(2170)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2167)
				p.CallSuffix()
			}

		}
		p.SetState(2172)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())
	}

	return localctx
}

// IInfixOperationContext is an interface to support dynamic dispatch.
type IInfixOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElvisExpression() []IElvisExpressionContext
	ElvisExpression(i int) IElvisExpressionContext
	AllInOperator() []IInOperatorContext
	InOperator(i int) IInOperatorContext
	AllIsOperator() []IIsOperatorContext
	IsOperator(i int) IIsOperatorContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsInfixOperationContext differentiates from other interfaces.
	IsInfixOperationContext()
}

type InfixOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixOperationContext() *InfixOperationContext {
	var p = new(InfixOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_infixOperation
	return p
}

func (*InfixOperationContext) IsInfixOperationContext() {}

func NewInfixOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixOperationContext {
	var p = new(InfixOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_infixOperation

	return p
}

func (s *InfixOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixOperationContext) AllElvisExpression() []IElvisExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElvisExpressionContext); ok {
			len++
		}
	}

	tst := make([]IElvisExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElvisExpressionContext); ok {
			tst[i] = t.(IElvisExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) ElvisExpression(i int) IElvisExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElvisExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElvisExpressionContext)
}

func (s *InfixOperationContext) AllInOperator() []IInOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInOperatorContext); ok {
			len++
		}
	}

	tst := make([]IInOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInOperatorContext); ok {
			tst[i] = t.(IInOperatorContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) InOperator(i int) IInOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *InfixOperationContext) AllIsOperator() []IIsOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIsOperatorContext); ok {
			len++
		}
	}

	tst := make([]IIsOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIsOperatorContext); ok {
			tst[i] = t.(IIsOperatorContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) IsOperator(i int) IIsOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *InfixOperationContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *InfixOperationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *InfixOperationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *InfixOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInfixOperation(s)
	}
}

func (s *InfixOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInfixOperation(s)
	}
}

func (p *KotlinParser) InfixOperation() (localctx IInfixOperationContext) {
	this := p
	_ = this

	localctx = NewInfixOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, KotlinParserRULE_infixOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2173)
		p.ElvisExpression()
	}
	p.SetState(2194)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2192)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserIN, KotlinParserNOT_IN:
				{
					p.SetState(2174)
					p.InOperator()
				}
				p.SetState(2178)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2175)
						p.Match(KotlinParserNL)
					}

					p.SetState(2180)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2181)
					p.ElvisExpression()
				}

			case KotlinParserIS, KotlinParserNOT_IS:
				{
					p.SetState(2183)
					p.IsOperator()
				}
				p.SetState(2187)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2184)
						p.Match(KotlinParserNL)
					}

					p.SetState(2189)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2190)
					p.Type_()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(2196)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())
	}

	return localctx
}

// IElvisExpressionContext is an interface to support dynamic dispatch.
type IElvisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInfixFunctionCall() []IInfixFunctionCallContext
	InfixFunctionCall(i int) IInfixFunctionCallContext
	AllElvis() []IElvisContext
	Elvis(i int) IElvisContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsElvisExpressionContext differentiates from other interfaces.
	IsElvisExpressionContext()
}

type ElvisExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElvisExpressionContext() *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_elvisExpression
	return p
}

func (*ElvisExpressionContext) IsElvisExpressionContext() {}

func NewElvisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_elvisExpression

	return p
}

func (s *ElvisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ElvisExpressionContext) AllInfixFunctionCall() []IInfixFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInfixFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IInfixFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInfixFunctionCallContext); ok {
			tst[i] = t.(IInfixFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *ElvisExpressionContext) InfixFunctionCall(i int) IInfixFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInfixFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInfixFunctionCallContext)
}

func (s *ElvisExpressionContext) AllElvis() []IElvisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElvisContext); ok {
			len++
		}
	}

	tst := make([]IElvisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElvisContext); ok {
			tst[i] = t.(IElvisContext)
			i++
		}
	}

	return tst
}

func (s *ElvisExpressionContext) Elvis(i int) IElvisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElvisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElvisContext)
}

func (s *ElvisExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ElvisExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ElvisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElvisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElvisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterElvisExpression(s)
	}
}

func (s *ElvisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitElvisExpression(s)
	}
}

func (p *KotlinParser) ElvisExpression() (localctx IElvisExpressionContext) {
	this := p
	_ = this

	localctx = NewElvisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, KotlinParserRULE_elvisExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2197)
		p.InfixFunctionCall()
	}
	p.SetState(2215)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2201)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2198)
					p.Match(KotlinParserNL)
				}

				p.SetState(2203)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2204)
				p.Elvis()
			}
			p.SetState(2208)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2205)
					p.Match(KotlinParserNL)
				}

				p.SetState(2210)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2211)
				p.InfixFunctionCall()
			}

		}
		p.SetState(2217)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())
	}

	return localctx
}

// IElvisContext is an interface to support dynamic dispatch.
type IElvisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUEST_NO_WS() antlr.TerminalNode
	COLON() antlr.TerminalNode

	// IsElvisContext differentiates from other interfaces.
	IsElvisContext()
}

type ElvisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElvisContext() *ElvisContext {
	var p = new(ElvisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_elvis
	return p
}

func (*ElvisContext) IsElvisContext() {}

func NewElvisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElvisContext {
	var p = new(ElvisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_elvis

	return p
}

func (s *ElvisContext) GetParser() antlr.Parser { return s.parser }

func (s *ElvisContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *ElvisContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ElvisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElvisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElvisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterElvis(s)
	}
}

func (s *ElvisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitElvis(s)
	}
}

func (p *KotlinParser) Elvis() (localctx IElvisContext) {
	this := p
	_ = this

	localctx = NewElvisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, KotlinParserRULE_elvis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2218)
		p.Match(KotlinParserQUEST_NO_WS)
	}
	{
		p.SetState(2219)
		p.Match(KotlinParserCOLON)
	}

	return localctx
}

// IInfixFunctionCallContext is an interface to support dynamic dispatch.
type IInfixFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRangeExpression() []IRangeExpressionContext
	RangeExpression(i int) IRangeExpressionContext
	AllSimpleIdentifier() []ISimpleIdentifierContext
	SimpleIdentifier(i int) ISimpleIdentifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsInfixFunctionCallContext differentiates from other interfaces.
	IsInfixFunctionCallContext()
}

type InfixFunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixFunctionCallContext() *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_infixFunctionCall
	return p
}

func (*InfixFunctionCallContext) IsInfixFunctionCallContext() {}

func NewInfixFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_infixFunctionCall

	return p
}

func (s *InfixFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixFunctionCallContext) AllRangeExpression() []IRangeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRangeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeExpressionContext); ok {
			tst[i] = t.(IRangeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) RangeExpression(i int) IRangeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *InfixFunctionCallContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdentifierContext); ok {
			tst[i] = t.(ISimpleIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *InfixFunctionCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *InfixFunctionCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *InfixFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInfixFunctionCall(s)
	}
}

func (s *InfixFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInfixFunctionCall(s)
	}
}

func (p *KotlinParser) InfixFunctionCall() (localctx IInfixFunctionCallContext) {
	this := p
	_ = this

	localctx = NewInfixFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, KotlinParserRULE_infixFunctionCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2221)
		p.RangeExpression()
	}
	p.SetState(2233)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2222)
				p.SimpleIdentifier()
			}
			p.SetState(2226)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2223)
					p.Match(KotlinParserNL)
				}

				p.SetState(2228)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2229)
				p.RangeExpression()
			}

		}
		p.SetState(2235)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())
	}

	return localctx
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdditiveExpression() []IAdditiveExpressionContext
	AdditiveExpression(i int) IAdditiveExpressionContext
	AllRANGE() []antlr.TerminalNode
	RANGE(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeExpression
	return p
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExpressionContext); ok {
			tst[i] = t.(IAdditiveExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RangeExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *RangeExpressionContext) AllRANGE() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserRANGE)
}

func (s *RangeExpressionContext) RANGE(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGE, i)
}

func (s *RangeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeExpression(s)
	}
}

func (s *RangeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeExpression(s)
	}
}

func (p *KotlinParser) RangeExpression() (localctx IRangeExpressionContext) {
	this := p
	_ = this

	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, KotlinParserRULE_rangeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2236)
		p.AdditiveExpression()
	}
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2237)
				p.Match(KotlinParserRANGE)
			}
			p.SetState(2241)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2238)
					p.Match(KotlinParserNL)
				}

				p.SetState(2243)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2244)
				p.AdditiveExpression()
			}

		}
		p.SetState(2249)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext())
	}

	return localctx
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpression() []IMultiplicativeExpressionContext
	MultiplicativeExpression(i int) IMultiplicativeExpressionContext
	AllAdditiveOperator() []IAdditiveOperatorContext
	AdditiveOperator(i int) IAdditiveOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveExpression
	return p
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExpressionContext); ok {
			tst[i] = t.(IMultiplicativeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllAdditiveOperator() []IAdditiveOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveOperatorContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveOperatorContext); ok {
			tst[i] = t.(IAdditiveOperatorContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) AdditiveOperator(i int) IAdditiveOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveOperatorContext)
}

func (s *AdditiveExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AdditiveExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *KotlinParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	this := p
	_ = this

	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, KotlinParserRULE_additiveExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2250)
		p.MultiplicativeExpression()
	}
	p.SetState(2262)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 336, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2251)
				p.AdditiveOperator()
			}
			p.SetState(2255)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2252)
					p.Match(KotlinParserNL)
				}

				p.SetState(2257)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2258)
				p.MultiplicativeExpression()
			}

		}
		p.SetState(2264)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 336, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAsExpression() []IAsExpressionContext
	AsExpression(i int) IAsExpressionContext
	AllMultiplicativeOperator() []IMultiplicativeOperatorContext
	MultiplicativeOperator(i int) IMultiplicativeOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression
	return p
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllAsExpression() []IAsExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAsExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsExpressionContext); ok {
			tst[i] = t.(IAsExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) AsExpression(i int) IAsExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsExpressionContext)
}

func (s *MultiplicativeExpressionContext) AllMultiplicativeOperator() []IMultiplicativeOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeOperatorContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeOperatorContext); ok {
			tst[i] = t.(IMultiplicativeOperatorContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) MultiplicativeOperator(i int) IMultiplicativeOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeOperatorContext)
}

func (s *MultiplicativeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiplicativeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *KotlinParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	this := p
	_ = this

	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, KotlinParserRULE_multiplicativeExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2265)
		p.AsExpression()
	}
	p.SetState(2277)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 338, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2266)
				p.MultiplicativeOperator()
			}
			p.SetState(2270)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2267)
					p.Match(KotlinParserNL)
				}

				p.SetState(2272)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2273)
				p.AsExpression()
			}

		}
		p.SetState(2279)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 338, p.GetParserRuleContext())
	}

	return localctx
}

// IAsExpressionContext is an interface to support dynamic dispatch.
type IAsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrefixUnaryExpression() IPrefixUnaryExpressionContext
	AllAsOperator() []IAsOperatorContext
	AsOperator(i int) IAsOperatorContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAsExpressionContext differentiates from other interfaces.
	IsAsExpressionContext()
}

type AsExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsExpressionContext() *AsExpressionContext {
	var p = new(AsExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_asExpression
	return p
}

func (*AsExpressionContext) IsAsExpressionContext() {}

func NewAsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsExpressionContext {
	var p = new(AsExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_asExpression

	return p
}

func (s *AsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsExpressionContext) PrefixUnaryExpression() IPrefixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryExpressionContext)
}

func (s *AsExpressionContext) AllAsOperator() []IAsOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsOperatorContext); ok {
			len++
		}
	}

	tst := make([]IAsOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsOperatorContext); ok {
			tst[i] = t.(IAsOperatorContext)
			i++
		}
	}

	return tst
}

func (s *AsExpressionContext) AsOperator(i int) IAsOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsOperatorContext)
}

func (s *AsExpressionContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *AsExpressionContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AsExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AsExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAsExpression(s)
	}
}

func (s *AsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAsExpression(s)
	}
}

func (p *KotlinParser) AsExpression() (localctx IAsExpressionContext) {
	this := p
	_ = this

	localctx = NewAsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, KotlinParserRULE_asExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2280)
		p.PrefixUnaryExpression()
	}
	p.SetState(2298)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 341, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2284)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2281)
					p.Match(KotlinParserNL)
				}

				p.SetState(2286)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2287)
				p.AsOperator()
			}
			p.SetState(2291)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2288)
					p.Match(KotlinParserNL)
				}

				p.SetState(2293)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2294)
				p.Type_()
			}

		}
		p.SetState(2300)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 341, p.GetParserRuleContext())
	}

	return localctx
}

// IPrefixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPrefixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixUnaryExpression() IPostfixUnaryExpressionContext
	AllUnaryPrefix() []IUnaryPrefixContext
	UnaryPrefix(i int) IUnaryPrefixContext

	// IsPrefixUnaryExpressionContext differentiates from other interfaces.
	IsPrefixUnaryExpressionContext()
}

type PrefixUnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryExpressionContext() *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression
	return p
}

func (*PrefixUnaryExpressionContext) IsPrefixUnaryExpressionContext() {}

func NewPrefixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression

	return p
}

func (s *PrefixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryExpressionContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *PrefixUnaryExpressionContext) AllUnaryPrefix() []IUnaryPrefixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryPrefixContext); ok {
			len++
		}
	}

	tst := make([]IUnaryPrefixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryPrefixContext); ok {
			tst[i] = t.(IUnaryPrefixContext)
			i++
		}
	}

	return tst
}

func (s *PrefixUnaryExpressionContext) UnaryPrefix(i int) IUnaryPrefixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryPrefixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryPrefixContext)
}

func (s *PrefixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryExpression(s)
	}
}

func (s *PrefixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryExpression(s)
	}
}

func (p *KotlinParser) PrefixUnaryExpression() (localctx IPrefixUnaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPrefixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, KotlinParserRULE_prefixUnaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2304)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 342, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2301)
				p.UnaryPrefix()
			}

		}
		p.SetState(2306)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 342, p.GetParserRuleContext())
	}
	{
		p.SetState(2307)
		p.PostfixUnaryExpression()
	}

	return localctx
}

// IUnaryPrefixContext is an interface to support dynamic dispatch.
type IUnaryPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	Label() ILabelContext
	PrefixUnaryOperator() IPrefixUnaryOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsUnaryPrefixContext differentiates from other interfaces.
	IsUnaryPrefixContext()
}

type UnaryPrefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryPrefixContext() *UnaryPrefixContext {
	var p = new(UnaryPrefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_unaryPrefix
	return p
}

func (*UnaryPrefixContext) IsUnaryPrefixContext() {}

func NewUnaryPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryPrefixContext {
	var p = new(UnaryPrefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_unaryPrefix

	return p
}

func (s *UnaryPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryPrefixContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnaryPrefixContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *UnaryPrefixContext) PrefixUnaryOperator() IPrefixUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryOperatorContext)
}

func (s *UnaryPrefixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *UnaryPrefixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *UnaryPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUnaryPrefix(s)
	}
}

func (s *UnaryPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUnaryPrefix(s)
	}
}

func (p *KotlinParser) UnaryPrefix() (localctx IUnaryPrefixContext) {
	this := p
	_ = this

	localctx = NewUnaryPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, KotlinParserRULE_unaryPrefix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2318)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2309)
			p.Annotation()
		}

	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2310)
			p.Label()
		}

	case KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2311)
			p.PrefixUnaryOperator()
		}
		p.SetState(2315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2312)
				p.Match(KotlinParserNL)
			}

			p.SetState(2317)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPostfixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPostfixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	AllPostfixUnarySuffix() []IPostfixUnarySuffixContext
	PostfixUnarySuffix(i int) IPostfixUnarySuffixContext

	// IsPostfixUnaryExpressionContext differentiates from other interfaces.
	IsPostfixUnaryExpressionContext()
}

type PostfixUnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryExpressionContext() *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression
	return p
}

func (*PostfixUnaryExpressionContext) IsPostfixUnaryExpressionContext() {}

func NewPostfixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression

	return p
}

func (s *PostfixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixUnaryExpressionContext) AllPostfixUnarySuffix() []IPostfixUnarySuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixUnarySuffixContext); ok {
			len++
		}
	}

	tst := make([]IPostfixUnarySuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixUnarySuffixContext); ok {
			tst[i] = t.(IPostfixUnarySuffixContext)
			i++
		}
	}

	return tst
}

func (s *PostfixUnaryExpressionContext) PostfixUnarySuffix(i int) IPostfixUnarySuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnarySuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnarySuffixContext)
}

func (s *PostfixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryExpression(s)
	}
}

func (s *PostfixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryExpression(s)
	}
}

func (p *KotlinParser) PostfixUnaryExpression() (localctx IPostfixUnaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPostfixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, KotlinParserRULE_postfixUnaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2320)
		p.PrimaryExpression()
	}
	p.SetState(2324)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 345, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2321)
				p.PostfixUnarySuffix()
			}

		}
		p.SetState(2326)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 345, p.GetParserRuleContext())
	}

	return localctx
}

// IPostfixUnarySuffixContext is an interface to support dynamic dispatch.
type IPostfixUnarySuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixUnaryOperator() IPostfixUnaryOperatorContext
	TypeArguments() ITypeArgumentsContext
	CallSuffix() ICallSuffixContext
	IndexingSuffix() IIndexingSuffixContext
	NavigationSuffix() INavigationSuffixContext

	// IsPostfixUnarySuffixContext differentiates from other interfaces.
	IsPostfixUnarySuffixContext()
}

type PostfixUnarySuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnarySuffixContext() *PostfixUnarySuffixContext {
	var p = new(PostfixUnarySuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnarySuffix
	return p
}

func (*PostfixUnarySuffixContext) IsPostfixUnarySuffixContext() {}

func NewPostfixUnarySuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnarySuffixContext {
	var p = new(PostfixUnarySuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnarySuffix

	return p
}

func (s *PostfixUnarySuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnarySuffixContext) PostfixUnaryOperator() IPostfixUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryOperatorContext)
}

func (s *PostfixUnarySuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *PostfixUnarySuffixContext) CallSuffix() ICallSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *PostfixUnarySuffixContext) IndexingSuffix() IIndexingSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexingSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexingSuffixContext)
}

func (s *PostfixUnarySuffixContext) NavigationSuffix() INavigationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INavigationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INavigationSuffixContext)
}

func (s *PostfixUnarySuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnarySuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnarySuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnarySuffix(s)
	}
}

func (s *PostfixUnarySuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnarySuffix(s)
	}
}

func (p *KotlinParser) PostfixUnarySuffix() (localctx IPostfixUnarySuffixContext) {
	this := p
	_ = this

	localctx = NewPostfixUnarySuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, KotlinParserRULE_postfixUnarySuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2332)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2327)
			p.PostfixUnaryOperator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2328)
			p.TypeArguments()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2329)
			p.CallSuffix()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2330)
			p.IndexingSuffix()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2331)
			p.NavigationSuffix()
		}

	}

	return localctx
}

// IDirectlyAssignableExpressionContext is an interface to support dynamic dispatch.
type IDirectlyAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixUnaryExpression() IPostfixUnaryExpressionContext
	AssignableSuffix() IAssignableSuffixContext
	SimpleIdentifier() ISimpleIdentifierContext
	ParenthesizedDirectlyAssignableExpression() IParenthesizedDirectlyAssignableExpressionContext

	// IsDirectlyAssignableExpressionContext differentiates from other interfaces.
	IsDirectlyAssignableExpressionContext()
}

type DirectlyAssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectlyAssignableExpressionContext() *DirectlyAssignableExpressionContext {
	var p = new(DirectlyAssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_directlyAssignableExpression
	return p
}

func (*DirectlyAssignableExpressionContext) IsDirectlyAssignableExpressionContext() {}

func NewDirectlyAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectlyAssignableExpressionContext {
	var p = new(DirectlyAssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_directlyAssignableExpression

	return p
}

func (s *DirectlyAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectlyAssignableExpressionContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *DirectlyAssignableExpressionContext) AssignableSuffix() IAssignableSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableSuffixContext)
}

func (s *DirectlyAssignableExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *DirectlyAssignableExpressionContext) ParenthesizedDirectlyAssignableExpression() IParenthesizedDirectlyAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedDirectlyAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedDirectlyAssignableExpressionContext)
}

func (s *DirectlyAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectlyAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectlyAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDirectlyAssignableExpression(s)
	}
}

func (s *DirectlyAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDirectlyAssignableExpression(s)
	}
}

func (p *KotlinParser) DirectlyAssignableExpression() (localctx IDirectlyAssignableExpressionContext) {
	this := p
	_ = this

	localctx = NewDirectlyAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, KotlinParserRULE_directlyAssignableExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2339)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 347, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2334)
			p.PostfixUnaryExpression()
		}
		{
			p.SetState(2335)
			p.AssignableSuffix()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2337)
			p.SimpleIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2338)
			p.ParenthesizedDirectlyAssignableExpression()
		}

	}

	return localctx
}

// IParenthesizedDirectlyAssignableExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedDirectlyAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	DirectlyAssignableExpression() IDirectlyAssignableExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedDirectlyAssignableExpressionContext differentiates from other interfaces.
	IsParenthesizedDirectlyAssignableExpressionContext()
}

type ParenthesizedDirectlyAssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedDirectlyAssignableExpressionContext() *ParenthesizedDirectlyAssignableExpressionContext {
	var p = new(ParenthesizedDirectlyAssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedDirectlyAssignableExpression
	return p
}

func (*ParenthesizedDirectlyAssignableExpressionContext) IsParenthesizedDirectlyAssignableExpressionContext() {
}

func NewParenthesizedDirectlyAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedDirectlyAssignableExpressionContext {
	var p = new(ParenthesizedDirectlyAssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedDirectlyAssignableExpression

	return p
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedDirectlyAssignableExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) DirectlyAssignableExpression() IDirectlyAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectlyAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectlyAssignableExpressionContext)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedDirectlyAssignableExpression(s)
	}
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedDirectlyAssignableExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedDirectlyAssignableExpression() (localctx IParenthesizedDirectlyAssignableExpressionContext) {
	this := p
	_ = this

	localctx = NewParenthesizedDirectlyAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, KotlinParserRULE_parenthesizedDirectlyAssignableExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2341)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2342)
			p.Match(KotlinParserNL)
		}

		p.SetState(2347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2348)
		p.DirectlyAssignableExpression()
	}
	p.SetState(2352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2349)
			p.Match(KotlinParserNL)
		}

		p.SetState(2354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2355)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IAssignableExpressionContext is an interface to support dynamic dispatch.
type IAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrefixUnaryExpression() IPrefixUnaryExpressionContext
	ParenthesizedAssignableExpression() IParenthesizedAssignableExpressionContext

	// IsAssignableExpressionContext differentiates from other interfaces.
	IsAssignableExpressionContext()
}

type AssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableExpressionContext() *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableExpression
	return p
}

func (*AssignableExpressionContext) IsAssignableExpressionContext() {}

func NewAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignableExpression

	return p
}

func (s *AssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableExpressionContext) PrefixUnaryExpression() IPrefixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryExpressionContext)
}

func (s *AssignableExpressionContext) ParenthesizedAssignableExpression() IParenthesizedAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedAssignableExpressionContext)
}

func (s *AssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignableExpression(s)
	}
}

func (s *AssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignableExpression(s)
	}
}

func (p *KotlinParser) AssignableExpression() (localctx IAssignableExpressionContext) {
	this := p
	_ = this

	localctx = NewAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, KotlinParserRULE_assignableExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2359)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 350, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2357)
			p.PrefixUnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2358)
			p.ParenthesizedAssignableExpression()
		}

	}

	return localctx
}

// IParenthesizedAssignableExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AssignableExpression() IAssignableExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedAssignableExpressionContext differentiates from other interfaces.
	IsParenthesizedAssignableExpressionContext()
}

type ParenthesizedAssignableExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedAssignableExpressionContext() *ParenthesizedAssignableExpressionContext {
	var p = new(ParenthesizedAssignableExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedAssignableExpression
	return p
}

func (*ParenthesizedAssignableExpressionContext) IsParenthesizedAssignableExpressionContext() {}

func NewParenthesizedAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedAssignableExpressionContext {
	var p = new(ParenthesizedAssignableExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedAssignableExpression

	return p
}

func (s *ParenthesizedAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedAssignableExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedAssignableExpressionContext) AssignableExpression() IAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *ParenthesizedAssignableExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedAssignableExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedAssignableExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedAssignableExpression(s)
	}
}

func (s *ParenthesizedAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedAssignableExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedAssignableExpression() (localctx IParenthesizedAssignableExpressionContext) {
	this := p
	_ = this

	localctx = NewParenthesizedAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, KotlinParserRULE_parenthesizedAssignableExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2361)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2362)
			p.Match(KotlinParserNL)
		}

		p.SetState(2367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2368)
		p.AssignableExpression()
	}
	p.SetState(2372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2369)
			p.Match(KotlinParserNL)
		}

		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2375)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IAssignableSuffixContext is an interface to support dynamic dispatch.
type IAssignableSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeArguments() ITypeArgumentsContext
	IndexingSuffix() IIndexingSuffixContext
	NavigationSuffix() INavigationSuffixContext

	// IsAssignableSuffixContext differentiates from other interfaces.
	IsAssignableSuffixContext()
}

type AssignableSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableSuffixContext() *AssignableSuffixContext {
	var p = new(AssignableSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableSuffix
	return p
}

func (*AssignableSuffixContext) IsAssignableSuffixContext() {}

func NewAssignableSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableSuffixContext {
	var p = new(AssignableSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignableSuffix

	return p
}

func (s *AssignableSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *AssignableSuffixContext) IndexingSuffix() IIndexingSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexingSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexingSuffixContext)
}

func (s *AssignableSuffixContext) NavigationSuffix() INavigationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INavigationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INavigationSuffixContext)
}

func (s *AssignableSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignableSuffix(s)
	}
}

func (s *AssignableSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignableSuffix(s)
	}
}

func (p *KotlinParser) AssignableSuffix() (localctx IAssignableSuffixContext) {
	this := p
	_ = this

	localctx = NewAssignableSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, KotlinParserRULE_assignableSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2380)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLANGLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2377)
			p.TypeArguments()
		}

	case KotlinParserLSQUARE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2378)
			p.IndexingSuffix()
		}

	case KotlinParserNL, KotlinParserDOT, KotlinParserCOLONCOLON, KotlinParserQUEST_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2379)
			p.NavigationSuffix()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexingSuffixContext is an interface to support dynamic dispatch.
type IIndexingSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQUARE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RSQUARE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexingSuffixContext differentiates from other interfaces.
	IsIndexingSuffixContext()
}

type IndexingSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexingSuffixContext() *IndexingSuffixContext {
	var p = new(IndexingSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_indexingSuffix
	return p
}

func (*IndexingSuffixContext) IsIndexingSuffixContext() {}

func NewIndexingSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexingSuffixContext {
	var p = new(IndexingSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_indexingSuffix

	return p
}

func (s *IndexingSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexingSuffixContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *IndexingSuffixContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexingSuffixContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexingSuffixContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *IndexingSuffixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IndexingSuffixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IndexingSuffixContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *IndexingSuffixContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *IndexingSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexingSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexingSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIndexingSuffix(s)
	}
}

func (s *IndexingSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIndexingSuffix(s)
	}
}

func (p *KotlinParser) IndexingSuffix() (localctx IIndexingSuffixContext) {
	this := p
	_ = this

	localctx = NewIndexingSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, KotlinParserRULE_indexingSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2382)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(2386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2383)
			p.Match(KotlinParserNL)
		}

		p.SetState(2388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2389)
		p.Expression()
	}
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 357, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2393)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2390)
					p.Match(KotlinParserNL)
				}

				p.SetState(2395)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2396)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(2400)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2397)
					p.Match(KotlinParserNL)
				}

				p.SetState(2402)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2403)
				p.Expression()
			}

		}
		p.SetState(2408)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 357, p.GetParserRuleContext())
	}
	p.SetState(2416)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext()) == 1 {
		p.SetState(2412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2409)
				p.Match(KotlinParserNL)
			}

			p.SetState(2414)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2415)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(2421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2418)
			p.Match(KotlinParserNL)
		}

		p.SetState(2423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2424)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// INavigationSuffixContext is an interface to support dynamic dispatch.
type INavigationSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MemberAccessOperator() IMemberAccessOperatorContext
	SimpleIdentifier() ISimpleIdentifierContext
	ParenthesizedExpression() IParenthesizedExpressionContext
	CLASS() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsNavigationSuffixContext differentiates from other interfaces.
	IsNavigationSuffixContext()
}

type NavigationSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNavigationSuffixContext() *NavigationSuffixContext {
	var p = new(NavigationSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_navigationSuffix
	return p
}

func (*NavigationSuffixContext) IsNavigationSuffixContext() {}

func NewNavigationSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NavigationSuffixContext {
	var p = new(NavigationSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_navigationSuffix

	return p
}

func (s *NavigationSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *NavigationSuffixContext) MemberAccessOperator() IMemberAccessOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessOperatorContext)
}

func (s *NavigationSuffixContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *NavigationSuffixContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *NavigationSuffixContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *NavigationSuffixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NavigationSuffixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NavigationSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NavigationSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NavigationSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNavigationSuffix(s)
	}
}

func (s *NavigationSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNavigationSuffix(s)
	}
}

func (p *KotlinParser) NavigationSuffix() (localctx INavigationSuffixContext) {
	this := p
	_ = this

	localctx = NewNavigationSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, KotlinParserRULE_navigationSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2426)
		p.MemberAccessOperator()
	}
	p.SetState(2430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2427)
			p.Match(KotlinParserNL)
		}

		p.SetState(2432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2436)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(2433)
			p.SimpleIdentifier()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(2434)
			p.ParenthesizedExpression()
		}

	case KotlinParserCLASS:
		{
			p.SetState(2435)
			p.Match(KotlinParserCLASS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallSuffixContext is an interface to support dynamic dispatch.
type ICallSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotatedLambda() IAnnotatedLambdaContext
	ValueArguments() IValueArgumentsContext
	TypeArguments() ITypeArgumentsContext

	// IsCallSuffixContext differentiates from other interfaces.
	IsCallSuffixContext()
}

type CallSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallSuffixContext() *CallSuffixContext {
	var p = new(CallSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_callSuffix
	return p
}

func (*CallSuffixContext) IsCallSuffixContext() {}

func NewCallSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallSuffixContext {
	var p = new(CallSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callSuffix

	return p
}

func (s *CallSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *CallSuffixContext) AnnotatedLambda() IAnnotatedLambdaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotatedLambdaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotatedLambdaContext)
}

func (s *CallSuffixContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *CallSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *CallSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallSuffix(s)
	}
}

func (s *CallSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallSuffix(s)
	}
}

func (p *KotlinParser) CallSuffix() (localctx ICallSuffixContext) {
	this := p
	_ = this

	localctx = NewCallSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, KotlinParserRULE_callSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLANGLE {
		{
			p.SetState(2438)
			p.TypeArguments()
		}

	}
	p.SetState(2446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2442)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserLPAREN {
			{
				p.SetState(2441)
				p.ValueArguments()
			}

		}
		{
			p.SetState(2444)
			p.AnnotatedLambda()
		}

	case 2:
		{
			p.SetState(2445)
			p.ValueArguments()
		}

	}

	return localctx
}

// IAnnotatedLambdaContext is an interface to support dynamic dispatch.
type IAnnotatedLambdaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaLiteral() ILambdaLiteralContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	Label() ILabelContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotatedLambdaContext differentiates from other interfaces.
	IsAnnotatedLambdaContext()
}

type AnnotatedLambdaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedLambdaContext() *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedLambda
	return p
}

func (*AnnotatedLambdaContext) IsAnnotatedLambdaContext() {}

func NewAnnotatedLambdaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotatedLambda

	return p
}

func (s *AnnotatedLambdaContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedLambdaContext) LambdaLiteral() ILambdaLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLiteralContext)
}

func (s *AnnotatedLambdaContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotatedLambdaContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotatedLambdaContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *AnnotatedLambdaContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotatedLambdaContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotatedLambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedLambdaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedLambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotatedLambda(s)
	}
}

func (s *AnnotatedLambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotatedLambda(s)
	}
}

func (p *KotlinParser) AnnotatedLambda() (localctx IAnnotatedLambdaContext) {
	this := p
	_ = this

	localctx = NewAnnotatedLambdaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, KotlinParserRULE_annotatedLambda)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(2448)
			p.Annotation()
		}

		p.SetState(2453)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&-17588927330817) != 0) || ((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&2098175) != 0) {
		{
			p.SetState(2454)
			p.Label()
		}

	}
	p.SetState(2460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2457)
			p.Match(KotlinParserNL)
		}

		p.SetState(2462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2463)
		p.LambdaLiteral()
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGLE() antlr.TerminalNode
	AllTypeProjection() []ITypeProjectionContext
	TypeProjection(i int) ITypeProjectionContext
	RANGLE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeArgumentsContext) AllTypeProjection() []ITypeProjectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeProjectionContext); ok {
			len++
		}
	}

	tst := make([]ITypeProjectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeProjectionContext); ok {
			tst[i] = t.(ITypeProjectionContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeProjection(i int) ITypeProjectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeProjectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionContext)
}

func (s *TypeArgumentsContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeArgumentsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeArgumentsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *KotlinParser) TypeArguments() (localctx ITypeArgumentsContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, KotlinParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2465)
		p.Match(KotlinParserLANGLE)
	}
	p.SetState(2469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2466)
			p.Match(KotlinParserNL)
		}

		p.SetState(2471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2472)
		p.TypeProjection()
	}
	p.SetState(2489)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 372, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2476)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2473)
					p.Match(KotlinParserNL)
				}

				p.SetState(2478)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2479)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(2483)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2480)
					p.Match(KotlinParserNL)
				}

				p.SetState(2485)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2486)
				p.TypeProjection()
			}

		}
		p.SetState(2491)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 372, p.GetParserRuleContext())
	}
	p.SetState(2499)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 374, p.GetParserRuleContext()) == 1 {
		p.SetState(2495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2492)
				p.Match(KotlinParserNL)
			}

			p.SetState(2497)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2498)
			p.Match(KotlinParserCOMMA)
		}

	}
	p.SetState(2504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2501)
			p.Match(KotlinParserNL)
		}

		p.SetState(2506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2507)
		p.Match(KotlinParserRANGLE)
	}

	return localctx
}

// IValueArgumentsContext is an interface to support dynamic dispatch.
type IValueArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllValueArgument() []IValueArgumentContext
	ValueArgument(i int) IValueArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValueArgumentsContext differentiates from other interfaces.
	IsValueArgumentsContext()
}

type ValueArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentsContext() *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArguments
	return p
}

func (*ValueArgumentsContext) IsValueArgumentsContext() {}

func NewValueArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArguments

	return p
}

func (s *ValueArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ValueArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ValueArgumentsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ValueArgumentsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ValueArgumentsContext) AllValueArgument() []IValueArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueArgumentContext); ok {
			len++
		}
	}

	tst := make([]IValueArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueArgumentContext); ok {
			tst[i] = t.(IValueArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ValueArgumentsContext) ValueArgument(i int) IValueArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentContext)
}

func (s *ValueArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ValueArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ValueArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArguments(s)
	}
}

func (s *ValueArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArguments(s)
	}
}

func (p *KotlinParser) ValueArguments() (localctx IValueArgumentsContext) {
	this := p
	_ = this

	localctx = NewValueArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, KotlinParserRULE_valueArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2509)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2513)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2510)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2515)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext())
	}
	p.SetState(2551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-144109553024456160) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4268161558145) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&13629951) != 0) {
		{
			p.SetState(2516)
			p.ValueArgument()
		}
		p.SetState(2533)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2520)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2517)
						p.Match(KotlinParserNL)
					}

					p.SetState(2522)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2523)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(2527)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2524)
							p.Match(KotlinParserNL)
						}

					}
					p.SetState(2529)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())
				}
				{
					p.SetState(2530)
					p.ValueArgument()
				}

			}
			p.SetState(2535)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())
		}
		p.SetState(2543)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext()) == 1 {
			p.SetState(2539)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2536)
					p.Match(KotlinParserNL)
				}

				p.SetState(2541)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2542)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(2548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2545)
				p.Match(KotlinParserNL)
			}

			p.SetState(2550)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2553)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IValueArgumentContext is an interface to support dynamic dispatch.
type IValueArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Annotation() IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	ASSIGNMENT() antlr.TerminalNode
	MULT() antlr.TerminalNode

	// IsValueArgumentContext differentiates from other interfaces.
	IsValueArgumentContext()
}

type ValueArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentContext() *ValueArgumentContext {
	var p = new(ValueArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArgument
	return p
}

func (*ValueArgumentContext) IsValueArgumentContext() {}

func NewValueArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentContext {
	var p = new(ValueArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArgument

	return p
}

func (s *ValueArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ValueArgumentContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ValueArgumentContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ValueArgumentContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ValueArgumentContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ValueArgumentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ValueArgumentContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ValueArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArgument(s)
	}
}

func (s *ValueArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArgument(s)
	}
}

func (p *KotlinParser) ValueArgument() (localctx IValueArgumentContext) {
	this := p
	_ = this

	localctx = NewValueArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, KotlinParserRULE_valueArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2556)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2555)
			p.Annotation()
		}

	}
	p.SetState(2561)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2558)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2563)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())
	}
	p.SetState(2578)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2564)
			p.SimpleIdentifier()
		}
		p.SetState(2568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2565)
				p.Match(KotlinParserNL)
			}

			p.SetState(2570)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2571)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(2575)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2572)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2577)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext())
		}

	}
	p.SetState(2581)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserMULT {
		{
			p.SetState(2580)
			p.Match(KotlinParserMULT)
		}

	}
	p.SetState(2586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2583)
			p.Match(KotlinParserNL)
		}

		p.SetState(2588)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2589)
		p.Expression()
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParenthesizedExpression() IParenthesizedExpressionContext
	SimpleIdentifier() ISimpleIdentifierContext
	LiteralConstant() ILiteralConstantContext
	StringLiteral() IStringLiteralContext
	CallableReference() ICallableReferenceContext
	FunctionLiteral() IFunctionLiteralContext
	ObjectLiteral() IObjectLiteralContext
	CollectionLiteral() ICollectionLiteralContext
	ThisExpression() IThisExpressionContext
	SuperExpression() ISuperExpressionContext
	IfExpression() IIfExpressionContext
	WhenExpression() IWhenExpressionContext
	TryExpression() ITryExpressionContext
	JumpExpression() IJumpExpressionContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *PrimaryExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *PrimaryExpressionContext) LiteralConstant() ILiteralConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *PrimaryExpressionContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PrimaryExpressionContext) CallableReference() ICallableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallableReferenceContext)
}

func (s *PrimaryExpressionContext) FunctionLiteral() IFunctionLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLiteralContext)
}

func (s *PrimaryExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *PrimaryExpressionContext) CollectionLiteral() ICollectionLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionLiteralContext)
}

func (s *PrimaryExpressionContext) ThisExpression() IThisExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThisExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThisExpressionContext)
}

func (s *PrimaryExpressionContext) SuperExpression() ISuperExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuperExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuperExpressionContext)
}

func (s *PrimaryExpressionContext) IfExpression() IIfExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExpressionContext)
}

func (s *PrimaryExpressionContext) WhenExpression() IWhenExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *PrimaryExpressionContext) TryExpression() ITryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExpressionContext)
}

func (s *PrimaryExpressionContext) JumpExpression() IJumpExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJumpExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJumpExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *KotlinParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, KotlinParserRULE_primaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2605)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2591)
			p.ParenthesizedExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2592)
			p.SimpleIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2593)
			p.LiteralConstant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2594)
			p.StringLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2595)
			p.CallableReference()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2596)
			p.FunctionLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2597)
			p.ObjectLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2598)
			p.CollectionLiteral()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2599)
			p.ThisExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2600)
			p.SuperExpression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2601)
			p.IfExpression()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2602)
			p.WhenExpression()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2603)
			p.TryExpression()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2604)
			p.JumpExpression()
		}

	}

	return localctx
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression
	return p
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	this := p
	_ = this

	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, KotlinParserRULE_parenthesizedExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2607)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2611)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2608)
			p.Match(KotlinParserNL)
		}

		p.SetState(2613)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2614)
		p.Expression()
	}
	p.SetState(2618)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2615)
			p.Match(KotlinParserNL)
		}

		p.SetState(2620)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2621)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// ICollectionLiteralContext is an interface to support dynamic dispatch.
type ICollectionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQUARE() antlr.TerminalNode
	RSQUARE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCollectionLiteralContext differentiates from other interfaces.
	IsCollectionLiteralContext()
}

type CollectionLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionLiteralContext() *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_collectionLiteral
	return p
}

func (*CollectionLiteralContext) IsCollectionLiteralContext() {}

func NewCollectionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_collectionLiteral

	return p
}

func (s *CollectionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionLiteralContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *CollectionLiteralContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *CollectionLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CollectionLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CollectionLiteralContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CollectionLiteralContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CollectionLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *CollectionLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *CollectionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCollectionLiteral(s)
	}
}

func (s *CollectionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCollectionLiteral(s)
	}
}

func (p *KotlinParser) CollectionLiteral() (localctx ICollectionLiteralContext) {
	this := p
	_ = this

	localctx = NewCollectionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, KotlinParserRULE_collectionLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2623)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(2627)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2624)
			p.Match(KotlinParserNL)
		}

		p.SetState(2629)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2665)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-144109553024488960) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4268161558145) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&13629951) != 0) {
		{
			p.SetState(2630)
			p.Expression()
		}
		p.SetState(2647)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2634)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2631)
						p.Match(KotlinParserNL)
					}

					p.SetState(2636)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2637)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(2641)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2638)
						p.Match(KotlinParserNL)
					}

					p.SetState(2643)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2644)
					p.Expression()
				}

			}
			p.SetState(2649)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext())
		}
		p.SetState(2657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 399, p.GetParserRuleContext()) == 1 {
			p.SetState(2653)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2650)
					p.Match(KotlinParserNL)
				}

				p.SetState(2655)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2656)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(2662)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2659)
				p.Match(KotlinParserNL)
			}

			p.SetState(2664)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2667)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanLiteral() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	HexLiteral() antlr.TerminalNode
	BinLiteral() antlr.TerminalNode
	CharacterLiteral() antlr.TerminalNode
	RealLiteral() antlr.TerminalNode
	NullLiteral() antlr.TerminalNode
	LongLiteral() antlr.TerminalNode
	UnsignedLiteral() antlr.TerminalNode

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_literalConstant
	return p
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBooleanLiteral, 0)
}

func (s *LiteralConstantContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserIntegerLiteral, 0)
}

func (s *LiteralConstantContext) HexLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserHexLiteral, 0)
}

func (s *LiteralConstantContext) BinLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBinLiteral, 0)
}

func (s *LiteralConstantContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserCharacterLiteral, 0)
}

func (s *LiteralConstantContext) RealLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserRealLiteral, 0)
}

func (s *LiteralConstantContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserNullLiteral, 0)
}

func (s *LiteralConstantContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserLongLiteral, 0)
}

func (s *LiteralConstantContext) UnsignedLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserUnsignedLiteral, 0)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLiteralConstant(s)
	}
}

func (s *LiteralConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLiteralConstant(s)
	}
}

func (p *KotlinParser) LiteralConstant() (localctx ILiteralConstantContext) {
	this := p
	_ = this

	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, KotlinParserRULE_literalConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2669)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&2041) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LineStringLiteral() ILineStringLiteralContext
	MultiLineStringLiteral() IMultiLineStringLiteralContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) LineStringLiteral() ILineStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineStringLiteralContext)
}

func (s *StringLiteralContext) MultiLineStringLiteral() IMultiLineStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiLineStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringLiteralContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *KotlinParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, KotlinParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2673)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserQUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2671)
			p.LineStringLiteral()
		}

	case KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2672)
			p.MultiLineStringLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILineStringLiteralContext is an interface to support dynamic dispatch.
type ILineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUOTE_OPEN() antlr.TerminalNode
	QUOTE_CLOSE() antlr.TerminalNode
	AllLineStringContent() []ILineStringContentContext
	LineStringContent(i int) ILineStringContentContext
	AllLineStringExpression() []ILineStringExpressionContext
	LineStringExpression(i int) ILineStringExpressionContext

	// IsLineStringLiteralContext differentiates from other interfaces.
	IsLineStringLiteralContext()
}

type LineStringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringLiteralContext() *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringLiteral
	return p
}

func (*LineStringLiteralContext) IsLineStringLiteralContext() {}

func NewLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringLiteral

	return p
}

func (s *LineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringLiteralContext) QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_OPEN, 0)
}

func (s *LineStringLiteralContext) QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_CLOSE, 0)
}

func (s *LineStringLiteralContext) AllLineStringContent() []ILineStringContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILineStringContentContext); ok {
			len++
		}
	}

	tst := make([]ILineStringContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILineStringContentContext); ok {
			tst[i] = t.(ILineStringContentContext)
			i++
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringContent(i int) ILineStringContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineStringContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineStringContentContext)
}

func (s *LineStringLiteralContext) AllLineStringExpression() []ILineStringExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILineStringExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILineStringExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILineStringExpressionContext); ok {
			tst[i] = t.(ILineStringExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringExpression(i int) ILineStringExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineStringExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineStringExpressionContext)
}

func (s *LineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringLiteral(s)
	}
}

func (s *LineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringLiteral(s)
	}
}

func (p *KotlinParser) LineStringLiteral() (localctx ILineStringLiteralContext) {
	this := p
	_ = this

	localctx = NewLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, KotlinParserRULE_lineStringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2675)
		p.Match(KotlinParserQUOTE_OPEN)
	}
	p.SetState(2680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-160)) & ^0x3f) == 0 && ((int64(1)<<(_la-160))&15) != 0 {
		p.SetState(2678)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserLineStrRef, KotlinParserLineStrText, KotlinParserLineStrEscapedChar:
			{
				p.SetState(2676)
				p.LineStringContent()
			}

		case KotlinParserLineStrExprStart:
			{
				p.SetState(2677)
				p.LineStringExpression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2683)
		p.Match(KotlinParserQUOTE_CLOSE)
	}

	return localctx
}

// IMultiLineStringLiteralContext is an interface to support dynamic dispatch.
type IMultiLineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_QUOTE_OPEN() antlr.TerminalNode
	TRIPLE_QUOTE_CLOSE() antlr.TerminalNode
	AllMultiLineStringContent() []IMultiLineStringContentContext
	MultiLineStringContent(i int) IMultiLineStringContentContext
	AllMultiLineStringExpression() []IMultiLineStringExpressionContext
	MultiLineStringExpression(i int) IMultiLineStringExpressionContext
	AllMultiLineStringQuote() []antlr.TerminalNode
	MultiLineStringQuote(i int) antlr.TerminalNode

	// IsMultiLineStringLiteralContext differentiates from other interfaces.
	IsMultiLineStringLiteralContext()
}

type MultiLineStringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringLiteralContext() *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral
	return p
}

func (*MultiLineStringLiteralContext) IsMultiLineStringLiteralContext() {}

func NewMultiLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral

	return p
}

func (s *MultiLineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_OPEN, 0)
}

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_CLOSE, 0)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringContent() []IMultiLineStringContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiLineStringContentContext); ok {
			len++
		}
	}

	tst := make([]IMultiLineStringContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiLineStringContentContext); ok {
			tst[i] = t.(IMultiLineStringContentContext)
			i++
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringContent(i int) IMultiLineStringContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiLineStringContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringContentContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringExpression() []IMultiLineStringExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiLineStringExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiLineStringExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiLineStringExpressionContext); ok {
			tst[i] = t.(IMultiLineStringExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringExpression(i int) IMultiLineStringExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiLineStringExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringExpressionContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringQuote() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserMultiLineStringQuote)
}

func (s *MultiLineStringLiteralContext) MultiLineStringQuote(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStringQuote, i)
}

func (s *MultiLineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringLiteral(s)
	}
}

func (s *MultiLineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringLiteral(s)
	}
}

func (p *KotlinParser) MultiLineStringLiteral() (localctx IMultiLineStringLiteralContext) {
	this := p
	_ = this

	localctx = NewMultiLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, KotlinParserRULE_multiLineStringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2685)
		p.Match(KotlinParserTRIPLE_QUOTE_OPEN)
	}
	p.SetState(2691)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-165)) & ^0x3f) == 0 && ((int64(1)<<(_la-165))&15) != 0 {
		p.SetState(2689)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 405, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2686)
				p.MultiLineStringContent()
			}

		case 2:
			{
				p.SetState(2687)
				p.MultiLineStringExpression()
			}

		case 3:
			{
				p.SetState(2688)
				p.Match(KotlinParserMultiLineStringQuote)
			}

		}

		p.SetState(2693)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2694)
		p.Match(KotlinParserTRIPLE_QUOTE_CLOSE)
	}

	return localctx
}

// ILineStringContentContext is an interface to support dynamic dispatch.
type ILineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LineStrText() antlr.TerminalNode
	LineStrEscapedChar() antlr.TerminalNode
	LineStrRef() antlr.TerminalNode

	// IsLineStringContentContext differentiates from other interfaces.
	IsLineStringContentContext()
}

type LineStringContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringContentContext() *LineStringContentContext {
	var p = new(LineStringContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringContent
	return p
}

func (*LineStringContentContext) IsLineStringContentContext() {}

func NewLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringContentContext {
	var p = new(LineStringContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringContent

	return p
}

func (s *LineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringContentContext) LineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrText, 0)
}

func (s *LineStringContentContext) LineStrEscapedChar() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrEscapedChar, 0)
}

func (s *LineStringContentContext) LineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrRef, 0)
}

func (s *LineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringContent(s)
	}
}

func (s *LineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringContent(s)
	}
}

func (p *KotlinParser) LineStringContent() (localctx ILineStringContentContext) {
	this := p
	_ = this

	localctx = NewLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, KotlinParserRULE_lineStringContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2696)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-160)) & ^0x3f) == 0 && ((int64(1)<<(_la-160))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILineStringExpressionContext is an interface to support dynamic dispatch.
type ILineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LineStrExprStart() antlr.TerminalNode
	Expression() IExpressionContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLineStringExpressionContext differentiates from other interfaces.
	IsLineStringExpressionContext()
}

type LineStringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringExpressionContext() *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringExpression
	return p
}

func (*LineStringExpressionContext) IsLineStringExpressionContext() {}

func NewLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringExpression

	return p
}

func (s *LineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringExpressionContext) LineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrExprStart, 0)
}

func (s *LineStringExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *LineStringExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LineStringExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringExpression(s)
	}
}

func (s *LineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringExpression(s)
	}
}

func (p *KotlinParser) LineStringExpression() (localctx ILineStringExpressionContext) {
	this := p
	_ = this

	localctx = NewLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, KotlinParserRULE_lineStringExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2698)
		p.Match(KotlinParserLineStrExprStart)
	}
	p.SetState(2702)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2699)
			p.Match(KotlinParserNL)
		}

		p.SetState(2704)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2705)
		p.Expression()
	}
	p.SetState(2709)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2706)
			p.Match(KotlinParserNL)
		}

		p.SetState(2711)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2712)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IMultiLineStringContentContext is an interface to support dynamic dispatch.
type IMultiLineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiLineStrText() antlr.TerminalNode
	MultiLineStringQuote() antlr.TerminalNode
	MultiLineStrRef() antlr.TerminalNode

	// IsMultiLineStringContentContext differentiates from other interfaces.
	IsMultiLineStringContentContext()
}

type MultiLineStringContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringContentContext() *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringContent
	return p
}

func (*MultiLineStringContentContext) IsMultiLineStringContentContext() {}

func NewMultiLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringContent

	return p
}

func (s *MultiLineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringContentContext) MultiLineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrText, 0)
}

func (s *MultiLineStringContentContext) MultiLineStringQuote() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStringQuote, 0)
}

func (s *MultiLineStringContentContext) MultiLineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrRef, 0)
}

func (s *MultiLineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringContent(s)
	}
}

func (s *MultiLineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringContent(s)
	}
}

func (p *KotlinParser) MultiLineStringContent() (localctx IMultiLineStringContentContext) {
	this := p
	_ = this

	localctx = NewMultiLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, KotlinParserRULE_multiLineStringContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2714)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-165)) & ^0x3f) == 0 && ((int64(1)<<(_la-165))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiLineStringExpressionContext is an interface to support dynamic dispatch.
type IMultiLineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiLineStrExprStart() antlr.TerminalNode
	Expression() IExpressionContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsMultiLineStringExpressionContext differentiates from other interfaces.
	IsMultiLineStringExpressionContext()
}

type MultiLineStringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringExpressionContext() *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression
	return p
}

func (*MultiLineStringExpressionContext) IsMultiLineStringExpressionContext() {}

func NewMultiLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression

	return p
}

func (s *MultiLineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringExpressionContext) MultiLineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrExprStart, 0)
}

func (s *MultiLineStringExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiLineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *MultiLineStringExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiLineStringExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiLineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringExpression(s)
	}
}

func (s *MultiLineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringExpression(s)
	}
}

func (p *KotlinParser) MultiLineStringExpression() (localctx IMultiLineStringExpressionContext) {
	this := p
	_ = this

	localctx = NewMultiLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, KotlinParserRULE_multiLineStringExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2716)
		p.Match(KotlinParserMultiLineStrExprStart)
	}
	p.SetState(2720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2717)
			p.Match(KotlinParserNL)
		}

		p.SetState(2722)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2723)
		p.Expression()
	}
	p.SetState(2727)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2724)
			p.Match(KotlinParserNL)
		}

		p.SetState(2729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2730)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// ILambdaLiteralContext is an interface to support dynamic dispatch.
type ILambdaLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	Statements() IStatementsContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	ARROW() antlr.TerminalNode
	LambdaParameters() ILambdaParametersContext

	// IsLambdaLiteralContext differentiates from other interfaces.
	IsLambdaLiteralContext()
}

type LambdaLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaLiteralContext() *LambdaLiteralContext {
	var p = new(LambdaLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaLiteral
	return p
}

func (*LambdaLiteralContext) IsLambdaLiteralContext() {}

func NewLambdaLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaLiteralContext {
	var p = new(LambdaLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaLiteral

	return p
}

func (s *LambdaLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaLiteralContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *LambdaLiteralContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *LambdaLiteralContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *LambdaLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaLiteralContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *LambdaLiteralContext) LambdaParameters() ILambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaLiteral(s)
	}
}

func (s *LambdaLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaLiteral(s)
	}
}

func (p *KotlinParser) LambdaLiteral() (localctx ILambdaLiteralContext) {
	this := p
	_ = this

	localctx = NewLambdaLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, KotlinParserRULE_lambdaLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2732)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(2736)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 411, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2733)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2738)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 411, p.GetParserRuleContext())
	}
	p.SetState(2755)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext()) == 1 {
		p.SetState(2740)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 412, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2739)
				p.LambdaParameters()
			}

		}
		p.SetState(2745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2742)
				p.Match(KotlinParserNL)
			}

			p.SetState(2747)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2748)
			p.Match(KotlinParserARROW)
		}
		p.SetState(2752)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 414, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2749)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2754)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 414, p.GetParserRuleContext())
		}

	}
	{
		p.SetState(2757)
		p.Statements()
	}
	p.SetState(2761)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2758)
			p.Match(KotlinParserNL)
		}

		p.SetState(2763)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2764)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLambdaParameter() []ILambdaParameterContext
	LambdaParameter(i int) ILambdaParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameters
	return p
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) AllLambdaParameter() []ILambdaParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaParameterContext); ok {
			len++
		}
	}

	tst := make([]ILambdaParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaParameterContext); ok {
			tst[i] = t.(ILambdaParameterContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParametersContext) LambdaParameter(i int) ILambdaParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParameterContext)
}

func (s *LambdaParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *LambdaParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *LambdaParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *KotlinParser) LambdaParameters() (localctx ILambdaParametersContext) {
	this := p
	_ = this

	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, KotlinParserRULE_lambdaParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2766)
		p.LambdaParameter()
	}
	p.SetState(2783)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 419, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2770)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2767)
					p.Match(KotlinParserNL)
				}

				p.SetState(2772)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2773)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(2777)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 418, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2774)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(2779)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 418, p.GetParserRuleContext())
			}
			{
				p.SetState(2780)
				p.LambdaParameter()
			}

		}
		p.SetState(2785)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 419, p.GetParserRuleContext())
	}
	p.SetState(2793)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 421, p.GetParserRuleContext()) == 1 {
		p.SetState(2789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2786)
				p.Match(KotlinParserNL)
			}

			p.SetState(2791)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2792)
			p.Match(KotlinParserCOMMA)
		}

	}

	return localctx
}

// ILambdaParameterContext is an interface to support dynamic dispatch.
type ILambdaParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaration() IVariableDeclarationContext
	MultiVariableDeclaration() IMultiVariableDeclarationContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLambdaParameterContext differentiates from other interfaces.
	IsLambdaParameterContext()
}

type LambdaParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParameterContext() *LambdaParameterContext {
	var p = new(LambdaParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameter
	return p
}

func (*LambdaParameterContext) IsLambdaParameterContext() {}

func NewLambdaParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParameterContext {
	var p = new(LambdaParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameter

	return p
}

func (s *LambdaParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParameterContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LambdaParameterContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *LambdaParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *LambdaParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LambdaParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameter(s)
	}
}

func (s *LambdaParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameter(s)
	}
}

func (p *KotlinParser) LambdaParameter() (localctx ILambdaParameterContext) {
	this := p
	_ = this

	localctx = NewLambdaParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, KotlinParserRULE_lambdaParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2813)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2795)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2796)
			p.MultiVariableDeclaration()
		}
		p.SetState(2811)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 424, p.GetParserRuleContext()) == 1 {
			p.SetState(2800)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2797)
					p.Match(KotlinParserNL)
				}

				p.SetState(2802)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2803)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(2807)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2804)
					p.Match(KotlinParserNL)
				}

				p.SetState(2809)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2810)
				p.Type_()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnonymousFunctionContext is an interface to support dynamic dispatch.
type IAnonymousFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUN() antlr.TerminalNode
	ParametersWithOptionalType() IParametersWithOptionalTypeContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	DOT() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeConstraints() ITypeConstraintsContext
	FunctionBody() IFunctionBodyContext

	// IsAnonymousFunctionContext differentiates from other interfaces.
	IsAnonymousFunctionContext()
}

type AnonymousFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousFunctionContext() *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousFunction
	return p
}

func (*AnonymousFunctionContext) IsAnonymousFunctionContext() {}

func NewAnonymousFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anonymousFunction

	return p
}

func (s *AnonymousFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousFunctionContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *AnonymousFunctionContext) ParametersWithOptionalType() IParametersWithOptionalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersWithOptionalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersWithOptionalTypeContext)
}

func (s *AnonymousFunctionContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *AnonymousFunctionContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AnonymousFunctionContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *AnonymousFunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnonymousFunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnonymousFunctionContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnonymousFunctionContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *AnonymousFunctionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *AnonymousFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnonymousFunction(s)
	}
}

func (s *AnonymousFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnonymousFunction(s)
	}
}

func (p *KotlinParser) AnonymousFunction() (localctx IAnonymousFunctionContext) {
	this := p
	_ = this

	localctx = NewAnonymousFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, KotlinParserRULE_anonymousFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2815)
		p.Match(KotlinParserFUN)
	}
	p.SetState(2831)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 428, p.GetParserRuleContext()) == 1 {
		p.SetState(2819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2816)
				p.Match(KotlinParserNL)
			}

			p.SetState(2821)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2822)
			p.Type_()
		}
		p.SetState(2826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2823)
				p.Match(KotlinParserNL)
			}

			p.SetState(2828)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2829)
			p.Match(KotlinParserDOT)
		}

	}
	p.SetState(2836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2833)
			p.Match(KotlinParserNL)
		}

		p.SetState(2838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2839)
		p.ParametersWithOptionalType()
	}
	p.SetState(2854)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
		p.SetState(2843)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2840)
				p.Match(KotlinParserNL)
			}

			p.SetState(2845)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2846)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(2850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2847)
				p.Match(KotlinParserNL)
			}

			p.SetState(2852)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2853)
			p.Type_()
		}

	}
	p.SetState(2863)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 434, p.GetParserRuleContext()) == 1 {
		p.SetState(2859)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2856)
				p.Match(KotlinParserNL)
			}

			p.SetState(2861)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2862)
			p.TypeConstraints()
		}

	}
	p.SetState(2872)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 436, p.GetParserRuleContext()) == 1 {
		p.SetState(2868)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2865)
				p.Match(KotlinParserNL)
			}

			p.SetState(2870)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2871)
			p.FunctionBody()
		}

	}

	return localctx
}

// IFunctionLiteralContext is an interface to support dynamic dispatch.
type IFunctionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaLiteral() ILambdaLiteralContext
	AnonymousFunction() IAnonymousFunctionContext

	// IsFunctionLiteralContext differentiates from other interfaces.
	IsFunctionLiteralContext()
}

type FunctionLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLiteralContext() *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionLiteral
	return p
}

func (*FunctionLiteralContext) IsFunctionLiteralContext() {}

func NewFunctionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionLiteral

	return p
}

func (s *FunctionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLiteralContext) LambdaLiteral() ILambdaLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLiteralContext)
}

func (s *FunctionLiteralContext) AnonymousFunction() IAnonymousFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousFunctionContext)
}

func (s *FunctionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionLiteral(s)
	}
}

func (s *FunctionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionLiteral(s)
	}
}

func (p *KotlinParser) FunctionLiteral() (localctx IFunctionLiteralContext) {
	this := p
	_ = this

	localctx = NewFunctionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, KotlinParserRULE_functionLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2876)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLCURL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2874)
			p.LambdaLiteral()
		}

	case KotlinParserFUN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2875)
			p.AnonymousFunction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	ClassBody() IClassBodyContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_objectLiteral
	return p
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectLiteralContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectLiteralContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectLiteralContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (p *KotlinParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	this := p
	_ = this

	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, KotlinParserRULE_objectLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2878)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(2899)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 441, p.GetParserRuleContext()) == 1 {
		p.SetState(2882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2879)
				p.Match(KotlinParserNL)
			}

			p.SetState(2884)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2885)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(2889)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 439, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2886)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2891)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 439, p.GetParserRuleContext())
		}
		{
			p.SetState(2892)
			p.DelegationSpecifiers()
		}
		p.SetState(2896)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2893)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2898)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext())
		}

	}
	p.SetState(2908)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 443, p.GetParserRuleContext()) == 1 {
		p.SetState(2904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2901)
				p.Match(KotlinParserNL)
			}

			p.SetState(2906)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2907)
			p.ClassBody()
		}

	}

	return localctx
}

// IThisExpressionContext is an interface to support dynamic dispatch.
type IThisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THIS() antlr.TerminalNode
	THIS_AT() antlr.TerminalNode

	// IsThisExpressionContext differentiates from other interfaces.
	IsThisExpressionContext()
}

type ThisExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisExpressionContext() *ThisExpressionContext {
	var p = new(ThisExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_thisExpression
	return p
}

func (*ThisExpressionContext) IsThisExpressionContext() {}

func NewThisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_thisExpression

	return p
}

func (s *ThisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThisExpressionContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ThisExpressionContext) THIS_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS_AT, 0)
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (p *KotlinParser) ThisExpression() (localctx IThisExpressionContext) {
	this := p
	_ = this

	localctx = NewThisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, KotlinParserRULE_thisExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2910)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserTHIS_AT || _la == KotlinParserTHIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISuperExpressionContext is an interface to support dynamic dispatch.
type ISuperExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUPER() antlr.TerminalNode
	LANGLE() antlr.TerminalNode
	Type_() ITypeContext
	RANGLE() antlr.TerminalNode
	AT_NO_WS() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	SUPER_AT() antlr.TerminalNode

	// IsSuperExpressionContext differentiates from other interfaces.
	IsSuperExpressionContext()
}

type SuperExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperExpressionContext() *SuperExpressionContext {
	var p = new(SuperExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_superExpression
	return p
}

func (*SuperExpressionContext) IsSuperExpressionContext() {}

func NewSuperExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_superExpression

	return p
}

func (s *SuperExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperExpressionContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *SuperExpressionContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *SuperExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SuperExpressionContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *SuperExpressionContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *SuperExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SuperExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SuperExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SuperExpressionContext) SUPER_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER_AT, 0)
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

func (p *KotlinParser) SuperExpression() (localctx ISuperExpressionContext) {
	this := p
	_ = this

	localctx = NewSuperExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, KotlinParserRULE_superExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2936)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2912)
			p.Match(KotlinParserSUPER)
		}
		p.SetState(2929)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 446, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2913)
				p.Match(KotlinParserLANGLE)
			}
			p.SetState(2917)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2914)
					p.Match(KotlinParserNL)
				}

				p.SetState(2919)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2920)
				p.Type_()
			}
			p.SetState(2924)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2921)
					p.Match(KotlinParserNL)
				}

				p.SetState(2926)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2927)
				p.Match(KotlinParserRANGLE)
			}

		}
		p.SetState(2933)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 447, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2931)
				p.Match(KotlinParserAT_NO_WS)
			}
			{
				p.SetState(2932)
				p.SimpleIdentifier()
			}

		}

	case KotlinParserSUPER_AT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2935)
			p.Match(KotlinParserSUPER_AT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfExpressionContext is an interface to support dynamic dispatch.
type IIfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllControlStructureBody() []IControlStructureBodyContext
	ControlStructureBody(i int) IControlStructureBodyContext
	ELSE() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsIfExpressionContext differentiates from other interfaces.
	IsIfExpressionContext()
}

type IfExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExpressionContext() *IfExpressionContext {
	var p = new(IfExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_ifExpression
	return p
}

func (*IfExpressionContext) IsIfExpressionContext() {}

func NewIfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExpressionContext {
	var p = new(IfExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_ifExpression

	return p
}

func (s *IfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(KotlinParserIF, 0)
}

func (s *IfExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *IfExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *IfExpressionContext) AllControlStructureBody() []IControlStructureBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			len++
		}
	}

	tst := make([]IControlStructureBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IControlStructureBodyContext); ok {
			tst[i] = t.(IControlStructureBodyContext)
			i++
		}
	}

	return tst
}

func (s *IfExpressionContext) ControlStructureBody(i int) IControlStructureBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *IfExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *IfExpressionContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserSEMICOLON)
}

func (s *IfExpressionContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, i)
}

func (s *IfExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IfExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIfExpression(s)
	}
}

func (s *IfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIfExpression(s)
	}
}

func (p *KotlinParser) IfExpression() (localctx IIfExpressionContext) {
	this := p
	_ = this

	localctx = NewIfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, KotlinParserRULE_ifExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2938)
		p.Match(KotlinParserIF)
	}
	p.SetState(2942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2939)
			p.Match(KotlinParserNL)
		}

		p.SetState(2944)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2945)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2949)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2946)
			p.Match(KotlinParserNL)
		}

		p.SetState(2951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2952)
		p.Expression()
	}
	p.SetState(2956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2953)
			p.Match(KotlinParserNL)
		}

		p.SetState(2958)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2959)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2963)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 452, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2960)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2965)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 452, p.GetParserRuleContext())
	}
	p.SetState(2997)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 459, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2966)
			p.ControlStructureBody()
		}

	case 2:
		p.SetState(2968)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-144109553024488960) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4260645306497) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&13629951) != 0) {
			{
				p.SetState(2967)
				p.ControlStructureBody()
			}

		}
		p.SetState(2973)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 454, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2970)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2975)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 454, p.GetParserRuleContext())
		}
		p.SetState(2977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserSEMICOLON {
			{
				p.SetState(2976)
				p.Match(KotlinParserSEMICOLON)
			}

		}
		p.SetState(2982)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2979)
				p.Match(KotlinParserNL)
			}

			p.SetState(2984)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2985)
			p.Match(KotlinParserELSE)
		}
		p.SetState(2989)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2986)
				p.Match(KotlinParserNL)
			}

			p.SetState(2991)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2994)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
			{
				p.SetState(2992)
				p.ControlStructureBody()
			}

		case KotlinParserSEMICOLON:
			{
				p.SetState(2993)
				p.Match(KotlinParserSEMICOLON)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		{
			p.SetState(2996)
			p.Match(KotlinParserSEMICOLON)
		}

	}

	return localctx
}

// IWhenSubjectContext is an interface to support dynamic dispatch.
type IWhenSubjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	VAL() antlr.TerminalNode
	VariableDeclaration() IVariableDeclarationContext
	ASSIGNMENT() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsWhenSubjectContext differentiates from other interfaces.
	IsWhenSubjectContext()
}

type WhenSubjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenSubjectContext() *WhenSubjectContext {
	var p = new(WhenSubjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenSubject
	return p
}

func (*WhenSubjectContext) IsWhenSubjectContext() {}

func NewWhenSubjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenSubjectContext {
	var p = new(WhenSubjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenSubject

	return p
}

func (s *WhenSubjectContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenSubjectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhenSubjectContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenSubjectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhenSubjectContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *WhenSubjectContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *WhenSubjectContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *WhenSubjectContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *WhenSubjectContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *WhenSubjectContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenSubjectContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenSubjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenSubjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenSubjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenSubject(s)
	}
}

func (s *WhenSubjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenSubject(s)
	}
}

func (p *KotlinParser) WhenSubject() (localctx IWhenSubjectContext) {
	this := p
	_ = this

	localctx = NewWhenSubjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, KotlinParserRULE_whenSubject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2999)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(3033)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 1 {
		p.SetState(3003)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
			{
				p.SetState(3000)
				p.Annotation()
			}

			p.SetState(3005)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3006)
				p.Match(KotlinParserNL)
			}

			p.SetState(3011)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3012)
			p.Match(KotlinParserVAL)
		}
		p.SetState(3016)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 462, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3013)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(3018)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 462, p.GetParserRuleContext())
		}
		{
			p.SetState(3019)
			p.VariableDeclaration()
		}
		p.SetState(3023)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3020)
				p.Match(KotlinParserNL)
			}

			p.SetState(3025)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3026)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(3030)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3027)
				p.Match(KotlinParserNL)
			}

			p.SetState(3032)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3035)
		p.Expression()
	}
	{
		p.SetState(3036)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	LCURL() antlr.TerminalNode
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	WhenSubject() IWhenSubjectContext
	AllWhenEntry() []IWhenEntryContext
	WhenEntry(i int) IWhenEntryContext

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenExpression
	return p
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHEN, 0)
}

func (s *WhenExpressionContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *WhenExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *WhenExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenExpressionContext) WhenSubject() IWhenSubjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenSubjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenSubjectContext)
}

func (s *WhenExpressionContext) AllWhenEntry() []IWhenEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenEntryContext); ok {
			len++
		}
	}

	tst := make([]IWhenEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenEntryContext); ok {
			tst[i] = t.(IWhenEntryContext)
			i++
		}
	}

	return tst
}

func (s *WhenExpressionContext) WhenEntry(i int) IWhenEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenEntryContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (p *KotlinParser) WhenExpression() (localctx IWhenExpressionContext) {
	this := p
	_ = this

	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, KotlinParserRULE_whenExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3038)
		p.Match(KotlinParserWHEN)
	}
	p.SetState(3042)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3039)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3044)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext())
	}
	p.SetState(3046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLPAREN {
		{
			p.SetState(3045)
			p.WhenSubject()
		}

	}
	p.SetState(3051)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3048)
			p.Match(KotlinParserNL)
		}

		p.SetState(3053)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3054)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(3058)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 469, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3055)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3060)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 469, p.GetParserRuleContext())
	}
	p.SetState(3070)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-144109553024488960) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-144959399553) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&13629951) != 0) {
		{
			p.SetState(3061)
			p.WhenEntry()
		}
		p.SetState(3065)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 470, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3062)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(3067)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 470, p.GetParserRuleContext())
		}

		p.SetState(3072)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3076)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3073)
			p.Match(KotlinParserNL)
		}

		p.SetState(3078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3079)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IWhenEntryContext is an interface to support dynamic dispatch.
type IWhenEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWhenCondition() []IWhenConditionContext
	WhenCondition(i int) IWhenConditionContext
	ARROW() antlr.TerminalNode
	ControlStructureBody() IControlStructureBodyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	Semi() ISemiContext
	ELSE() antlr.TerminalNode

	// IsWhenEntryContext differentiates from other interfaces.
	IsWhenEntryContext()
}

type WhenEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenEntryContext() *WhenEntryContext {
	var p = new(WhenEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenEntry
	return p
}

func (*WhenEntryContext) IsWhenEntryContext() {}

func NewWhenEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenEntryContext {
	var p = new(WhenEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenEntry

	return p
}

func (s *WhenEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenEntryContext) AllWhenCondition() []IWhenConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenConditionContext); ok {
			len++
		}
	}

	tst := make([]IWhenConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenConditionContext); ok {
			tst[i] = t.(IWhenConditionContext)
			i++
		}
	}

	return tst
}

func (s *WhenEntryContext) WhenCondition(i int) IWhenConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *WhenEntryContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *WhenEntryContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhenEntryContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *WhenEntryContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *WhenEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenEntryContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *WhenEntryContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *WhenEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenEntry(s)
	}
}

func (s *WhenEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenEntry(s)
	}
}

func (p *KotlinParser) WhenEntry() (localctx IWhenEntryContext) {
	this := p
	_ = this

	localctx = NewWhenEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, KotlinParserRULE_whenEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3145)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserFUN, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserIS, KotlinParserIN, KotlinParserNOT_IS, KotlinParserNOT_IN, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3081)
			p.WhenCondition()
		}
		p.SetState(3098)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 475, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(3085)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3082)
						p.Match(KotlinParserNL)
					}

					p.SetState(3087)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3088)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(3092)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3089)
						p.Match(KotlinParserNL)
					}

					p.SetState(3094)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3095)
					p.WhenCondition()
				}

			}
			p.SetState(3100)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 475, p.GetParserRuleContext())
		}
		p.SetState(3108)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 477, p.GetParserRuleContext()) == 1 {
			p.SetState(3104)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3101)
					p.Match(KotlinParserNL)
				}

				p.SetState(3106)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3107)
				p.Match(KotlinParserCOMMA)
			}

		}
		p.SetState(3113)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3110)
				p.Match(KotlinParserNL)
			}

			p.SetState(3115)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3116)
			p.Match(KotlinParserARROW)
		}
		p.SetState(3120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3117)
				p.Match(KotlinParserNL)
			}

			p.SetState(3122)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3123)
			p.ControlStructureBody()
		}
		p.SetState(3125)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 480, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3124)
				p.Semi()
			}

		}

	case KotlinParserELSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3127)
			p.Match(KotlinParserELSE)
		}
		p.SetState(3131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3128)
				p.Match(KotlinParserNL)
			}

			p.SetState(3133)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3134)
			p.Match(KotlinParserARROW)
		}
		p.SetState(3138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3135)
				p.Match(KotlinParserNL)
			}

			p.SetState(3140)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3141)
			p.ControlStructureBody()
		}
		p.SetState(3143)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3142)
				p.Semi()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenConditionContext is an interface to support dynamic dispatch.
type IWhenConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	RangeTest() IRangeTestContext
	TypeTest() ITypeTestContext

	// IsWhenConditionContext differentiates from other interfaces.
	IsWhenConditionContext()
}

type WhenConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenConditionContext() *WhenConditionContext {
	var p = new(WhenConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenCondition
	return p
}

func (*WhenConditionContext) IsWhenConditionContext() {}

func NewWhenConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenConditionContext {
	var p = new(WhenConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenCondition

	return p
}

func (s *WhenConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenConditionContext) RangeTest() IRangeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeTestContext)
}

func (s *WhenConditionContext) TypeTest() ITypeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTestContext)
}

func (s *WhenConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenCondition(s)
	}
}

func (s *WhenConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenCondition(s)
	}
}

func (p *KotlinParser) WhenCondition() (localctx IWhenConditionContext) {
	this := p
	_ = this

	localctx = NewWhenConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, KotlinParserRULE_whenCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3150)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserFUN, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3147)
			p.Expression()
		}

	case KotlinParserIN, KotlinParserNOT_IN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3148)
			p.RangeTest()
		}

	case KotlinParserIS, KotlinParserNOT_IS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3149)
			p.TypeTest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRangeTestContext is an interface to support dynamic dispatch.
type IRangeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InOperator() IInOperatorContext
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsRangeTestContext differentiates from other interfaces.
	IsRangeTestContext()
}

type RangeTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeTestContext() *RangeTestContext {
	var p = new(RangeTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeTest
	return p
}

func (*RangeTestContext) IsRangeTestContext() {}

func NewRangeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeTestContext {
	var p = new(RangeTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeTest

	return p
}

func (s *RangeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeTestContext) InOperator() IInOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *RangeTestContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeTest(s)
	}
}

func (s *RangeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeTest(s)
	}
}

func (p *KotlinParser) RangeTest() (localctx IRangeTestContext) {
	this := p
	_ = this

	localctx = NewRangeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, KotlinParserRULE_rangeTest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3152)
		p.InOperator()
	}
	p.SetState(3156)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3153)
			p.Match(KotlinParserNL)
		}

		p.SetState(3158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3159)
		p.Expression()
	}

	return localctx
}

// ITypeTestContext is an interface to support dynamic dispatch.
type ITypeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IsOperator() IIsOperatorContext
	Type_() ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsTypeTestContext differentiates from other interfaces.
	IsTypeTestContext()
}

type TypeTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTestContext() *TypeTestContext {
	var p = new(TypeTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeTest
	return p
}

func (*TypeTestContext) IsTypeTestContext() {}

func NewTypeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTestContext {
	var p = new(TypeTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeTest

	return p
}

func (s *TypeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTestContext) IsOperator() IIsOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *TypeTestContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeTest(s)
	}
}

func (s *TypeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeTest(s)
	}
}

func (p *KotlinParser) TypeTest() (localctx ITypeTestContext) {
	this := p
	_ = this

	localctx = NewTypeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, KotlinParserRULE_typeTest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3161)
		p.IsOperator()
	}
	p.SetState(3165)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3162)
			p.Match(KotlinParserNL)
		}

		p.SetState(3167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3168)
		p.Type_()
	}

	return localctx
}

// ITryExpressionContext is an interface to support dynamic dispatch.
type ITryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Block() IBlockContext
	FinallyBlock() IFinallyBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCatchBlock() []ICatchBlockContext
	CatchBlock(i int) ICatchBlockContext

	// IsTryExpressionContext differentiates from other interfaces.
	IsTryExpressionContext()
}

type TryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExpressionContext() *TryExpressionContext {
	var p = new(TryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_tryExpression
	return p
}

func (*TryExpressionContext) IsTryExpressionContext() {}

func NewTryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExpressionContext {
	var p = new(TryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_tryExpression

	return p
}

func (s *TryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExpressionContext) TRY() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRY, 0)
}

func (s *TryExpressionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryExpressionContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TryExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TryExpressionContext) AllCatchBlock() []ICatchBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchBlockContext); ok {
			len++
		}
	}

	tst := make([]ICatchBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchBlockContext); ok {
			tst[i] = t.(ICatchBlockContext)
			i++
		}
	}

	return tst
}

func (s *TryExpressionContext) CatchBlock(i int) ICatchBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchBlockContext)
}

func (s *TryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTryExpression(s)
	}
}

func (s *TryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTryExpression(s)
	}
}

func (p *KotlinParser) TryExpression() (localctx ITryExpressionContext) {
	this := p
	_ = this

	localctx = NewTryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, KotlinParserRULE_tryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3170)
		p.Match(KotlinParserTRY)
	}
	p.SetState(3174)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3171)
			p.Match(KotlinParserNL)
		}

		p.SetState(3176)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3177)
		p.Block()
	}
	p.SetState(3205)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 494, p.GetParserRuleContext()) {
	case 1:
		p.SetState(3185)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(3181)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3178)
						p.Match(KotlinParserNL)
					}

					p.SetState(3183)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3184)
					p.CatchBlock()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3187)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 490, p.GetParserRuleContext())
		}
		p.SetState(3196)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 492, p.GetParserRuleContext()) == 1 {
			p.SetState(3192)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3189)
					p.Match(KotlinParserNL)
				}

				p.SetState(3194)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3195)
				p.FinallyBlock()
			}

		}

	case 2:
		p.SetState(3201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3198)
				p.Match(KotlinParserNL)
			}

			p.SetState(3203)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3204)
			p.FinallyBlock()
		}

	}

	return localctx
}

// ICatchBlockContext is an interface to support dynamic dispatch.
type ICatchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	COMMA() antlr.TerminalNode

	// IsCatchBlockContext differentiates from other interfaces.
	IsCatchBlockContext()
}

type CatchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchBlockContext() *CatchBlockContext {
	var p = new(CatchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_catchBlock
	return p
}

func (*CatchBlockContext) IsCatchBlockContext() {}

func NewCatchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchBlockContext {
	var p = new(CatchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_catchBlock

	return p
}

func (s *CatchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchBlockContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *CatchBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *CatchBlockContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CatchBlockContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CatchBlockContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CatchBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *CatchBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CatchBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CatchBlockContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *CatchBlockContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *CatchBlockContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, 0)
}

func (s *CatchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCatchBlock(s)
	}
}

func (s *CatchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCatchBlock(s)
	}
}

func (p *KotlinParser) CatchBlock() (localctx ICatchBlockContext) {
	this := p
	_ = this

	localctx = NewCatchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, KotlinParserRULE_catchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3207)
		p.Match(KotlinParserCATCH)
	}
	p.SetState(3211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3208)
			p.Match(KotlinParserNL)
		}

		p.SetState(3213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3214)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(3218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(3215)
			p.Annotation()
		}

		p.SetState(3220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3221)
		p.SimpleIdentifier()
	}
	{
		p.SetState(3222)
		p.Match(KotlinParserCOLON)
	}
	{
		p.SetState(3223)
		p.Type_()
	}
	p.SetState(3231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserNL || _la == KotlinParserCOMMA {
		p.SetState(3227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3224)
				p.Match(KotlinParserNL)
			}

			p.SetState(3229)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3230)
			p.Match(KotlinParserCOMMA)
		}

	}
	{
		p.SetState(3233)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(3237)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3234)
			p.Match(KotlinParserNL)
		}

		p.SetState(3239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3240)
		p.Block()
	}

	return localctx
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Block() IBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_finallyBlock
	return p
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FinallyBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (p *KotlinParser) FinallyBlock() (localctx IFinallyBlockContext) {
	this := p
	_ = this

	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, KotlinParserRULE_finallyBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3242)
		p.Match(KotlinParserFINALLY)
	}
	p.SetState(3246)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3243)
			p.Match(KotlinParserNL)
		}

		p.SetState(3248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3249)
		p.Block()
	}

	return localctx
}

// IJumpExpressionContext is an interface to support dynamic dispatch.
type IJumpExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THROW() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	RETURN() antlr.TerminalNode
	RETURN_AT() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	CONTINUE_AT() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	BREAK_AT() antlr.TerminalNode

	// IsJumpExpressionContext differentiates from other interfaces.
	IsJumpExpressionContext()
}

type JumpExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpExpressionContext() *JumpExpressionContext {
	var p = new(JumpExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_jumpExpression
	return p
}

func (*JumpExpressionContext) IsJumpExpressionContext() {}

func NewJumpExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpExpressionContext {
	var p = new(JumpExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_jumpExpression

	return p
}

func (s *JumpExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpExpressionContext) THROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHROW, 0)
}

func (s *JumpExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *JumpExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *JumpExpressionContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN, 0)
}

func (s *JumpExpressionContext) RETURN_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN_AT, 0)
}

func (s *JumpExpressionContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE, 0)
}

func (s *JumpExpressionContext) CONTINUE_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE_AT, 0)
}

func (s *JumpExpressionContext) BREAK() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK, 0)
}

func (s *JumpExpressionContext) BREAK_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK_AT, 0)
}

func (s *JumpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterJumpExpression(s)
	}
}

func (s *JumpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitJumpExpression(s)
	}
}

func (p *KotlinParser) JumpExpression() (localctx IJumpExpressionContext) {
	this := p
	_ = this

	localctx = NewJumpExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, KotlinParserRULE_jumpExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3267)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserTHROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3251)
			p.Match(KotlinParserTHROW)
		}
		p.SetState(3255)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3252)
				p.Match(KotlinParserNL)
			}

			p.SetState(3257)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3258)
			p.Expression()
		}

	case KotlinParserRETURN_AT, KotlinParserRETURN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3259)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserRETURN_AT || _la == KotlinParserRETURN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3261)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 502, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3260)
				p.Expression()
			}

		}

	case KotlinParserCONTINUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3263)
			p.Match(KotlinParserCONTINUE)
		}

	case KotlinParserCONTINUE_AT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3264)
			p.Match(KotlinParserCONTINUE_AT)
		}

	case KotlinParserBREAK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3265)
			p.Match(KotlinParserBREAK)
		}

	case KotlinParserBREAK_AT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3266)
			p.Match(KotlinParserBREAK_AT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallableReferenceContext is an interface to support dynamic dispatch.
type ICallableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLONCOLON() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	CLASS() antlr.TerminalNode
	ReceiverType() IReceiverTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsCallableReferenceContext differentiates from other interfaces.
	IsCallableReferenceContext()
}

type CallableReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallableReferenceContext() *CallableReferenceContext {
	var p = new(CallableReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_callableReference
	return p
}

func (*CallableReferenceContext) IsCallableReferenceContext() {}

func NewCallableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallableReferenceContext {
	var p = new(CallableReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callableReference

	return p
}

func (s *CallableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallableReferenceContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLONCOLON, 0)
}

func (s *CallableReferenceContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CallableReferenceContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *CallableReferenceContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *CallableReferenceContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CallableReferenceContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CallableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallableReference(s)
	}
}

func (s *CallableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallableReference(s)
	}
}

func (p *KotlinParser) CallableReference() (localctx ICallableReferenceContext) {
	this := p
	_ = this

	localctx = NewCallableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, KotlinParserRULE_callableReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3270)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611680520869248512) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4397231832705) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&524543) != 0) {
		{
			p.SetState(3269)
			p.ReceiverType()
		}

	}
	{
		p.SetState(3272)
		p.Match(KotlinParserCOLONCOLON)
	}
	p.SetState(3276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3273)
			p.Match(KotlinParserNL)
		}

		p.SetState(3278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3281)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(3279)
			p.SimpleIdentifier()
		}

	case KotlinParserCLASS:
		{
			p.SetState(3280)
			p.Match(KotlinParserCLASS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentAndOperatorContext is an interface to support dynamic dispatch.
type IAssignmentAndOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_ASSIGNMENT() antlr.TerminalNode
	SUB_ASSIGNMENT() antlr.TerminalNode
	MULT_ASSIGNMENT() antlr.TerminalNode
	DIV_ASSIGNMENT() antlr.TerminalNode
	MOD_ASSIGNMENT() antlr.TerminalNode

	// IsAssignmentAndOperatorContext differentiates from other interfaces.
	IsAssignmentAndOperatorContext()
}

type AssignmentAndOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentAndOperatorContext() *AssignmentAndOperatorContext {
	var p = new(AssignmentAndOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignmentAndOperator
	return p
}

func (*AssignmentAndOperatorContext) IsAssignmentAndOperatorContext() {}

func NewAssignmentAndOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentAndOperatorContext {
	var p = new(AssignmentAndOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignmentAndOperator

	return p
}

func (s *AssignmentAndOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentAndOperatorContext) ADD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) SUB_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) MULT_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) DIV_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) MOD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentAndOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentAndOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignmentAndOperator(s)
	}
}

func (s *AssignmentAndOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignmentAndOperator(s)
	}
}

func (p *KotlinParser) AssignmentAndOperator() (localctx IAssignmentAndOperatorContext) {
	this := p
	_ = this

	localctx = NewAssignmentAndOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, KotlinParserRULE_assignmentAndOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3283)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16642998272) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEqualityOperatorContext is an interface to support dynamic dispatch.
type IEqualityOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCL_EQ() antlr.TerminalNode
	EXCL_EQEQ() antlr.TerminalNode
	EQEQ() antlr.TerminalNode
	EQEQEQ() antlr.TerminalNode

	// IsEqualityOperatorContext differentiates from other interfaces.
	IsEqualityOperatorContext()
}

type EqualityOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityOperatorContext() *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_equalityOperator
	return p
}

func (*EqualityOperatorContext) IsEqualityOperatorContext() {}

func NewEqualityOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equalityOperator

	return p
}

func (s *EqualityOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityOperatorContext) EXCL_EQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQ, 0)
}

func (s *EqualityOperatorContext) EXCL_EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQEQ, 0)
}

func (s *EqualityOperatorContext) EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQ, 0)
}

func (s *EqualityOperatorContext) EQEQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQEQ, 0)
}

func (s *EqualityOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEqualityOperator(s)
	}
}

func (s *EqualityOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEqualityOperator(s)
	}
}

func (p *KotlinParser) EqualityOperator() (localctx IEqualityOperatorContext) {
	this := p
	_ = this

	localctx = NewEqualityOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, KotlinParserRULE_equalityOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3285)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&30399297484750848) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGLE() antlr.TerminalNode
	RANGLE() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *ComparisonOperatorContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *ComparisonOperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLE, 0)
}

func (s *ComparisonOperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(KotlinParserGE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *KotlinParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, KotlinParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3287)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1055531162664960) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInOperatorContext is an interface to support dynamic dispatch.
type IInOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN() antlr.TerminalNode
	NOT_IN() antlr.TerminalNode

	// IsInOperatorContext differentiates from other interfaces.
	IsInOperatorContext()
}

type InOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInOperatorContext() *InOperatorContext {
	var p = new(InOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_inOperator
	return p
}

func (*InOperatorContext) IsInOperatorContext() {}

func NewInOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InOperatorContext {
	var p = new(InOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inOperator

	return p
}

func (s *InOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *InOperatorContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IN, 0)
}

func (s *InOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInOperator(s)
	}
}

func (s *InOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInOperator(s)
	}
}

func (p *KotlinParser) InOperator() (localctx IInOperatorContext) {
	this := p
	_ = this

	localctx = NewInOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, KotlinParserRULE_inOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3289)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserNOT_IN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIsOperatorContext is an interface to support dynamic dispatch.
type IIsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	NOT_IS() antlr.TerminalNode

	// IsIsOperatorContext differentiates from other interfaces.
	IsIsOperatorContext()
}

type IsOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsOperatorContext() *IsOperatorContext {
	var p = new(IsOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_isOperator
	return p
}

func (*IsOperatorContext) IsIsOperatorContext() {}

func NewIsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsOperatorContext {
	var p = new(IsOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_isOperator

	return p
}

func (s *IsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *IsOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserIS, 0)
}

func (s *IsOperatorContext) NOT_IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IS, 0)
}

func (s *IsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIsOperator(s)
	}
}

func (s *IsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIsOperator(s)
	}
}

func (p *KotlinParser) IsOperator() (localctx IIsOperatorContext) {
	this := p
	_ = this

	localctx = NewIsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, KotlinParserRULE_isOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3291)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIS || _la == KotlinParserNOT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAdditiveOperatorContext is an interface to support dynamic dispatch.
type IAdditiveOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsAdditiveOperatorContext differentiates from other interfaces.
	IsAdditiveOperatorContext()
}

type AdditiveOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveOperatorContext() *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveOperator
	return p
}

func (*AdditiveOperatorContext) IsAdditiveOperatorContext() {}

func NewAdditiveOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveOperator

	return p
}

func (s *AdditiveOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *AdditiveOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *AdditiveOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveOperator(s)
	}
}

func (s *AdditiveOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveOperator(s)
	}
}

func (p *KotlinParser) AdditiveOperator() (localctx IAdditiveOperatorContext) {
	this := p
	_ = this

	localctx = NewAdditiveOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, KotlinParserRULE_additiveOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3293)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserADD || _la == KotlinParserSUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiplicativeOperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULT() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultiplicativeOperatorContext differentiates from other interfaces.
	IsMultiplicativeOperatorContext()
}

type MultiplicativeOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeOperatorContext() *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeOperator
	return p
}

func (*MultiplicativeOperatorContext) IsMultiplicativeOperatorContext() {}

func NewMultiplicativeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeOperator

	return p
}

func (s *MultiplicativeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeOperatorContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *MultiplicativeOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV, 0)
}

func (s *MultiplicativeOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD, 0)
}

func (s *MultiplicativeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeOperator(s)
	}
}

func (s *MultiplicativeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeOperator(s)
	}
}

func (p *KotlinParser) MultiplicativeOperator() (localctx IMultiplicativeOperatorContext) {
	this := p
	_ = this

	localctx = NewMultiplicativeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, KotlinParserRULE_multiplicativeOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3295)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&229376) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAsOperatorContext is an interface to support dynamic dispatch.
type IAsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	AS_SAFE() antlr.TerminalNode

	// IsAsOperatorContext differentiates from other interfaces.
	IsAsOperatorContext()
}

type AsOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsOperatorContext() *AsOperatorContext {
	var p = new(AsOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_asOperator
	return p
}

func (*AsOperatorContext) IsAsOperatorContext() {}

func NewAsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsOperatorContext {
	var p = new(AsOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_asOperator

	return p
}

func (s *AsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AsOperatorContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *AsOperatorContext) AS_SAFE() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS_SAFE, 0)
}

func (s *AsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAsOperator(s)
	}
}

func (s *AsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAsOperator(s)
	}
}

func (p *KotlinParser) AsOperator() (localctx IAsOperatorContext) {
	this := p
	_ = this

	localctx = NewAsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, KotlinParserRULE_asOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3297)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAS_SAFE || _la == KotlinParserAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrefixUnaryOperatorContext is an interface to support dynamic dispatch.
type IPrefixUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INCR() antlr.TerminalNode
	DECR() antlr.TerminalNode
	SUB() antlr.TerminalNode
	ADD() antlr.TerminalNode
	Excl() IExclContext

	// IsPrefixUnaryOperatorContext differentiates from other interfaces.
	IsPrefixUnaryOperatorContext()
}

type PrefixUnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryOperatorContext() *PrefixUnaryOperatorContext {
	var p = new(PrefixUnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperator
	return p
}

func (*PrefixUnaryOperatorContext) IsPrefixUnaryOperatorContext() {}

func NewPrefixUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryOperatorContext {
	var p = new(PrefixUnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperator

	return p
}

func (s *PrefixUnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryOperatorContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PrefixUnaryOperatorContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PrefixUnaryOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *PrefixUnaryOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *PrefixUnaryOperatorContext) Excl() IExclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclContext)
}

func (s *PrefixUnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryOperator(s)
	}
}

func (s *PrefixUnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryOperator(s)
	}
}

func (p *KotlinParser) PrefixUnaryOperator() (localctx IPrefixUnaryOperatorContext) {
	this := p
	_ = this

	localctx = NewPrefixUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, KotlinParserRULE_prefixUnaryOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3304)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserINCR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3299)
			p.Match(KotlinParserINCR)
		}

	case KotlinParserDECR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3300)
			p.Match(KotlinParserDECR)
		}

	case KotlinParserSUB:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3301)
			p.Match(KotlinParserSUB)
		}

	case KotlinParserADD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3302)
			p.Match(KotlinParserADD)
		}

	case KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3303)
			p.Excl()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPostfixUnaryOperatorContext is an interface to support dynamic dispatch.
type IPostfixUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INCR() antlr.TerminalNode
	DECR() antlr.TerminalNode
	EXCL_NO_WS() antlr.TerminalNode
	Excl() IExclContext

	// IsPostfixUnaryOperatorContext differentiates from other interfaces.
	IsPostfixUnaryOperatorContext()
}

type PostfixUnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryOperatorContext() *PostfixUnaryOperatorContext {
	var p = new(PostfixUnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperator
	return p
}

func (*PostfixUnaryOperatorContext) IsPostfixUnaryOperatorContext() {}

func NewPostfixUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryOperatorContext {
	var p = new(PostfixUnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperator

	return p
}

func (s *PostfixUnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryOperatorContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PostfixUnaryOperatorContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PostfixUnaryOperatorContext) EXCL_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_NO_WS, 0)
}

func (s *PostfixUnaryOperatorContext) Excl() IExclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclContext)
}

func (s *PostfixUnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryOperator(s)
	}
}

func (s *PostfixUnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryOperator(s)
	}
}

func (p *KotlinParser) PostfixUnaryOperator() (localctx IPostfixUnaryOperatorContext) {
	this := p
	_ = this

	localctx = NewPostfixUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, KotlinParserRULE_postfixUnaryOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3310)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserINCR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3306)
			p.Match(KotlinParserINCR)
		}

	case KotlinParserDECR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3307)
			p.Match(KotlinParserDECR)
		}

	case KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3308)
			p.Match(KotlinParserEXCL_NO_WS)
		}
		{
			p.SetState(3309)
			p.Excl()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExclContext is an interface to support dynamic dispatch.
type IExclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCL_NO_WS() antlr.TerminalNode
	EXCL_WS() antlr.TerminalNode

	// IsExclContext differentiates from other interfaces.
	IsExclContext()
}

type ExclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclContext() *ExclContext {
	var p = new(ExclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_excl
	return p
}

func (*ExclContext) IsExclContext() {}

func NewExclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclContext {
	var p = new(ExclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_excl

	return p
}

func (s *ExclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclContext) EXCL_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_NO_WS, 0)
}

func (s *ExclContext) EXCL_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_WS, 0)
}

func (s *ExclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExcl(s)
	}
}

func (s *ExclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExcl(s)
	}
}

func (p *KotlinParser) Excl() (localctx IExclContext) {
	this := p
	_ = this

	localctx = NewExclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, KotlinParserRULE_excl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3312)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserEXCL_WS || _la == KotlinParserEXCL_NO_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberAccessOperatorContext is an interface to support dynamic dispatch.
type IMemberAccessOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	SafeNav() ISafeNavContext
	COLONCOLON() antlr.TerminalNode

	// IsMemberAccessOperatorContext differentiates from other interfaces.
	IsMemberAccessOperatorContext()
}

type MemberAccessOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessOperatorContext() *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_memberAccessOperator
	return p
}

func (*MemberAccessOperatorContext) IsMemberAccessOperatorContext() {}

func NewMemberAccessOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberAccessOperator

	return p
}

func (s *MemberAccessOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessOperatorContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *MemberAccessOperatorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MemberAccessOperatorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MemberAccessOperatorContext) SafeNav() ISafeNavContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISafeNavContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISafeNavContext)
}

func (s *MemberAccessOperatorContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLONCOLON, 0)
}

func (s *MemberAccessOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberAccessOperator(s)
	}
}

func (s *MemberAccessOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberAccessOperator(s)
	}
}

func (p *KotlinParser) MemberAccessOperator() (localctx IMemberAccessOperatorContext) {
	this := p
	_ = this

	localctx = NewMemberAccessOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, KotlinParserRULE_memberAccessOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3329)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 511, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3314)
				p.Match(KotlinParserNL)
			}

			p.SetState(3319)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3320)
			p.Match(KotlinParserDOT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3321)
				p.Match(KotlinParserNL)
			}

			p.SetState(3326)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3327)
			p.SafeNav()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3328)
			p.Match(KotlinParserCOLONCOLON)
		}

	}

	return localctx
}

// ISafeNavContext is an interface to support dynamic dispatch.
type ISafeNavContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUEST_NO_WS() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsSafeNavContext differentiates from other interfaces.
	IsSafeNavContext()
}

type SafeNavContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySafeNavContext() *SafeNavContext {
	var p = new(SafeNavContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_safeNav
	return p
}

func (*SafeNavContext) IsSafeNavContext() {}

func NewSafeNavContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SafeNavContext {
	var p = new(SafeNavContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_safeNav

	return p
}

func (s *SafeNavContext) GetParser() antlr.Parser { return s.parser }

func (s *SafeNavContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *SafeNavContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *SafeNavContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SafeNavContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SafeNavContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSafeNav(s)
	}
}

func (s *SafeNavContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSafeNav(s)
	}
}

func (p *KotlinParser) SafeNav() (localctx ISafeNavContext) {
	this := p
	_ = this

	localctx = NewSafeNavContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, KotlinParserRULE_safeNav)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3331)
		p.Match(KotlinParserQUEST_NO_WS)
	}
	{
		p.SetState(3332)
		p.Match(KotlinParserDOT)
	}

	return localctx
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_modifiers
	return p
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModifiersContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *KotlinParser) Modifiers() (localctx IModifiersContext) {
	this := p
	_ = this

	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, KotlinParserRULE_modifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3336)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3336)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(3334)
					p.Annotation()
				}

			case KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserEXPECT, KotlinParserACTUAL:
				{
					p.SetState(3335)
					p.Modifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3338)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 513, p.GetParserRuleContext())
	}

	return localctx
}

// IParameterModifiersContext is an interface to support dynamic dispatch.
type IParameterModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllParameterModifier() []IParameterModifierContext
	ParameterModifier(i int) IParameterModifierContext

	// IsParameterModifiersContext differentiates from other interfaces.
	IsParameterModifiersContext()
}

type ParameterModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterModifiersContext() *ParameterModifiersContext {
	var p = new(ParameterModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifiers
	return p
}

func (*ParameterModifiersContext) IsParameterModifiersContext() {}

func NewParameterModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterModifiersContext {
	var p = new(ParameterModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterModifiers

	return p
}

func (s *ParameterModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterModifiersContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ParameterModifiersContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ParameterModifiersContext) AllParameterModifier() []IParameterModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterModifierContext); ok {
			len++
		}
	}

	tst := make([]IParameterModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterModifierContext); ok {
			tst[i] = t.(IParameterModifierContext)
			i++
		}
	}

	return tst
}

func (s *ParameterModifiersContext) ParameterModifier(i int) IParameterModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *ParameterModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterModifiers(s)
	}
}

func (s *ParameterModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterModifiers(s)
	}
}

func (p *KotlinParser) ParameterModifiers() (localctx IParameterModifiersContext) {
	this := p
	_ = this

	localctx = NewParameterModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, KotlinParserRULE_parameterModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3342)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3342)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(3340)
					p.Annotation()
				}

			case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
				{
					p.SetState(3341)
					p.ParameterModifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3344)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 515, p.GetParserRuleContext())
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassModifier() IClassModifierContext
	MemberModifier() IMemberModifierContext
	VisibilityModifier() IVisibilityModifierContext
	FunctionModifier() IFunctionModifierContext
	PropertyModifier() IPropertyModifierContext
	InheritanceModifier() IInheritanceModifierContext
	ParameterModifier() IParameterModifierContext
	PlatformModifier() IPlatformModifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) ClassModifier() IClassModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *ModifierContext) MemberModifier() IMemberModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *ModifierContext) VisibilityModifier() IVisibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityModifierContext)
}

func (s *ModifierContext) FunctionModifier() IFunctionModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionModifierContext)
}

func (s *ModifierContext) PropertyModifier() IPropertyModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyModifierContext)
}

func (s *ModifierContext) InheritanceModifier() IInheritanceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceModifierContext)
}

func (s *ModifierContext) ParameterModifier() IParameterModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *ModifierContext) PlatformModifier() IPlatformModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlatformModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlatformModifierContext)
}

func (s *ModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *KotlinParser) Modifier() (localctx IModifierContext) {
	this := p
	_ = this

	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, KotlinParserRULE_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE:
		{
			p.SetState(3346)
			p.ClassModifier()
		}

	case KotlinParserOVERRIDE, KotlinParserLATEINIT:
		{
			p.SetState(3347)
			p.MemberModifier()
		}

	case KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL:
		{
			p.SetState(3348)
			p.VisibilityModifier()
		}

	case KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND:
		{
			p.SetState(3349)
			p.FunctionModifier()
		}

	case KotlinParserCONST:
		{
			p.SetState(3350)
			p.PropertyModifier()
		}

	case KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN:
		{
			p.SetState(3351)
			p.InheritanceModifier()
		}

	case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
		{
			p.SetState(3352)
			p.ParameterModifier()
		}

	case KotlinParserEXPECT, KotlinParserACTUAL:
		{
			p.SetState(3353)
			p.PlatformModifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3359)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 517, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3356)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3361)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 517, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeModifiersContext is an interface to support dynamic dispatch.
type ITypeModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeModifier() []ITypeModifierContext
	TypeModifier(i int) ITypeModifierContext

	// IsTypeModifiersContext differentiates from other interfaces.
	IsTypeModifiersContext()
}

type TypeModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeModifiersContext() *TypeModifiersContext {
	var p = new(TypeModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifiers
	return p
}

func (*TypeModifiersContext) IsTypeModifiersContext() {}

func NewTypeModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeModifiersContext {
	var p = new(TypeModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeModifiers

	return p
}

func (s *TypeModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeModifiersContext) AllTypeModifier() []ITypeModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeModifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeModifierContext); ok {
			tst[i] = t.(ITypeModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeModifiersContext) TypeModifier(i int) ITypeModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifierContext)
}

func (s *TypeModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeModifiers(s)
	}
}

func (s *TypeModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeModifiers(s)
	}
}

func (p *KotlinParser) TypeModifiers() (localctx ITypeModifiersContext) {
	this := p
	_ = this

	localctx = NewTypeModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, KotlinParserRULE_typeModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3363)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3362)
				p.TypeModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3365)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 518, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeModifierContext is an interface to support dynamic dispatch.
type ITypeModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	SUSPEND() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsTypeModifierContext differentiates from other interfaces.
	IsTypeModifierContext()
}

type TypeModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeModifierContext() *TypeModifierContext {
	var p = new(TypeModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifier
	return p
}

func (*TypeModifierContext) IsTypeModifierContext() {}

func NewTypeModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeModifierContext {
	var p = new(TypeModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeModifier

	return p
}

func (s *TypeModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeModifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *TypeModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeModifier(s)
	}
}

func (s *TypeModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeModifier(s)
	}
}

func (p *KotlinParser) TypeModifier() (localctx ITypeModifierContext) {
	this := p
	_ = this

	localctx = NewTypeModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, KotlinParserRULE_typeModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3367)
			p.Annotation()
		}

	case KotlinParserSUSPEND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3368)
			p.Match(KotlinParserSUSPEND)
		}
		p.SetState(3372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3369)
				p.Match(KotlinParserNL)
			}

			p.SetState(3374)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassModifierContext is an interface to support dynamic dispatch.
type IClassModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	ANNOTATION() antlr.TerminalNode
	DATA() antlr.TerminalNode
	INNER() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsClassModifierContext differentiates from other interfaces.
	IsClassModifierContext()
}

type ClassModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassModifierContext() *ClassModifierContext {
	var p = new(ClassModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classModifier
	return p
}

func (*ClassModifierContext) IsClassModifierContext() {}

func NewClassModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassModifierContext {
	var p = new(ClassModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classModifier

	return p
}

func (s *ClassModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassModifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *ClassModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *ClassModifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *ClassModifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *ClassModifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *ClassModifierContext) VALUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserVALUE, 0)
}

func (s *ClassModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassModifier(s)
	}
}

func (s *ClassModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassModifier(s)
	}
}

func (p *KotlinParser) ClassModifier() (localctx IClassModifierContext) {
	this := p
	_ = this

	localctx = NewClassModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, KotlinParserRULE_classModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3377)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberModifierContext is an interface to support dynamic dispatch.
type IMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVERRIDE() antlr.TerminalNode
	LATEINIT() antlr.TerminalNode

	// IsMemberModifierContext differentiates from other interfaces.
	IsMemberModifierContext()
}

type MemberModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifierContext() *MemberModifierContext {
	var p = new(MemberModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_memberModifier
	return p
}

func (*MemberModifierContext) IsMemberModifierContext() {}

func NewMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifierContext {
	var p = new(MemberModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberModifier

	return p
}

func (s *MemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *MemberModifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *MemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberModifier(s)
	}
}

func (s *MemberModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberModifier(s)
	}
}

func (p *KotlinParser) MemberModifier() (localctx IMemberModifierContext) {
	this := p
	_ = this

	localctx = NewMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, KotlinParserRULE_memberModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3379)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserOVERRIDE || _la == KotlinParserLATEINIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVisibilityModifierContext is an interface to support dynamic dispatch.
type IVisibilityModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUBLIC() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode

	// IsVisibilityModifierContext differentiates from other interfaces.
	IsVisibilityModifierContext()
}

type VisibilityModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityModifierContext() *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_visibilityModifier
	return p
}

func (*VisibilityModifierContext) IsVisibilityModifierContext() {}

func NewVisibilityModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_visibilityModifier

	return p
}

func (s *VisibilityModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *VisibilityModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *VisibilityModifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *VisibilityModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *VisibilityModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVisibilityModifier(s)
	}
}

func (s *VisibilityModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVisibilityModifier(s)
	}
}

func (p *KotlinParser) VisibilityModifier() (localctx IVisibilityModifierContext) {
	this := p
	_ = this

	localctx = NewVisibilityModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, KotlinParserRULE_visibilityModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3381)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-108)) & ^0x3f) == 0 && ((int64(1)<<(_la-108))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVarianceModifierContext is an interface to support dynamic dispatch.
type IVarianceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode

	// IsVarianceModifierContext differentiates from other interfaces.
	IsVarianceModifierContext()
}

type VarianceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarianceModifierContext() *VarianceModifierContext {
	var p = new(VarianceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_varianceModifier
	return p
}

func (*VarianceModifierContext) IsVarianceModifierContext() {}

func NewVarianceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarianceModifierContext {
	var p = new(VarianceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_varianceModifier

	return p
}

func (s *VarianceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarianceModifierContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *VarianceModifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *VarianceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarianceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarianceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVarianceModifier(s)
	}
}

func (s *VarianceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVarianceModifier(s)
	}
}

func (p *KotlinParser) VarianceModifier() (localctx IVarianceModifierContext) {
	this := p
	_ = this

	localctx = NewVarianceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, KotlinParserRULE_varianceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3383)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserOUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeParameterModifiersContext is an interface to support dynamic dispatch.
type ITypeParameterModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeParameterModifier() []ITypeParameterModifierContext
	TypeParameterModifier(i int) ITypeParameterModifierContext

	// IsTypeParameterModifiersContext differentiates from other interfaces.
	IsTypeParameterModifiersContext()
}

type TypeParameterModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifiersContext() *TypeParameterModifiersContext {
	var p = new(TypeParameterModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifiers
	return p
}

func (*TypeParameterModifiersContext) IsTypeParameterModifiersContext() {}

func NewTypeParameterModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifiersContext {
	var p = new(TypeParameterModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameterModifiers

	return p
}

func (s *TypeParameterModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifiersContext) AllTypeParameterModifier() []ITypeParameterModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterModifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterModifierContext); ok {
			tst[i] = t.(ITypeParameterModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterModifiersContext) TypeParameterModifier(i int) ITypeParameterModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifierContext)
}

func (s *TypeParameterModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameterModifiers(s)
	}
}

func (s *TypeParameterModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameterModifiers(s)
	}
}

func (p *KotlinParser) TypeParameterModifiers() (localctx ITypeParameterModifiersContext) {
	this := p
	_ = this

	localctx = NewTypeParameterModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, KotlinParserRULE_typeParameterModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3386)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3385)
				p.TypeParameterModifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3388)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 521, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterModifierContext is an interface to support dynamic dispatch.
type ITypeParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReificationModifier() IReificationModifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	VarianceModifier() IVarianceModifierContext
	Annotation() IAnnotationContext

	// IsTypeParameterModifierContext differentiates from other interfaces.
	IsTypeParameterModifierContext()
}

type TypeParameterModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifierContext() *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifier
	return p
}

func (*TypeParameterModifierContext) IsTypeParameterModifierContext() {}

func NewTypeParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameterModifier

	return p
}

func (s *TypeParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifierContext) ReificationModifier() IReificationModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReificationModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReificationModifierContext)
}

func (s *TypeParameterModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParameterModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParameterModifierContext) VarianceModifier() IVarianceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarianceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarianceModifierContext)
}

func (s *TypeParameterModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameterModifier(s)
	}
}

func (s *TypeParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameterModifier(s)
	}
}

func (p *KotlinParser) TypeParameterModifier() (localctx ITypeParameterModifierContext) {
	this := p
	_ = this

	localctx = NewTypeParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, KotlinParserRULE_typeParameterModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3405)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserREIFIED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3390)
			p.ReificationModifier()
		}
		p.SetState(3394)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 522, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3391)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(3396)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 522, p.GetParserRuleContext())
		}

	case KotlinParserIN, KotlinParserOUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3397)
			p.VarianceModifier()
		}
		p.SetState(3401)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 523, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3398)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(3403)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 523, p.GetParserRuleContext())
		}

	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3404)
			p.Annotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionModifierContext is an interface to support dynamic dispatch.
type IFunctionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAILREC() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	INFIX() antlr.TerminalNode
	INLINE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode

	// IsFunctionModifierContext differentiates from other interfaces.
	IsFunctionModifierContext()
}

type FunctionModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionModifierContext() *FunctionModifierContext {
	var p = new(FunctionModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionModifier
	return p
}

func (*FunctionModifierContext) IsFunctionModifierContext() {}

func NewFunctionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionModifierContext {
	var p = new(FunctionModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionModifier

	return p
}

func (s *FunctionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionModifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *FunctionModifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *FunctionModifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *FunctionModifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *FunctionModifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *FunctionModifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *FunctionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionModifier(s)
	}
}

func (s *FunctionModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionModifier(s)
	}
}

func (p *KotlinParser) FunctionModifier() (localctx IFunctionModifierContext) {
	this := p
	_ = this

	localctx = NewFunctionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, KotlinParserRULE_functionModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3407)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-118)) & ^0x3f) == 0 && ((int64(1)<<(_la-118))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPropertyModifierContext is an interface to support dynamic dispatch.
type IPropertyModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode

	// IsPropertyModifierContext differentiates from other interfaces.
	IsPropertyModifierContext()
}

type PropertyModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyModifierContext() *PropertyModifierContext {
	var p = new(PropertyModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyModifier
	return p
}

func (*PropertyModifierContext) IsPropertyModifierContext() {}

func NewPropertyModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyModifierContext {
	var p = new(PropertyModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyModifier

	return p
}

func (s *PropertyModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *PropertyModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyModifier(s)
	}
}

func (s *PropertyModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyModifier(s)
	}
}

func (p *KotlinParser) PropertyModifier() (localctx IPropertyModifierContext) {
	this := p
	_ = this

	localctx = NewPropertyModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, KotlinParserRULE_propertyModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3409)
		p.Match(KotlinParserCONST)
	}

	return localctx
}

// IInheritanceModifierContext is an interface to support dynamic dispatch.
type IInheritanceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSTRACT() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	OPEN() antlr.TerminalNode

	// IsInheritanceModifierContext differentiates from other interfaces.
	IsInheritanceModifierContext()
}

type InheritanceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceModifierContext() *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_inheritanceModifier
	return p
}

func (*InheritanceModifierContext) IsInheritanceModifierContext() {}

func NewInheritanceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inheritanceModifier

	return p
}

func (s *InheritanceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *InheritanceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *InheritanceModifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *InheritanceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInheritanceModifier(s)
	}
}

func (s *InheritanceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInheritanceModifier(s)
	}
}

func (p *KotlinParser) InheritanceModifier() (localctx IInheritanceModifierContext) {
	this := p
	_ = this

	localctx = NewInheritanceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, KotlinParserRULE_inheritanceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3411)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IParameterModifierContext is an interface to support dynamic dispatch.
type IParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARARG() antlr.TerminalNode
	NOINLINE() antlr.TerminalNode
	CROSSINLINE() antlr.TerminalNode

	// IsParameterModifierContext differentiates from other interfaces.
	IsParameterModifierContext()
}

type ParameterModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterModifierContext() *ParameterModifierContext {
	var p = new(ParameterModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifier
	return p
}

func (*ParameterModifierContext) IsParameterModifierContext() {}

func NewParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterModifierContext {
	var p = new(ParameterModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterModifier

	return p
}

func (s *ParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterModifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *ParameterModifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *ParameterModifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *ParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterModifier(s)
	}
}

func (s *ParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterModifier(s)
	}
}

func (p *KotlinParser) ParameterModifier() (localctx IParameterModifierContext) {
	this := p
	_ = this

	localctx = NewParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, KotlinParserRULE_parameterModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3413)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReificationModifierContext is an interface to support dynamic dispatch.
type IReificationModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REIFIED() antlr.TerminalNode

	// IsReificationModifierContext differentiates from other interfaces.
	IsReificationModifierContext()
}

type ReificationModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReificationModifierContext() *ReificationModifierContext {
	var p = new(ReificationModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_reificationModifier
	return p
}

func (*ReificationModifierContext) IsReificationModifierContext() {}

func NewReificationModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReificationModifierContext {
	var p = new(ReificationModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_reificationModifier

	return p
}

func (s *ReificationModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReificationModifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *ReificationModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReificationModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReificationModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterReificationModifier(s)
	}
}

func (s *ReificationModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitReificationModifier(s)
	}
}

func (p *KotlinParser) ReificationModifier() (localctx IReificationModifierContext) {
	this := p
	_ = this

	localctx = NewReificationModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, KotlinParserRULE_reificationModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3415)
		p.Match(KotlinParserREIFIED)
	}

	return localctx
}

// IPlatformModifierContext is an interface to support dynamic dispatch.
type IPlatformModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPECT() antlr.TerminalNode
	ACTUAL() antlr.TerminalNode

	// IsPlatformModifierContext differentiates from other interfaces.
	IsPlatformModifierContext()
}

type PlatformModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlatformModifierContext() *PlatformModifierContext {
	var p = new(PlatformModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_platformModifier
	return p
}

func (*PlatformModifierContext) IsPlatformModifierContext() {}

func NewPlatformModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlatformModifierContext {
	var p = new(PlatformModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_platformModifier

	return p
}

func (s *PlatformModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PlatformModifierContext) EXPECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXPECT, 0)
}

func (s *PlatformModifierContext) ACTUAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserACTUAL, 0)
}

func (s *PlatformModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlatformModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlatformModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPlatformModifier(s)
	}
}

func (s *PlatformModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPlatformModifier(s)
	}
}

func (p *KotlinParser) PlatformModifier() (localctx IPlatformModifierContext) {
	this := p
	_ = this

	localctx = NewPlatformModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, KotlinParserRULE_platformModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3417)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserEXPECT || _la == KotlinParserACTUAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleAnnotation() ISingleAnnotationContext
	MultiAnnotation() IMultiAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) SingleAnnotation() ISingleAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleAnnotationContext)
}

func (s *AnnotationContext) MultiAnnotation() IMultiAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiAnnotationContext)
}

func (s *AnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *KotlinParser) Annotation() (localctx IAnnotationContext) {
	this := p
	_ = this

	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, KotlinParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3421)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 525, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3419)
			p.SingleAnnotation()
		}

	case 2:
		{
			p.SetState(3420)
			p.MultiAnnotation()
		}

	}
	p.SetState(3426)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 526, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3423)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(3428)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 526, p.GetParserRuleContext())
	}

	return localctx
}

// ISingleAnnotationContext is an interface to support dynamic dispatch.
type ISingleAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnescapedAnnotation() IUnescapedAnnotationContext
	AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSingleAnnotationContext differentiates from other interfaces.
	IsSingleAnnotationContext()
}

type SingleAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleAnnotationContext() *SingleAnnotationContext {
	var p = new(SingleAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_singleAnnotation
	return p
}

func (*SingleAnnotationContext) IsSingleAnnotationContext() {}

func NewSingleAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleAnnotationContext {
	var p = new(SingleAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_singleAnnotation

	return p
}

func (s *SingleAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleAnnotationContext) UnescapedAnnotation() IUnescapedAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *SingleAnnotationContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationUseSiteTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *SingleAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *SingleAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *SingleAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SingleAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SingleAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSingleAnnotation(s)
	}
}

func (s *SingleAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSingleAnnotation(s)
	}
}

func (p *KotlinParser) SingleAnnotation() (localctx ISingleAnnotationContext) {
	this := p
	_ = this

	localctx = NewSingleAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, KotlinParserRULE_singleAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3438)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 528, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3429)
			p.AnnotationUseSiteTarget()
		}
		p.SetState(3433)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3430)
				p.Match(KotlinParserNL)
			}

			p.SetState(3435)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3436)
			p.Match(KotlinParserAT_NO_WS)
		}

	case 3:
		{
			p.SetState(3437)
			p.Match(KotlinParserAT_PRE_WS)
		}

	}
	{
		p.SetState(3440)
		p.UnescapedAnnotation()
	}

	return localctx
}

// IMultiAnnotationContext is an interface to support dynamic dispatch.
type IMultiAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQUARE() antlr.TerminalNode
	RSQUARE() antlr.TerminalNode
	AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	AllUnescapedAnnotation() []IUnescapedAnnotationContext
	UnescapedAnnotation(i int) IUnescapedAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsMultiAnnotationContext differentiates from other interfaces.
	IsMultiAnnotationContext()
}

type MultiAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiAnnotationContext() *MultiAnnotationContext {
	var p = new(MultiAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiAnnotation
	return p
}

func (*MultiAnnotationContext) IsMultiAnnotationContext() {}

func NewMultiAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiAnnotationContext {
	var p = new(MultiAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiAnnotation

	return p
}

func (s *MultiAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiAnnotationContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *MultiAnnotationContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *MultiAnnotationContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationUseSiteTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *MultiAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *MultiAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *MultiAnnotationContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IUnescapedAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnescapedAnnotationContext); ok {
			tst[i] = t.(IUnescapedAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *MultiAnnotationContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *MultiAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiAnnotation(s)
	}
}

func (s *MultiAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiAnnotation(s)
	}
}

func (p *KotlinParser) MultiAnnotation() (localctx IMultiAnnotationContext) {
	this := p
	_ = this

	localctx = NewMultiAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, KotlinParserRULE_multiAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3451)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 530, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3442)
			p.AnnotationUseSiteTarget()
		}
		p.SetState(3446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3443)
				p.Match(KotlinParserNL)
			}

			p.SetState(3448)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3449)
			p.Match(KotlinParserAT_NO_WS)
		}

	case 3:
		{
			p.SetState(3450)
			p.Match(KotlinParserAT_PRE_WS)
		}

	}
	{
		p.SetState(3453)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(3455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&-17588927330817) != 0) || ((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&2098175) != 0) {
		{
			p.SetState(3454)
			p.UnescapedAnnotation()
		}

		p.SetState(3457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3459)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// IAnnotationUseSiteTargetContext is an interface to support dynamic dispatch.
type IAnnotationUseSiteTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	GET() antlr.TerminalNode
	SET() antlr.TerminalNode
	RECEIVER() antlr.TerminalNode
	PARAM() antlr.TerminalNode
	SETPARAM() antlr.TerminalNode
	DELEGATE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotationUseSiteTargetContext differentiates from other interfaces.
	IsAnnotationUseSiteTargetContext()
}

type AnnotationUseSiteTargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationUseSiteTargetContext() *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget
	return p
}

func (*AnnotationUseSiteTargetContext) IsAnnotationUseSiteTargetContext() {}

func NewAnnotationUseSiteTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget

	return p
}

func (s *AnnotationUseSiteTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationUseSiteTargetContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnnotationUseSiteTargetContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *AnnotationUseSiteTargetContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *AnnotationUseSiteTargetContext) FIELD() antlr.TerminalNode {
	return s.GetToken(KotlinParserFIELD, 0)
}

func (s *AnnotationUseSiteTargetContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROPERTY, 0)
}

func (s *AnnotationUseSiteTargetContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *AnnotationUseSiteTargetContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *AnnotationUseSiteTargetContext) RECEIVER() antlr.TerminalNode {
	return s.GetToken(KotlinParserRECEIVER, 0)
}

func (s *AnnotationUseSiteTargetContext) PARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) SETPARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) DELEGATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserDELEGATE, 0)
}

func (s *AnnotationUseSiteTargetContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationUseSiteTargetContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationUseSiteTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationUseSiteTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationUseSiteTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotationUseSiteTarget(s)
	}
}

func (s *AnnotationUseSiteTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotationUseSiteTarget(s)
	}
}

func (p *KotlinParser) AnnotationUseSiteTarget() (localctx IAnnotationUseSiteTargetContext) {
	this := p
	_ = this

	localctx = NewAnnotationUseSiteTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, KotlinParserRULE_annotationUseSiteTarget)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3461)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3462)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3463)
			p.Match(KotlinParserNL)
		}

		p.SetState(3468)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3469)
		p.Match(KotlinParserCOLON)
	}

	return localctx
}

// IUnescapedAnnotationContext is an interface to support dynamic dispatch.
type IUnescapedAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorInvocation() IConstructorInvocationContext
	UserType() IUserTypeContext

	// IsUnescapedAnnotationContext differentiates from other interfaces.
	IsUnescapedAnnotationContext()
}

type UnescapedAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnescapedAnnotationContext() *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation
	return p
}

func (*UnescapedAnnotationContext) IsUnescapedAnnotationContext() {}

func NewUnescapedAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation

	return p
}

func (s *UnescapedAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnescapedAnnotationContext) ConstructorInvocation() IConstructorInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorInvocationContext)
}

func (s *UnescapedAnnotationContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *UnescapedAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnescapedAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnescapedAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUnescapedAnnotation(s)
	}
}

func (s *UnescapedAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUnescapedAnnotation(s)
	}
}

func (p *KotlinParser) UnescapedAnnotation() (localctx IUnescapedAnnotationContext) {
	this := p
	_ = this

	localctx = NewUnescapedAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, KotlinParserRULE_unescapedAnnotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3473)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 533, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3471)
			p.ConstructorInvocation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3472)
			p.UserType()
		}

	}

	return localctx
}

// ISimpleIdentifierContext is an interface to support dynamic dispatch.
type ISimpleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	ANNOTATION() antlr.TerminalNode
	BY() antlr.TerminalNode
	CATCH() antlr.TerminalNode
	COMPANION() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	CROSSINLINE() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	FINALLY() antlr.TerminalNode
	GET() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INFIX() antlr.TerminalNode
	INIT() antlr.TerminalNode
	INLINE() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	LATEINIT() antlr.TerminalNode
	NOINLINE() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	REIFIED() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	TAILREC() antlr.TerminalNode
	SET() antlr.TerminalNode
	VARARG() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	RECEIVER() antlr.TerminalNode
	PARAM() antlr.TerminalNode
	SETPARAM() antlr.TerminalNode
	DELEGATE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	EXPECT() antlr.TerminalNode
	ACTUAL() antlr.TerminalNode
	CONST() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsSimpleIdentifierContext differentiates from other interfaces.
	IsSimpleIdentifierContext()
}

type SimpleIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdentifierContext() *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleIdentifier
	return p
}

func (*SimpleIdentifierContext) IsSimpleIdentifierContext() {}

func NewSimpleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleIdentifier

	return p
}

func (s *SimpleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(KotlinParserIdentifier, 0)
}

func (s *SimpleIdentifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *SimpleIdentifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *SimpleIdentifierContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *SimpleIdentifierContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *SimpleIdentifierContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *SimpleIdentifierContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SimpleIdentifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *SimpleIdentifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *SimpleIdentifierContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *SimpleIdentifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *SimpleIdentifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *SimpleIdentifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *SimpleIdentifierContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *SimpleIdentifierContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *SimpleIdentifierContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *SimpleIdentifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *SimpleIdentifierContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *SimpleIdentifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *SimpleIdentifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *SimpleIdentifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *SimpleIdentifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *SimpleIdentifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *SimpleIdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *SimpleIdentifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *SimpleIdentifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *SimpleIdentifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *SimpleIdentifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *SimpleIdentifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *SimpleIdentifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *SimpleIdentifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *SimpleIdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *SimpleIdentifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *SimpleIdentifierContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *SimpleIdentifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *SimpleIdentifierContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *SimpleIdentifierContext) FIELD() antlr.TerminalNode {
	return s.GetToken(KotlinParserFIELD, 0)
}

func (s *SimpleIdentifierContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROPERTY, 0)
}

func (s *SimpleIdentifierContext) RECEIVER() antlr.TerminalNode {
	return s.GetToken(KotlinParserRECEIVER, 0)
}

func (s *SimpleIdentifierContext) PARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserPARAM, 0)
}

func (s *SimpleIdentifierContext) SETPARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETPARAM, 0)
}

func (s *SimpleIdentifierContext) DELEGATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserDELEGATE, 0)
}

func (s *SimpleIdentifierContext) FILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, 0)
}

func (s *SimpleIdentifierContext) EXPECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXPECT, 0)
}

func (s *SimpleIdentifierContext) ACTUAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserACTUAL, 0)
}

func (s *SimpleIdentifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *SimpleIdentifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *SimpleIdentifierContext) VALUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserVALUE, 0)
}

func (s *SimpleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleIdentifier(s)
	}
}

func (p *KotlinParser) SimpleIdentifier() (localctx ISimpleIdentifierContext) {
	this := p
	_ = this

	localctx = NewSimpleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, KotlinParserRULE_simpleIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3475)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&-17588927330817) != 0) || ((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&2098175) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleIdentifier() []ISimpleIdentifierContext
	SimpleIdentifier(i int) ISimpleIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdentifierContext); ok {
			tst[i] = t.(ISimpleIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *IdentifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IdentifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *KotlinParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, KotlinParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3477)
		p.SimpleIdentifier()
	}
	p.SetState(3488)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 535, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3481)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3478)
					p.Match(KotlinParserNL)
				}

				p.SetState(3483)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3484)
				p.Match(KotlinParserDOT)
			}
			{
				p.SetState(3485)
				p.SimpleIdentifier()
			}

		}
		p.SetState(3490)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 535, p.GetParserRuleContext())
	}

	return localctx
}
